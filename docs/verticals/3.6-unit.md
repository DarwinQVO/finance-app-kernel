# Vertical 3.6: Unit (Currency & Date Normalization)

> **Type:** Value Normalization System
> **Pattern:** Value Object + Adapter + Strategy Pattern
> **Last Updated:** 2025-10-24

---

## üìã Overview

The **Unit** vertical provides a **value normalization system** for converting and displaying amounts across currencies, timezones, and numerical formats. While demonstrated in finance domain (multi-currency transactions, exchange rates), the underlying primitives are domain-agnostic and apply to ANY unit conversion and value normalization.

**Key Characteristics:**
- **Multi-Currency:** Support hundreds of currencies with automatic conversion to user's base currency
- **Exchange Rate Management:** Multi-source rate fetching (ECB, Federal Reserve, manual) with caching and staleness detection
- **Context Preservation:** Store original + normalized values to maintain provenance
- **Timezone Normalization:** Convert local dates/times to UTC storage, display in user's timezone
- **Precision Rules:** Configurable decimal places (2 for fiat, 4 for crypto, 8 for BTC)
- **Display Formatting:** Locale-aware number formatting (thousands separators, decimal symbols)

**Finance Domain Examples:**
- Convert USD transactions to MXN base currency for Mexican user
- Display EUR expense with original amount + USD equivalent
- Fetch exchange rates from ECB (European Central Bank) with Federal Reserve fallback
- Store transaction dates in UTC, display in America/Mexico_City timezone
- Format $1,234.56 as "$1,234.56" (US) or "$1.234,56" (ES)

**Multi-Domain Applicability:**
- Healthcare: Currency conversion for international medical claims, timezone handling for global clinical trials
- E-commerce: Product pricing in multiple currencies, cross-border transaction display
- Legal: International billing with currency conversion, jurisdiction timezone normalization
- Travel: Expense reporting in foreign currencies with automatic conversion
- Manufacturing: Unit conversion (imperial ‚Üî metric), temperature scales (F ‚Üî C)

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Multi-currency normalization (convert to user's base currency)
- Exchange rate fetching from multiple sources (ECB, Federal Reserve, manual override)
- Exchange rate caching with staleness detection (24-hour TTL)
- Historical exchange rate support (get rate for specific date)
- Original + normalized amount storage (context preservation)
- Date/time normalization (user timezone ‚Üí UTC storage)
- Display formatting with locale awareness (en-US, es-MX, de-DE, etc.)
- Precision rules by currency type (fiat 2 decimals, crypto 4-8 decimals)
- Currency configuration per user (base currency, timezone, display locale)
- Rate refresh UI (manual refresh for stale rates)

**Out of Scope:**
- Cryptocurrency price tracking (real-time updates, covered in future vertical)
- Tax calculation on currency gains/losses (covered in 4.x Tax Engine)
- Payment processing with currency conversion (separate workflow)
- Historical price charts (covered in 2.3 Dashboard)
- Forward rate contracts or hedging (advanced treasury)
- Blockchain integration for crypto transactions

**Boundaries:**
- Exchange rates updated daily (not real-time, except manual refresh)
- Rates older than 24 hours marked as "stale" (visual indicator)
- User can override system rate with manual rate (audit trail)
- One base currency per user (cannot have multi-base simultaneously)
- Timezone applies globally to all dates (not per-transaction)

---

### 2. User Flow (Real Usage)

**Scenario 1: User sets base currency during onboarding**

User: "I want to track all expenses in Mexican Pesos (MXN)"

System:
1. During onboarding, CurrencySelectorDialog appears
2. User sees list of popular currencies first:
   - üá∫üá∏ USD - US Dollar
   - üá™üá∫ EUR - Euro
   - üá≤üáΩ MXN - Mexican Peso
   - üá¨üáß GBP - British Pound
   - üáØüáµ JPY - Japanese Yen
3. User clicks "üá≤üáΩ MXN - Mexican Peso"
4. System prompts for timezone: "America/Mexico_City" (auto-detected)
5. System prompts for display locale: "es-MX" (auto-detected from browser)
6. System creates CurrencyConfig:
   ```json
   {
     "user_id": "user_123",
     "base_currency": "MXN",
     "precision": 2,
     "display_locale": "es-MX",
     "timezone": "America/Mexico_City",
     "rate_sources": ["ecb", "federal_reserve", "manual"]
   }
   ```
7. User sees confirmation: "‚úÖ Base currency set to MXN"

**Scenario 2: User views transaction with currency conversion**

User: "I spent $100 USD while traveling - how much is that in my base currency (MXN)?"

System:
1. User imports transaction from credit card:
   - Original: $100.00 USD
   - Date: 2024-11-01
2. CurrencyConverter.convert() runs automatically:
   - from_currency: USD
   - to_currency: MXN (user's base)
   - rate_date: 2024-11-01
3. ExchangeRateProvider.get_rate() fetches rate:
   - Checks cache first (rate_usd_mxn_20241101)
   - Cache miss ‚Üí Fetch from ECB API
   - ECB returns: 1 USD = 18.5000 MXN
   - Cache rate with 24h TTL
4. Normalized amount calculated:
   - $100.00 USD √ó 18.5000 = $1,850.00 MXN
5. Creates NormalizedAmount:
   ```json
   {
     "original_amount": 100.00,
     "original_currency": "USD",
     "normalized_amount": 1850.00,
     "base_currency": "MXN",
     "exchange_rate": 18.5000,
     "rate_date": "2024-11-01",
     "rate_source": "ecb"
   }
   ```
6. User sees in TransactionList:
   - Primary: $1,850.00 MXN
   - Secondary: ($100.00 USD @ 18.50)
7. AmountDisplayCard shows dual currency display

**Scenario 3: User refreshes stale exchange rate**

Background: Rate was fetched 25 hours ago (stale threshold: 24h)

User: "This rate looks outdated - I want to refresh it"

System:
1. User views transaction, sees stale indicator: "‚ö†Ô∏è Rate from 2024-10-31 (stale)"
2. ExchangeRateWidget displays:
   - From: USD
   - To: MXN
   - Rate: 18.5000
   - Date: 2024-10-31
   - Status: "Stale (fetched 25 hours ago)"
3. User clicks "üîÑ Refresh Rate"
4. System:
   - Shows loading spinner: "Refreshing..."
   - Calls ExchangeRateProvider.refresh_cache()
   - Fetches latest rate from ECB
   - New rate: 1 USD = 18.7500 MXN (rate changed!)
5. System asks: "Update all transactions using old rate?"
   - Option A: "Update all USD‚ÜíMXN transactions from Oct 31" (batch update)
   - Option B: "Only this transaction" (single update)
6. User selects Option A
7. System:
   - Re-normalizes all affected transactions
   - Updates normalized_amount: $100.00 √ó 18.7500 = $1,875.00 MXN
   - Logs rate change in audit trail
8. User sees updated display:
   - $1,875.00 MXN ($100.00 USD @ 18.75)
   - "‚úÖ Rate updated to 2024-11-01"

**Scenario 4: User manually overrides exchange rate**

User: "The bank charged me a different rate - I want to use the actual rate I paid"

System:
1. User views transaction: $100.00 USD ‚Üí $1,850.00 MXN (@ 18.50)
2. User clicks "Edit Rate" in ExchangeRateWidget
3. Dialog appears:
   - Current Rate: 18.5000 (from ECB)
   - Override Rate: [input field]
   - Reason: [text area]
4. User enters:
   - Override Rate: 19.0000
   - Reason: "Bank charged higher rate due to foreign transaction fee"
5. System validates:
   - Rate > 0? ‚úÖ
   - Variance from ECB rate: 2.7% (within 10% tolerance) ‚úÖ
6. System recalculates:
   - $100.00 USD √ó 19.0000 = $1,900.00 MXN
7. Updates NormalizedAmount:
   ```json
   {
     "original_amount": 100.00,
     "original_currency": "USD",
     "normalized_amount": 1900.00,
     "base_currency": "MXN",
     "exchange_rate": 19.0000,
     "rate_date": "2024-11-01",
     "rate_source": "manual",
     "override_reason": "Bank charged higher rate due to foreign transaction fee"
   }
   ```
8. User sees: $1,900.00 MXN ($100.00 USD @ 19.00*)
   - "*" indicates manual override
9. Audit trail logs manual rate change

**Scenario 5: User changes timezone**

User: "I moved from Mexico to Spain - I want dates in Europe/Madrid timezone"

System:
1. User opens Settings ‚Üí Currency & Display
2. Current timezone: "America/Mexico_City (GMT-6)"
3. User clicks "Change Timezone"
4. Dropdown shows:
   - Popular timezones (America/New_York, Europe/London, Asia/Tokyo)
   - Search: "madrid"
5. User selects "Europe/Madrid (GMT+1)"
6. System updates CurrencyConfig:
   ```json
   {
     "timezone": "Europe/Madrid"
   }
   ```
7. System re-renders all dates:
   - Before: "Nov 1, 2024 10:00 AM" (Mexico City time)
   - After: "Nov 1, 2024 5:00 PM" (Madrid time)
   - UTC stored value unchanged: "2024-11-01T16:00:00Z"
8. User sees confirmation: "‚úÖ Timezone changed to Europe/Madrid"

**Scenario 6: User views historical exchange rate**

User: "What was the USD/EUR rate 6 months ago?"

System:
1. User navigates to Settings ‚Üí Exchange Rate History
2. Input form appears:
   - From Currency: [dropdown] ‚Üí USD
   - To Currency: [dropdown] ‚Üí EUR
   - Date: [date picker] ‚Üí 2024-05-01
3. User submits
4. System calls ExchangeRateProvider.get_rate(USD, EUR, "2024-05-01")
5. Checks historical cache (rate_usd_eur_20240501)
6. Cache miss ‚Üí Fetch from ECB historical API
7. Returns: 1 USD = 0.9200 EUR (May 1, 2024)
8. Displays:
   - Rate: 0.9200
   - Date: May 1, 2024
   - Source: ECB Historical
   - Trend: "+2.1% vs today's rate (0.9400)"

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `CurrencyConverter` - Convert amounts between currencies (NEW - this vertical)
- `DateNormalizer` - Normalize dates between timezones and UTC (NEW - this vertical)
- `AmountFormatter` - Format amounts with locale-aware display rules (NEW - this vertical)
- `ExchangeRateProvider` - Fetch and cache exchange rates from multiple sources (NEW - this vertical)
- `CurrencyConfigStore` - CRUD for user currency configuration (NEW - this vertical)
- `TransactionStore` - Store normalized_amount on transactions (from 1.3)

**Interaction Layer (IL):**
- `CurrencySelectorDialog` - Modal for selecting base currency (NEW - this vertical)
- `AmountDisplayCard` - Display original + normalized amounts side-by-side (NEW - this vertical)
- `ExchangeRateWidget` - Display rate with refresh button and staleness indicator (NEW - this vertical)
- `TransactionList` - View transactions with normalized amounts (from 2.1)
- `DrillDownPanel` - View currency details in transaction detail (from 2.2)

**Schemas:**
- `normalized-amount.schema.json` - Original + normalized amount with rate metadata (NEW - this vertical)
- `exchange-rate-record.schema.json` - Cached exchange rate record (NEW - this vertical)
- `currency-config.schema.json` - User currency and display preferences (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# Get User Currency Configuration
GET /api/user/currency-config
Authorization: Bearer {token}

Response 200:
{
  "user_id": "user_123",
  "base_currency": "MXN",
  "precision": 2,
  "display_locale": "es-MX",
  "timezone": "America/Mexico_City",
  "rate_sources": ["ecb", "federal_reserve", "manual"],
  "created_at": "2024-11-01T10:00:00Z",
  "updated_at": "2024-11-01T10:00:00Z"
}
```

```http
# Update Base Currency
PATCH /api/user/currency-config
Authorization: Bearer {token}
Content-Type: application/json

{
  "base_currency": "EUR",
  "timezone": "Europe/Madrid",
  "display_locale": "es-ES"
}

Response 200:
{
  "user_id": "user_123",
  "base_currency": "EUR",
  "precision": 2,
  "display_locale": "es-ES",
  "timezone": "Europe/Madrid",
  "rate_sources": ["ecb", "federal_reserve", "manual"],
  "updated_at": "2024-11-01T10:30:00Z"
}
```

```http
# Get Exchange Rate (specific date)
GET /api/exchange-rates?from=USD&to=MXN&date=2024-11-01
Authorization: Bearer {token}

Response 200:
{
  "rate_id": "rate_usd_mxn_20241101",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 18.5000,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "fetched_at": "2024-11-01T08:00:00Z",
  "is_stale": false,
  "expires_at": "2024-11-02T08:00:00Z"
}
```

```http
# Refresh Exchange Rate (force update)
POST /api/exchange-rates/refresh
Authorization: Bearer {token}
Content-Type: application/json

{
  "from_currency": "USD",
  "to_currency": "MXN",
  "apply_to_transactions": true  // Update all transactions using this rate
}

Response 200:
{
  "old_rate": 18.5000,
  "new_rate": 18.7500,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "transactions_updated": 15,
  "message": "Rate refreshed and applied to 15 transactions"
}
```

```http
# Override Exchange Rate (manual)
POST /api/exchange-rates/override
Authorization: Bearer {token}
Content-Type: application/json

{
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 19.0000,
  "rate_date": "2024-11-01",
  "reason": "Bank charged higher rate due to foreign transaction fee",
  "transaction_id": "txn_12345"  // Optional: apply only to this transaction
}

Response 201:
{
  "rate_id": "rate_usd_mxn_20241101_manual_user123",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 19.0000,
  "rate_date": "2024-11-01",
  "source": "manual",
  "override_reason": "Bank charged higher rate due to foreign transaction fee",
  "variance_from_ecb": 2.7,
  "created_at": "2024-11-01T10:30:00Z"
}
```

```http
# Convert Amount (preview - no persistence)
POST /api/convert
Authorization: Bearer {token}
Content-Type: application/json

{
  "amount": 100.00,
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate_date": "2024-11-01"
}

Response 200:
{
  "original_amount": 100.00,
  "original_currency": "USD",
  "converted_amount": 1850.00,
  "target_currency": "MXN",
  "exchange_rate": 18.5000,
  "rate_date": "2024-11-01",
  "rate_source": "ecb"
}
```

**Internal OL API:**

```python
class CurrencyConverter:
    def convert(self, amount: Decimal, from_currency: str, to_currency: str,
                rate_date: date) -> NormalizedAmount:
        """
        Converts amount from one currency to another.

        Args:
            amount: Original amount
            from_currency: ISO 4217 currency code (e.g., "USD")
            to_currency: ISO 4217 currency code (e.g., "MXN")
            rate_date: Date for exchange rate lookup

        Returns:
            NormalizedAmount with original + converted values and rate metadata

        Raises:
            UnsupportedCurrencyError: If currency not in ISO 4217
            RateNotAvailableError: If no rate found for date
        """

    def batch_convert(self, transactions: List[Transaction]) -> Dict[str, NormalizedAmount]:
        """Batch conversion for performance (single rate fetch per currency pair)."""

class DateNormalizer:
    def normalize(self, user_date: datetime, user_tz: str) -> datetime:
        """
        Converts user timezone datetime to UTC.

        Args:
            user_date: Datetime in user's local timezone
            user_tz: IANA timezone (e.g., "America/Mexico_City")

        Returns:
            UTC datetime (timezone-aware)
        """

    def display(self, utc_datetime: datetime, user_tz: str) -> str:
        """
        Formats UTC datetime for display in user's timezone.

        Returns:
            Formatted string (e.g., "Nov 1, 2024 10:00 AM")
        """

class AmountFormatter:
    def format(self, amount: Decimal, currency: str, locale: str) -> str:
        """
        Formats amount with locale-aware rules.

        Args:
            amount: Decimal amount
            currency: ISO 4217 currency code
            locale: BCP 47 locale (e.g., "en-US", "es-MX")

        Returns:
            Formatted string (e.g., "$1,234.56" for en-US, "$1.234,56" for es-ES)
        """

class ExchangeRateProvider:
    def get_rate(self, from_currency: str, to_currency: str,
                 rate_date: date) -> ExchangeRateRecord:
        """
        Gets exchange rate from cache or fetches from source.

        Rate Source Priority:
        1. Cache (if fresh, < 24h)
        2. ECB API (European Central Bank)
        3. Federal Reserve API
        4. Manual override (user-provided)

        Returns:
            ExchangeRateRecord with rate and metadata

        Raises:
            RateNotAvailableError: If all sources fail
        """

    def refresh_cache(self, from_currency: str, to_currency: str) -> ExchangeRateRecord:
        """Forces cache invalidation and fetches fresh rate."""

    def get_historical(self, from_currency: str, to_currency: str,
                       start_date: date, end_date: date) -> List[ExchangeRateRecord]:
        """Fetches historical rates for date range (for charts)."""

class CurrencyConfigStore:
    def get(self, user_id: str) -> CurrencyConfig:
        """Gets user's currency configuration."""

    def update(self, user_id: str, base_currency: Optional[str] = None,
               timezone: Optional[str] = None,
               display_locale: Optional[str] = None) -> CurrencyConfig:
        """
        Updates user's currency configuration.

        Raises:
            InvalidCurrencyError: If base_currency not in ISO 4217
            InvalidTimezoneError: If timezone not in IANA database
            InvalidLocaleError: If locale not in BCP 47
        """
```

---

### 5. Schemas / Tipos (Persistencia)

**NormalizedAmount Schema (embedded in Transaction):**

```json
{
  "original_amount": 100.00,
  "original_currency": "USD",
  "normalized_amount": 1850.00,
  "base_currency": "MXN",
  "exchange_rate": 18.5000,
  "rate_date": "2024-11-01",
  "rate_source": "ecb",
  "override_reason": null
}
```

**ExchangeRateRecord Schema:**

```json
{
  "rate_id": "rate_usd_mxn_20241101",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 18.5000,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "fetched_at": "2024-11-01T08:00:00Z",
  "is_stale": false,
  "expires_at": "2024-11-02T08:00:00Z"
}
```

**CurrencyConfig Schema:**

```json
{
  "user_id": "user_123",
  "base_currency": "MXN",
  "precision": 2,
  "display_locale": "es-MX",
  "timezone": "America/Mexico_City",
  "rate_sources": ["ecb", "federal_reserve", "manual"],
  "created_at": "2024-11-01T10:00:00Z",
  "updated_at": "2024-11-01T10:00:00Z"
}
```

**Supported Currencies (ISO 4217):**
- Major: USD, EUR, GBP, JPY, MXN, CAD, AUD, CHF, CNY
- Crypto: BTC, ETH (precision: 8 decimals)
- Total: 150+ fiat currencies supported

**Exchange Rate Sources:**
- `ecb` - European Central Bank (primary, updated daily at 16:00 CET)
- `federal_reserve` - US Federal Reserve (fallback, updated daily)
- `manual` - User-provided override

**Precision Rules:**
- Fiat currencies: 2 decimals (e.g., $1.23)
- Crypto (major): 4 decimals (e.g., 0.1234 ETH)
- Bitcoin: 8 decimals (e.g., 0.00012345 BTC)

---

### 6. Validaciones & Estados

**Currency Configuration Validations:**
- Base currency: Must be valid ISO 4217 code (3 uppercase letters)
- Timezone: Must be valid IANA timezone (e.g., "America/Mexico_City")
- Display locale: Must be valid BCP 47 locale (e.g., "es-MX")
- Precision: Integer, 0-8 (matches currency type)
- Rate sources: Array of ["ecb", "federal_reserve", "manual"]

**Exchange Rate Validations:**
- From/To currency: Must be valid ISO 4217, cannot be equal
- Rate: Decimal > 0, max 6 decimals (e.g., 18.5000)
- Rate date: Cannot be in future
- Manual override: Variance from system rate < 10% (warning if higher)

**Amount Conversion Validations:**
- Amount: Decimal, can be negative (for expenses)
- Precision matches target currency (2 for fiat, 4-8 for crypto)
- Overflow protection: Max amount = 999,999,999.99

**State Machine (Exchange Rate):**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  fresh   ‚îÇ‚îÄ‚îÄ24h elapsed‚îÄ‚îÄ‚ñ∂‚îÇ  stale  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚ñ≤                           ‚îÇ
     ‚îÇ refresh_cache()           ‚îÇ
     ‚îÇ                           ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

States:
- fresh: Rate fetched < 24h ago, use cached value
- stale: Rate fetched ‚â• 24h ago, show warning, allow refresh
```

---

### 7. Edge Cases

**EC1: Rate not available for historical date**
- Problem: User imports transaction from 2020, but ECB only has data since 2021
- **Solution:**
  - Try Federal Reserve (longer history)
  - If still unavailable, require manual rate entry
  - Show warning: "Rate not available - please enter manually"

**EC2: Currency mismatch (transaction currency ‚â† account currency)**
- Problem: USD account, but transaction in EUR (foreign merchant)
- **Solution:**
  - Convert EUR ‚Üí USD (account currency) ‚Üí MXN (base currency)
  - Store intermediate conversion in audit trail
  - Example: ‚Ç¨100 ‚Üí $110 USD ‚Üí $2,035 MXN (two-step conversion)

**EC3: Same-day rate changes (multiple fetches)**
- Problem: User refreshes rate twice in same day, but ECB updates at 16:00 CET
- **Solution:**
  - Check if fetched_at > ECB update time (16:00 CET)
  - If before, show: "Waiting for today's rate (updates at 16:00 CET)"
  - If after, allow refresh

**EC4: Leap second / DST transition**
- Problem: Date normalization during daylight saving time change
- **Solution:**
  - Use pytz/tzinfo for DST-aware conversions
  - Store UTC timestamp (no DST ambiguity)
  - Display in user's local time with DST indicator

**EC5: Crypto currency high volatility**
- Problem: BTC/USD rate changes 5% in 1 hour
- **Solution:**
  - Mark crypto rates as stale after 1 hour (not 24h)
  - Show real-time warning: "‚ö†Ô∏è Crypto rates are volatile"
  - Allow manual refresh more frequently

**EC6: User changes base currency mid-month**
- Problem: User has 50 transactions in USD, switches base from USD to EUR
- **Solution:**
  - Re-normalize ALL transactions (batch operation)
  - Show progress: "Re-normalizing 50 transactions..."
  - Preserve original amounts (no data loss)
  - Log base currency change in audit trail

**EC7: Inverse rate calculation**
- Problem: System has USD‚ÜíMXN rate (18.50), user needs MXN‚ÜíUSD
- **Solution:**
  - Calculate inverse: MXN‚ÜíUSD = 1 / 18.50 = 0.0541
  - Cache both directions (rate_usd_mxn and rate_mxn_usd)
  - Ensure precision maintained (6 decimals)

---

### 8. Acceptance Criteria (Definition of Done)

**Currency Configuration:**
- [ ] User can select base currency from 150+ ISO 4217 currencies
- [ ] User can set timezone from IANA database
- [ ] User can set display locale (en-US, es-MX, de-DE, etc.)
- [ ] System validates all configuration fields
- [ ] User can change base currency (triggers re-normalization of all transactions)

**Currency Conversion:**
- [ ] System automatically converts all transactions to base currency
- [ ] System stores original + normalized amounts (context preservation)
- [ ] System fetches rates from ECB (primary) and Federal Reserve (fallback)
- [ ] System caches rates with 24-hour TTL
- [ ] User can see both original and normalized amounts side-by-side
- [ ] User can manually override exchange rate with reason

**Exchange Rate Management:**
- [ ] System marks rates older than 24h as "stale"
- [ ] User can refresh stale rates manually
- [ ] User can view historical rates (date range query)
- [ ] System logs all rate fetches and manual overrides
- [ ] System shows rate source (ECB, Federal Reserve, manual)
- [ ] User can batch-update transactions after rate refresh

**Date/Time Normalization:**
- [ ] System stores all dates in UTC (timezone-agnostic)
- [ ] System displays dates in user's local timezone
- [ ] User can change timezone (re-renders all dates)
- [ ] System handles DST transitions correctly
- [ ] System uses ISO 8601 format for API responses

**Display Formatting:**
- [ ] System formats amounts with locale-aware rules (thousands separator, decimal symbol)
- [ ] System applies precision rules (2 for fiat, 4-8 for crypto)
- [ ] User sees currency symbol based on locale ($ vs ‚Ç¨ vs ¬£)
- [ ] System handles negative amounts (expenses) correctly

**Multi-Domain:**
- [ ] Pattern applies to Healthcare (currency conversion for international claims)
- [ ] Pattern applies to E-commerce (product pricing in multiple currencies)
- [ ] Pattern applies to Travel (expense reporting in foreign currencies)
- [ ] Pattern applies to Manufacturing (unit conversion: imperial ‚Üî metric)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "currency_converted",
  "transaction_id": "txn_12345",
  "original_amount": 100.00,
  "original_currency": "USD",
  "normalized_amount": 1850.00,
  "base_currency": "MXN",
  "exchange_rate": 18.5000,
  "rate_source": "ecb",
  "rate_date": "2024-11-01",
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:00:00Z"
}
```

```json
{
  "event": "exchange_rate_refreshed",
  "from_currency": "USD",
  "to_currency": "MXN",
  "old_rate": 18.5000,
  "new_rate": 18.7500,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "transactions_updated": 15,
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:30:00Z"
}
```

```json
{
  "event": "exchange_rate_manual_override",
  "from_currency": "USD",
  "to_currency": "MXN",
  "system_rate": 18.5000,
  "manual_rate": 19.0000,
  "variance_percent": 2.7,
  "reason": "Bank charged higher rate due to foreign transaction fee",
  "transaction_id": "txn_12345",
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:35:00Z"
}
```

```json
{
  "event": "base_currency_changed",
  "old_currency": "USD",
  "new_currency": "EUR",
  "transactions_renormalized": 50,
  "user_id": "user_123",
  "timestamp": "2024-11-01T11:00:00Z"
}
```

**Provenance Chain:**
```
Transaction Imported (1.1)
  ‚Üì
Original Amount Extracted (1.3 Normalization)
  ‚Üì
ExchangeRateProvider.get_rate() (3.6)
  ‚Üì
  ‚îú‚îÄ Check Cache (fresh/stale?)
  ‚îÇ   ‚îú‚îÄ Cache HIT (fresh) ‚Üí Use cached rate
  ‚îÇ   ‚îî‚îÄ Cache MISS/stale ‚Üí Fetch from ECB
  ‚îÇ       ‚îú‚îÄ ECB Success ‚Üí Cache + Return
  ‚îÇ       ‚îî‚îÄ ECB Fail ‚Üí Fallback to Federal Reserve
  ‚Üì
CurrencyConverter.convert() (3.6)
  ‚Üì
NormalizedAmount Created
  ‚Üì
Stored in Transaction.normalized_amount (1.3)
  ‚Üì
Displayed in TransactionList (2.1)
```

---

### 10. Risks & Deferred

**Risks:**
- **R1: Exchange rate API downtime** - ECB or Federal Reserve APIs unavailable
  - **Mitigation:** Multi-source fallback, cache last-known-good rates, manual override option
- **R2: Rate volatility (crypto)** - Crypto rates change rapidly (5%+ per hour)
  - **Mitigation:** Shorter staleness threshold for crypto (1h vs 24h), real-time warning
- **R3: Timezone complexity** - DST transitions, leap seconds, historical timezone changes
  - **Mitigation:** Use battle-tested libraries (pytz, moment-timezone), store UTC only
- **R4: Precision loss** - Floating-point arithmetic errors in currency conversion
  - **Mitigation:** Use Decimal type (Python) or BigDecimal (Java), fixed-point arithmetic

**Deferred:**
- **D1: Real-time crypto prices** - Live BTC/ETH price tracking moved to 4.x Crypto vertical
- **D2: Forward rate contracts** - Currency hedging for future transactions (advanced treasury)
- **D3: Multi-base currency** - Allow users to track in multiple base currencies simultaneously
- **D4: Rate alerts** - Notify user when rate crosses threshold (e.g., USD/MXN > 20.00)
- **D5: Historical price charts** - Line chart showing rate trends moved to 2.3 Dashboard

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 5 new primitives:**

1. **CurrencyConverter** - Convert amounts between currencies
   - File: `docs/primitives/ol/CurrencyConverter.md`
   - Methods: convert, batch_convert, get_precision
   - Responsibilities: Currency conversion, precision handling, batch optimization

2. **DateNormalizer** - Normalize dates between timezones and UTC
   - File: `docs/primitives/ol/DateNormalizer.md`
   - Methods: normalize, display, parse_iso8601
   - Responsibilities: Timezone conversion, DST handling, ISO 8601 compliance

3. **AmountFormatter** - Format amounts with locale-aware rules
   - File: `docs/primitives/ol/AmountFormatter.md`
   - Methods: format, parse, get_locale_rules
   - Responsibilities: Number formatting, currency symbols, locale handling

4. **ExchangeRateProvider** - Fetch and cache exchange rates
   - File: `docs/primitives/ol/ExchangeRateProvider.md`
   - Methods: get_rate, refresh_cache, get_historical, fetch_from_ecb, fetch_from_fed
   - Responsibilities: Multi-source fetching, caching, staleness detection

5. **CurrencyConfigStore** - CRUD for user currency configuration
   - File: `docs/primitives/ol/CurrencyConfigStore.md`
   - Methods: get, update, validate_currency, validate_timezone
   - Responsibilities: Configuration persistence, validation

**Interaction Layer (IL) - 3 new components:**

6. **CurrencySelectorDialog** - Modal for selecting base currency
   - File: `docs/primitives/il/CurrencySelectorDialog.md`
   - Features: Currency list with flags, search, popular currencies first
   - Responsibilities: Currency selection UI, search functionality

7. **AmountDisplayCard** - Display original + normalized amounts
   - File: `docs/primitives/il/AmountDisplayCard.md`
   - Features: Dual currency display, rate tooltip, original amount toggle
   - Responsibilities: Amount visualization, side-by-side display

8. **ExchangeRateWidget** - Display rate with refresh button
   - File: `docs/primitives/il/ExchangeRateWidget.md`
   - Features: Rate display, staleness indicator, refresh button, source badge
   - Responsibilities: Rate visualization, refresh UI, staleness warning

**Schemas - 3 new:**

9. **normalized-amount.schema.json** - Original + normalized amount with rate metadata
10. **exchange-rate-record.schema.json** - Cached exchange rate record
11. **currency-config.schema.json** - User currency and display preferences

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **1.3 Normalization** - Transactions must be normalized before currency conversion
- **1.1 Observation Capture** - Original currency detected from source data
- **2.1 Transaction List** - Display normalized amounts in list view

**Used By:**
- **2.3 Finance Dashboard** - Display totals in base currency
- **4.2 Forecast** - Project future expenses in base currency
- **3.4 Tax Categorization** - Deductions calculated in base currency
- **Future: 4.x Reporting** - Export data in base currency

**Data Flow:**
```
Transaction Imported (1.1)
  ‚Üì
Original Amount Extracted (1.3) ‚Üí "100.00 USD"
  ‚Üì
ExchangeRateProvider fetches rate (3.6) ‚Üí "18.5000"
  ‚Üì
CurrencyConverter normalizes (3.6) ‚Üí "1,850.00 MXN"
  ‚Üì
NormalizedAmount stored in Transaction
  ‚Üì
TransactionList displays (2.1) ‚Üí "$1,850.00 MXN ($100.00 USD)"
  ‚Üì
Dashboard aggregates (2.3) ‚Üí "Total: $45,000 MXN"
```

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Value Normalization + Unit Conversion + Context Preservation**

This pattern applies to **any domain requiring unit conversion and display normalization**:

**Finance:**
- Unit: Currency (USD, EUR, MXN)
- Conversion: Exchange rates from ECB/Federal Reserve
- Context: Original amount + normalized amount + rate metadata
- Use Case: Multi-currency expense tracking

**Healthcare:**
- Unit: Currency (USD, EUR) for international claims
- Conversion: Exchange rates for cross-border reimbursement
- Context: Original claim amount + USD equivalent + rate date
- Use Case: International medical billing

**E-commerce:**
- Unit: Currency (customer's local currency ‚Üí merchant's base currency)
- Conversion: Real-time exchange rates + payment processor fees
- Context: Display price + actual charged amount + conversion rate
- Use Case: Cross-border online shopping

**Travel:**
- Unit: Currency (foreign currency ‚Üí traveler's home currency)
- Conversion: Exchange rates + credit card foreign transaction fees
- Context: Merchant charge + home currency equivalent + total fees
- Use Case: Travel expense reporting

**Manufacturing:**
- Unit: Temperature (Fahrenheit ‚Üî Celsius ‚Üî Kelvin)
- Conversion: Fixed formula (no external API)
- Context: Original reading + normalized value + conversion formula
- Use Case: Quality control in global factories

**Science/Research:**
- Unit: Measurement (imperial ‚Üî metric, pounds ‚Üî kilograms)
- Conversion: Fixed conversion factors
- Context: Original measurement + SI unit + conversion factor
- Use Case: Lab data normalization

**Key Abstraction:**
```python
class ValueNormalizer[TOriginal, TNormalized]:
    """
    Universal pattern for value normalization with context preservation.

    Generic enough to apply across:
    - Finance: Currency conversion (USD ‚Üí EUR)
    - Temperature: Scale conversion (F ‚Üí C)
    - Distance: Unit conversion (miles ‚Üí km)
    - Time: Timezone conversion (EST ‚Üí UTC)
    """
    original_value: TOriginal
    original_unit: str
    normalized_value: TNormalized
    target_unit: str
    conversion_rate: Decimal  # or formula
    conversion_source: str  # API, formula, manual
    converted_at: datetime

class ConversionRateProvider[TFromUnit, TToUnit]:
    """
    Fetches conversion rates/formulas with caching.

    Examples:
    - Currency: Fetch from ECB API, cache 24h
    - Temperature: Return fixed formula, cache forever
    - Distance: Return fixed factor, cache forever
    """
    def get_rate(from_unit: TFromUnit, to_unit: TToUnit,
                 context_date: Optional[date] = None) -> Decimal:
        """Returns conversion rate/factor."""

    def refresh_cache(from_unit: TFromUnit, to_unit: TToUnit) -> Decimal:
        """Forces cache invalidation and refetch."""
```

---

### 14. Pattern Abstraction

**Pattern Name:** Value Normalization + Unit Conversion + Context Preservation

**Problem Statement:**
Users need to work with values in different units (currencies, temperatures, distances, timezones) while maintaining the original context for audit and provenance. System must convert values to a standard unit for aggregation while preserving the original for display and compliance.

**Solution Architecture:**

1. **Dual Storage** - Store both original and normalized values
2. **Conversion Metadata** - Track conversion rate, source, and date
3. **Multi-Source Providers** - Fetch conversion rates from multiple sources with fallback
4. **Caching Layer** - Cache conversion rates with staleness detection
5. **Display Formatting** - Locale-aware formatting for user display

**Components:**
- **ValueNormalizer** - Converts values while preserving original context
- **ConversionRateProvider** - Fetches conversion rates/formulas with caching and fallback
- **DisplayFormatter** - Formats normalized values for display with locale awareness
- **ConfigStore** - Manages user preferences (target unit, locale, timezone)

**When to Use:**
- ‚úÖ Need to aggregate values in different units (sum expenses in multiple currencies)
- ‚úÖ Must preserve original context (audit trail, compliance)
- ‚úÖ Conversion rates/formulas change over time (exchange rates, regulations)
- ‚úÖ Display format varies by user locale (US: $1,234.56 vs ES: $1.234,56)
- ‚ùå Simple one-way conversion with no history (use direct formula)
- ‚ùå No aggregation needed (display original values only)

**Examples:**

**Finance (Currency):**
```python
# Original: $100 USD, User's base: MXN
normalizer = ValueNormalizer()
result = normalizer.normalize(
    original_value=100.00,
    original_unit="USD",
    target_unit="MXN",
    context_date=date(2024, 11, 1)
)
# Result: NormalizedAmount(
#   original=100.00, original_unit="USD",
#   normalized=1850.00, target_unit="MXN",
#   conversion_rate=18.50, source="ecb"
# )
```

**Manufacturing (Temperature):**
```python
# Original: 212¬∞F, Target: Celsius
result = normalizer.normalize(
    original_value=212.0,
    original_unit="fahrenheit",
    target_unit="celsius",
    context_date=None  # No time dependency
)
# Result: NormalizedValue(
#   original=212.0, original_unit="fahrenheit",
#   normalized=100.0, target_unit="celsius",
#   conversion_formula="(F - 32) * 5/9", source="fixed"
# )
```

**Travel (Distance):**
```python
# Original: 100 miles, Target: kilometers
result = normalizer.normalize(
    original_value=100.0,
    original_unit="miles",
    target_unit="kilometers",
    context_date=None
)
# Result: NormalizedValue(
#   original=100.0, original_unit="miles",
#   normalized=160.93, target_unit="kilometers",
#   conversion_factor=1.60934, source="fixed"
# )
```

---

### 15. M√©tricas de Madurez

**Coverage Metrics:**
- % of transactions with normalized amounts (target: 100%)
- % of transactions with fresh rates (<24h) (target: >95%)
- % of rates from primary source (ECB) vs fallback (target: >90% ECB)
- % of manual rate overrides (target: <5%)

**Quality Metrics:**
- Exchange rate fetch success rate (target: >99%)
- Rate variance from multiple sources (ECB vs Fed) (target: <0.5% variance)
- Precision accuracy (no rounding errors) (target: 100%)
- Timezone conversion accuracy (DST transitions) (target: 100%)

**Performance Metrics:**
- Rate fetch latency from cache (target: <10ms p95)
- Rate fetch latency from ECB API (target: <500ms p95)
- Batch conversion throughput (target: >1000 transactions/sec)
- Display formatting latency (target: <5ms p95)

**User Engagement:**
- % users who customize base currency (target: >80%)
- % users who refresh stale rates (target: >30%)
- % users who override rates manually (target: <10%)
- Avg transactions per user in foreign currency (target: >5/month)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All operations require valid bearer token
- Users can only update their own currency configuration
- Rate refresh limited to user's own transactions
- Manual overrides logged with user_id

**Input Validation:**
- Currency code: Pattern validation ^[A-Z]{3}$ (prevent injection)
- Amount: Decimal validation, range check (prevent overflow)
- Timezone: IANA database validation (prevent arbitrary string)
- Locale: BCP 47 validation (prevent XSS)
- Exchange rate: Range validation (0.0001 to 1,000,000)

**API Security:**
- **Rate limiting:**
  - Get rate: 1000 requests/minute per user
  - Refresh rate: 10 requests/minute per user (prevent API abuse)
  - Convert amount: 100 requests/minute per user
- **SQL Injection Prevention:** Use parameterized queries
  - Example: `SELECT * FROM exchange_rates WHERE from_currency = ? AND to_currency = ?`

**Trust Construction Elements:**
- **Audit trail:** All rate overrides logged with reason and user_id
- **Variance validation:** Manual rates >10% variance require confirmation
- **Source transparency:** Always display rate source (ECB, Federal Reserve, manual)
- **Staleness indicator:** Visual warning for rates >24h old
- **Precision guarantee:** Use Decimal type, never float (prevent rounding errors)

**Data Privacy:**
- Override reasons may contain sensitive info (e.g., "negotiated rate with vendor ABC")
- Do not log override reasons in external systems
- Redact PII in error messages

**External API Security:**
- **ECB API:** HTTPS only, validate SSL certificate
- **Federal Reserve API:** HTTPS only, API key in environment variable (not code)
- **Timeout:** 5 seconds max (prevent hang)
- **Circuit breaker:** After 3 failures, disable source for 5 minutes

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `GET /api/user/currency-config`: <50ms
- `GET /api/exchange-rates?from=USD&to=MXN`: <100ms (cache hit), <500ms (cache miss)
- `POST /api/exchange-rates/refresh`: <1000ms (includes API call)
- `POST /api/convert`: <50ms (cache hit)
- `PATCH /api/user/currency-config`: <200ms

**Scalability:**
- Rates cached per currency pair per date: ~50,000 unique rates (150 currencies √ó 150 √ó 2 days)
- Cache size: ~10 MB (50,000 √ó 200 bytes)
- Batch conversion: 1,000 transactions/second (single rate fetch, loop conversion)
- Concurrent users: 10,000 (cache shared across users)

**Database Indexes:**
```sql
-- Exchange rates cache
CREATE INDEX idx_exchange_rates_pair_date
ON exchange_rates(from_currency, to_currency, rate_date);

CREATE INDEX idx_exchange_rates_fetched
ON exchange_rates(fetched_at);  -- For staleness detection

CREATE INDEX idx_exchange_rates_source
ON exchange_rates(source);  -- For source analytics

-- User currency config
CREATE UNIQUE INDEX idx_currency_config_user
ON currency_configs(user_id);

-- Transactions (normalized_amount is JSONB)
CREATE INDEX idx_transactions_normalized
ON transactions((normalized_amount->>'base_currency'), (normalized_amount->>'normalized_amount'));
```

**Caching Strategy:**
- **Exchange rates:**
  - Key: `rate_{from}_{to}_{date}` (e.g., `rate_usd_mxn_20241101`)
  - TTL: 24 hours (configurable per currency type: crypto 1h, fiat 24h)
  - Storage: Redis (fast lookup, distributed)
  - Eviction: LRU (Least Recently Used)

- **User configuration:**
  - Key: `currency_config_{user_id}`
  - TTL: 5 minutes (low write frequency)
  - Storage: Redis
  - Invalidation: On update (write-through)

- **Timezone data:**
  - Key: `timezone_db`
  - TTL: 7 days (rarely changes)
  - Storage: Redis
  - Size: ~500 KB (all IANA timezones)

**Background Jobs:**
- **Daily (02:00 UTC):** Fetch rates for popular pairs (USD/EUR, USD/MXN, etc.) - proactive caching
- **Hourly:** Refresh crypto rates (BTC/USD, ETH/USD) - volatility handling
- **Daily (03:00 UTC):** Purge stale cache entries (>30 days old)
- **Weekly:** Audit manual overrides (variance analysis)

**Optimization Techniques:**
- **Batch fetching:** Fetch multiple currency pairs in single API call (ECB supports batch)
- **Inverse caching:** Cache both USD‚ÜíMXN and MXN‚ÜíUSD (avoid recalculation)
- **Connection pooling:** Reuse HTTP connections to ECB/Fed APIs
- **Compression:** Gzip cache entries (reduce Redis memory by 60%)

---

### 18. Observability

**Metrics:**
```
# Exchange rate metrics
exchange_rates.fetched.count (counter, labels: source, from_currency, to_currency)
exchange_rates.cache_hit.count (counter, labels: from_currency, to_currency)
exchange_rates.cache_miss.count (counter, labels: from_currency, to_currency)
exchange_rates.stale.count (counter, labels: from_currency, to_currency)
exchange_rates.manual_override.count (counter, labels: from_currency, to_currency)
exchange_rates.variance.gauge (gauge, labels: from_currency, to_currency)

# API latency
exchange_rates.fetch.latency (histogram, labels: source)  # ECB, Fed, manual
currency.convert.latency (histogram)
currency.format.latency (histogram)

# Accuracy
exchange_rates.source_variance (gauge)  # ECB vs Fed variance %
timezone.conversion.errors (counter)

# User behavior
currency_config.updates.count (counter, labels: user_id)
base_currency.changes.count (counter, labels: old_currency, new_currency)
```

**Structured Logs:**
- All rate fetches (source, latency, success/failure)
- All manual overrides (user_id, reason, variance %)
- All cache misses (currency pair, date)
- All API failures (source, error, retry count)
- All base currency changes (user_id, old, new, transactions updated)

**Dashboards:**

**Dashboard 1: Exchange Rate Health**
- Rate fetch success rate by source (target: >99%)
- Cache hit rate (target: >90%)
- Stale rate count (target: <5% of total)
- Manual override rate (target: <5%)
- ECB vs Federal Reserve variance (target: <0.5%)

**Dashboard 2: Performance**
- API latency histogram (p50, p95, p99)
- Cache hit latency (target: <10ms p95)
- Cache miss latency (target: <500ms p95)
- Batch conversion throughput (transactions/sec)

**Dashboard 3: User Behavior**
- Base currency distribution (pie chart: USD, EUR, MXN, etc.)
- Currency pair popularity (bar chart: USD/EUR, USD/MXN, etc.)
- Manual override frequency (line chart over time)
- Base currency changes per week

**Alerts:**
- **Critical:** Exchange rate fetch failure rate >5% (check API connectivity)
- **Critical:** Cache hit rate <50% (check Redis)
- **Warning:** Stale rate count >10% (investigate slow refresh)
- **Warning:** Manual override variance >10% (investigate user behavior or rate accuracy)
- **Info:** ECB vs Fed variance >1% (investigate data source discrepancy)

**Tracing:**
- Trace conversion flow: Transaction ‚Üí get_rate ‚Üí check_cache ‚Üí fetch_ecb ‚Üí convert ‚Üí format
- Include: transaction_id, from/to currency, rate, source, latency for each step
- Distributed tracing: Link frontend conversion request to backend API calls

**Log Examples:**
```json
{
  "timestamp": "2024-11-01T10:00:00Z",
  "level": "INFO",
  "event": "exchange_rate_fetched",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 18.5000,
  "source": "ecb",
  "latency_ms": 245,
  "cache_miss": true
}
```

```json
{
  "timestamp": "2024-11-01T10:30:00Z",
  "level": "WARN",
  "event": "exchange_rate_manual_override",
  "user_id": "user_123",
  "from_currency": "USD",
  "to_currency": "MXN",
  "system_rate": 18.5000,
  "manual_rate": 19.0000,
  "variance_percent": 2.7,
  "reason": "Bank charged higher rate"
}
```

---

### 19. Testing Strategy

**Unit Tests:**

```python
# CurrencyConverter tests
def test_convert_usd_to_mxn():
    converter = CurrencyConverter(rate_provider=mock_provider)
    result = converter.convert(
        amount=Decimal("100.00"),
        from_currency="USD",
        to_currency="MXN",
        rate_date=date(2024, 11, 1)
    )
    assert result.original_amount == Decimal("100.00")
    assert result.normalized_amount == Decimal("1850.00")
    assert result.exchange_rate == Decimal("18.5000")
    assert result.rate_source == "ecb"

def test_convert_same_currency():
    result = converter.convert(
        amount=Decimal("100.00"),
        from_currency="USD",
        to_currency="USD",
        rate_date=date(2024, 11, 1)
    )
    assert result.exchange_rate == Decimal("1.0000")
    assert result.normalized_amount == Decimal("100.00")

def test_convert_precision_crypto():
    result = converter.convert(
        amount=Decimal("0.12345678"),  # 8 decimals (BTC)
        from_currency="BTC",
        to_currency="USD",
        rate_date=date(2024, 11, 1)
    )
    assert result.normalized_amount.as_tuple().exponent == -2  # 2 decimals for USD

# ExchangeRateProvider tests
def test_get_rate_cache_hit():
    provider = ExchangeRateProvider(cache=mock_cache)
    mock_cache.get.return_value = {"rate": 18.5000, "fetched_at": "2024-11-01T08:00:00Z"}

    rate = provider.get_rate("USD", "MXN", date(2024, 11, 1))

    assert rate.rate == Decimal("18.5000")
    assert rate.is_stale == False
    mock_cache.get.assert_called_once()

def test_get_rate_cache_miss_fetch_ecb():
    provider = ExchangeRateProvider(cache=mock_cache)
    mock_cache.get.return_value = None

    with mock.patch('requests.get') as mock_get:
        mock_get.return_value.json.return_value = {"rates": {"MXN": 18.5000}}
        rate = provider.get_rate("USD", "MXN", date(2024, 11, 1))

    assert rate.rate == Decimal("18.5000")
    assert rate.source == "ecb"
    mock_cache.set.assert_called_once()  # Cache the result

def test_get_rate_ecb_fail_fallback_fed():
    provider = ExchangeRateProvider(cache=mock_cache)
    mock_cache.get.return_value = None

    with mock.patch('requests.get') as mock_get:
        # ECB fails
        mock_get.side_effect = [
            requests.exceptions.Timeout(),
            # Federal Reserve succeeds
            Mock(json=lambda: {"rates": {"MXN": 18.6000}})
        ]
        rate = provider.get_rate("USD", "MXN", date(2024, 11, 1))

    assert rate.source == "federal_reserve"
    assert rate.rate == Decimal("18.6000")

# DateNormalizer tests
def test_normalize_to_utc():
    normalizer = DateNormalizer()
    user_date = datetime(2024, 11, 1, 10, 0, 0)  # 10:00 AM Mexico City

    utc_date = normalizer.normalize(user_date, "America/Mexico_City")

    assert utc_date.tzinfo == pytz.UTC
    assert utc_date.hour == 16  # 10 AM CST = 4 PM UTC (GMT-6)

def test_display_in_user_timezone():
    normalizer = DateNormalizer()
    utc_date = datetime(2024, 11, 1, 16, 0, 0, tzinfo=pytz.UTC)

    display_str = normalizer.display(utc_date, "America/Mexico_City")

    assert display_str == "Nov 1, 2024 10:00 AM"  # Back to Mexico City time

def test_dst_transition():
    normalizer = DateNormalizer()
    # Test date during DST transition (spring forward)
    user_date = datetime(2024, 3, 10, 2, 30, 0)  # 2:30 AM doesn't exist!

    utc_date = normalizer.normalize(user_date, "America/New_York")

    assert utc_date.hour == 7  # Correctly handles DST (3:30 AM EDT = 7:30 AM UTC)

# AmountFormatter tests
def test_format_usd_en_us():
    formatter = AmountFormatter()
    formatted = formatter.format(Decimal("1234.56"), "USD", "en-US")
    assert formatted == "$1,234.56"

def test_format_eur_es_es():
    formatter = AmountFormatter()
    formatted = formatter.format(Decimal("1234.56"), "EUR", "es-ES")
    assert formatted == "1.234,56 ‚Ç¨"  # European format

def test_format_crypto_btc():
    formatter = AmountFormatter()
    formatted = formatter.format(Decimal("0.12345678"), "BTC", "en-US")
    assert formatted == "0.12345678 BTC"  # 8 decimals preserved
```

**Integration Tests:**

```python
def test_end_to_end_currency_conversion():
    # 1. Create user with MXN base currency
    user = create_user(base_currency="MXN", timezone="America/Mexico_City")

    # 2. Import transaction in USD
    transaction = import_transaction(
        amount=100.00,
        currency="USD",
        date="2024-11-01",
        user_id=user.id
    )

    # 3. Verify normalization happened automatically
    assert transaction.normalized_amount.original_currency == "USD"
    assert transaction.normalized_amount.base_currency == "MXN"
    assert transaction.normalized_amount.normalized_amount == Decimal("1850.00")
    assert transaction.normalized_amount.rate_source == "ecb"

    # 4. Verify display
    response = client.get(f"/api/transactions/{transaction.id}")
    assert "$1,850.00 MXN" in response.json()["display_amount"]
    assert "($100.00 USD @ 18.50)" in response.json()["display_amount"]

def test_rate_refresh_flow():
    # 1. Create transaction with stale rate (25h old)
    transaction = create_transaction_with_stale_rate()

    # 2. User refreshes rate
    response = client.post("/api/exchange-rates/refresh", json={
        "from_currency": "USD",
        "to_currency": "MXN",
        "apply_to_transactions": True
    })

    assert response.status_code == 200
    assert response.json()["transactions_updated"] == 1

    # 3. Verify transaction updated
    updated_transaction = client.get(f"/api/transactions/{transaction.id}")
    assert updated_transaction.json()["normalized_amount"]["rate_source"] == "ecb"
    assert updated_transaction.json()["normalized_amount"]["is_stale"] == False

def test_manual_override_flow():
    # 1. Create transaction
    transaction = create_transaction(amount=100, currency="USD")

    # 2. User overrides rate
    response = client.post("/api/exchange-rates/override", json={
        "from_currency": "USD",
        "to_currency": "MXN",
        "rate": 19.0000,
        "rate_date": "2024-11-01",
        "reason": "Bank charged higher rate",
        "transaction_id": transaction.id
    })

    assert response.status_code == 201

    # 3. Verify transaction updated
    updated = client.get(f"/api/transactions/{transaction.id}")
    assert updated.json()["normalized_amount"]["exchange_rate"] == 19.0000
    assert updated.json()["normalized_amount"]["rate_source"] == "manual"
    assert updated.json()["normalized_amount"]["override_reason"] == "Bank charged higher rate"

def test_base_currency_change_renormalization():
    # 1. Create user with USD base, import 10 transactions
    user = create_user(base_currency="USD")
    transactions = [create_transaction(user_id=user.id) for _ in range(10)]

    # 2. Change base currency to EUR
    response = client.patch("/api/user/currency-config", json={
        "base_currency": "EUR"
    })

    assert response.status_code == 200

    # 3. Verify all transactions re-normalized
    for txn_id in [t.id for t in transactions]:
        txn = client.get(f"/api/transactions/{txn_id}")
        assert txn.json()["normalized_amount"]["base_currency"] == "EUR"
```

**Multi-Domain Tests:**

```python
# Healthcare: International medical claim currency conversion
def test_healthcare_international_claim():
    # Claim filed in EUR, patient's insurance in USD
    claim = create_medical_claim(amount=1000, currency="EUR")
    normalized = converter.convert(1000, "EUR", "USD", date(2024, 11, 1))
    assert normalized.base_currency == "USD"
    # Reimbursement calculated in USD

# E-commerce: Product pricing in multiple currencies
def test_ecommerce_product_pricing():
    # Product priced in USD, display in user's local currency (MXN)
    product_price = Decimal("99.99")
    user_currency = "MXN"
    displayed_price = converter.convert(product_price, "USD", user_currency, date.today())
    assert displayed_price.base_currency == user_currency
    # User sees price in MXN

# Travel: Expense reporting in foreign currency
def test_travel_expense_reporting():
    # Employee spent EUR abroad, company reimburses in USD
    expense = create_expense(amount=200, currency="EUR", category="meals")
    reimbursement = converter.convert(200, "EUR", "USD", expense.date)
    assert reimbursement.base_currency == "USD"
    # Company pays in USD

# Manufacturing: Temperature conversion
def test_manufacturing_temperature_conversion():
    # Sensor reads Fahrenheit, system stores Celsius
    fahrenheit = Decimal("212.0")
    celsius = temperature_converter.convert(fahrenheit, "fahrenheit", "celsius")
    assert celsius.normalized_value == Decimal("100.0")
    # Boiling point of water
```

**Performance Tests:**

```python
def test_batch_conversion_performance():
    # Convert 1000 transactions in batch
    transactions = [create_transaction() for _ in range(1000)]

    start = time.time()
    results = converter.batch_convert(transactions)
    elapsed = time.time() - start

    assert elapsed < 1.0  # Target: <1 second for 1000 transactions
    assert len(results) == 1000

def test_cache_hit_performance():
    # Measure cache hit latency
    provider = ExchangeRateProvider(cache=redis_cache)

    # Warm cache
    provider.get_rate("USD", "MXN", date(2024, 11, 1))

    # Measure cache hit
    start = time.time()
    for _ in range(1000):
        provider.get_rate("USD", "MXN", date(2024, 11, 1))
    elapsed = time.time() - start

    assert elapsed / 1000 < 0.010  # Target: <10ms per lookup
```

---

### 20. Operations Runbook

**Deployment:**

**1. Database Migrations:**

```sql
-- Create currency_configs table
CREATE TABLE currency_configs (
    user_id UUID PRIMARY KEY,
    base_currency VARCHAR(3) NOT NULL CHECK (base_currency ~ '^[A-Z]{3}$'),
    precision INTEGER NOT NULL CHECK (precision >= 0 AND precision <= 8),
    display_locale VARCHAR(10) NOT NULL,
    timezone VARCHAR(50) NOT NULL,
    rate_sources JSONB NOT NULL DEFAULT '["ecb", "federal_reserve", "manual"]'::jsonb,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Create exchange_rates cache table
CREATE TABLE exchange_rates (
    rate_id VARCHAR(100) PRIMARY KEY,
    from_currency VARCHAR(3) NOT NULL,
    to_currency VARCHAR(3) NOT NULL,
    rate DECIMAL(12, 6) NOT NULL CHECK (rate > 0),
    rate_date DATE NOT NULL,
    source VARCHAR(20) NOT NULL CHECK (source IN ('ecb', 'federal_reserve', 'manual')),
    fetched_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    is_stale BOOLEAN GENERATED ALWAYS AS (NOW() > expires_at) STORED,
    metadata JSONB,
    UNIQUE(from_currency, to_currency, rate_date, source)
);

-- Add normalized_amount to transactions table (JSONB column)
ALTER TABLE transactions ADD COLUMN normalized_amount JSONB;

-- Indexes
CREATE INDEX idx_exchange_rates_pair_date
ON exchange_rates(from_currency, to_currency, rate_date);

CREATE INDEX idx_exchange_rates_fetched
ON exchange_rates(fetched_at);

CREATE INDEX idx_exchange_rates_stale
ON exchange_rates(is_stale) WHERE is_stale = true;

CREATE UNIQUE INDEX idx_currency_config_user
ON currency_configs(user_id);

CREATE INDEX idx_transactions_normalized_currency
ON transactions((normalized_amount->>'base_currency'));
```

**2. Seed Initial Data:**

```bash
# Set default currency config for existing users
python /app/scripts/seed_currency_configs.py --default-currency=USD --default-timezone=UTC

# Pre-cache popular exchange rates
python /app/scripts/prefetch_rates.py --pairs=USD/EUR,USD/MXN,USD/GBP,EUR/GBP --days=7
```

**3. Environment Variables:**

```bash
# Exchange rate API keys
ECB_API_URL=https://api.exchangerate.host/latest
FEDERAL_RESERVE_API_KEY=your_api_key_here
FEDERAL_RESERVE_API_URL=https://api.federalreserve.gov/data

# Cache settings
REDIS_URL=redis://localhost:6379/0
EXCHANGE_RATE_CACHE_TTL_SECONDS=86400  # 24 hours
CRYPTO_RATE_CACHE_TTL_SECONDS=3600  # 1 hour

# Rate fetch settings
EXCHANGE_RATE_FETCH_TIMEOUT_SECONDS=5
EXCHANGE_RATE_MAX_RETRIES=3
```

**Monitoring:**

**Health Check:**
```bash
# Check if currency conversion is working
curl -X GET "https://api.example.com/api/health/currency" \
  -H "Authorization: Bearer TOKEN"

# Expected response:
# {
#   "status": "healthy",
#   "exchange_rate_provider": "ecb",
#   "cache_hit_rate": 0.92,
#   "last_rate_fetch": "2024-11-01T08:00:00Z"
# }
```

**Metric Alerts:**
- **Critical:** Exchange rate fetch failure rate >5% ‚Üí Check ECB/Fed API connectivity
- **Critical:** Cache hit rate <50% ‚Üí Check Redis connectivity
- **Warning:** Stale rate count >10% ‚Üí Investigate refresh job
- **Warning:** Manual override rate >10% ‚Üí Investigate rate accuracy or user confusion
- **Info:** ECB vs Fed variance >1% ‚Üí Investigate data source discrepancy

**Common Issues:**

**Issue 1: Exchange rate API down (ECB)**
- **Symptom:** All rate fetches failing with timeout error
- **Debug:**
  1. Check ECB API status: `curl https://api.exchangerate.host/latest?base=USD`
  2. Check network connectivity: `ping api.exchangerate.host`
  3. Check logs for error messages
- **Fix:**
  - System automatically falls back to Federal Reserve
  - If both fail, rates served from cache (may be stale)
  - Monitor alert will trigger, ops team notified
- **Recovery:** Once ECB API restored, system auto-recovers (cache refreshes on next fetch)

**Issue 2: Stale rates accumulating**
- **Symptom:** >10% of rates marked as stale, users seeing warnings
- **Debug:**
  1. Check background refresh job: `ps aux | grep prefetch_rates`
  2. Check Redis cache size: `redis-cli INFO memory`
  3. Check rate fetch latency: Check Datadog/Grafana dashboard
- **Fix:**
  - Manually trigger refresh: `python /app/scripts/prefetch_rates.py --all`
  - Check if job scheduler (cron/Kubernetes CronJob) is running
  - Increase cache TTL temporarily: `export EXCHANGE_RATE_CACHE_TTL_SECONDS=172800`  # 48h
- **Recovery:** Resume normal refresh schedule, rates auto-refresh

**Issue 3: Currency conversion producing incorrect results**
- **Symptom:** User reports $100 USD showing as $100 MXN (rate = 1.0)
- **Debug:**
  1. Check rate fetch for currency pair:
     ```bash
     curl -X GET "/api/exchange-rates?from=USD&to=MXN&date=2024-11-01"
     ```
  2. Verify rate in database:
     ```sql
     SELECT * FROM exchange_rates
     WHERE from_currency='USD' AND to_currency='MXN'
     ORDER BY rate_date DESC LIMIT 10;
     ```
  3. Check for manual overrides:
     ```sql
     SELECT * FROM exchange_rates
     WHERE from_currency='USD' AND to_currency='MXN' AND source='manual';
     ```
- **Fix:**
  - If rate is 1.0 (incorrect), invalidate cache and refetch:
    ```bash
    redis-cli DEL rate_usd_mxn_20241101
    curl -X POST "/api/exchange-rates/refresh" -d '{"from":"USD","to":"MXN"}'
    ```
  - If manual override is wrong, delete and refetch:
    ```sql
    DELETE FROM exchange_rates WHERE rate_id='rate_usd_mxn_20241101_manual_user123';
    ```

**Issue 4: Timezone conversion showing wrong times**
- **Symptom:** Transaction dated "Nov 1, 2024 10:00 AM" shows as "Nov 1, 2024 4:00 PM"
- **Debug:**
  1. Check user's timezone setting:
     ```sql
     SELECT timezone FROM currency_configs WHERE user_id='user_123';
     ```
  2. Verify UTC storage:
     ```sql
     SELECT date, timezone FROM transactions WHERE transaction_id='txn_12345';
     ```
  3. Check for DST transition (spring forward / fall back)
- **Fix:**
  - If timezone incorrect, update user config:
    ```bash
    curl -X PATCH "/api/user/currency-config" \
      -d '{"timezone":"America/Mexico_City"}'
    ```
  - If DST issue, verify pytz library is up-to-date:
    ```bash
    pip install --upgrade pytz
    ```

**Issue 5: High variance between ECB and Federal Reserve rates**
- **Symptom:** ECB rate: 18.50, Fed rate: 18.90 (2.2% variance)
- **Debug:**
  1. Fetch rates from both sources manually:
     ```bash
     curl "https://api.exchangerate.host/latest?base=USD&symbols=MXN"
     curl "https://api.federalreserve.gov/data?series_id=DEXMXUS"
     ```
  2. Check rate dates (ensure same date)
  3. Check if one source has stale data
- **Fix:**
  - If variance within 1%, no action (normal market fluctuation)
  - If variance >1%, investigate which source is more accurate:
    - Compare to third source (e.g., xe.com, Bloomberg)
    - Temporarily disable less accurate source
    - Log variance in audit trail for analysis

**Incident Response Commands:**

```bash
# Force refresh all rates for today
python /app/scripts/prefetch_rates.py --all --date=today

# Invalidate all cache entries (nuclear option)
redis-cli FLUSHDB

# Re-normalize all transactions for user (after base currency change)
python /app/scripts/renormalize_transactions.py --user-id=user_123

# Audit manual overrides (variance >5%)
python /app/scripts/audit_manual_overrides.py --variance-threshold=5.0

# Export exchange rate history for debugging
python /app/scripts/export_rate_history.py --from=USD --to=MXN --start=2024-10-01 --end=2024-11-01 --output=/tmp/rates.csv

# Check cache health
redis-cli INFO stats
redis-cli DBSIZE
redis-cli --scan --pattern "rate_*" | wc -l  # Count cached rates
```

**Backup & Recovery:**

```bash
# Backup exchange rates cache (daily)
redis-cli --rdb /backups/exchange_rates_$(date +%Y%m%d).rdb

# Restore cache from backup
redis-cli --rdb /backups/exchange_rates_20241101.rdb

# Backup user currency configs (daily)
pg_dump -t currency_configs > /backups/currency_configs_$(date +%Y%m%d).sql

# Restore user configs
psql < /backups/currency_configs_20241101.sql
```

**Performance Tuning:**

```bash
# Increase Redis max memory
redis-cli CONFIG SET maxmemory 2gb
redis-cli CONFIG SET maxmemory-policy allkeys-lru

# Optimize database indexes
VACUUM ANALYZE exchange_rates;
REINDEX TABLE exchange_rates;

# Monitor slow queries
SELECT * FROM pg_stat_statements
WHERE query LIKE '%exchange_rates%'
ORDER BY total_time DESC
LIMIT 10;
```

---

## üéØ Summary

Vertical 3.6 delivers a **value normalization system** with:

‚úÖ **5 OL Primitives** (CurrencyConverter, DateNormalizer, AmountFormatter, ExchangeRateProvider, CurrencyConfigStore)
‚úÖ **3 IL Components** (CurrencySelectorDialog, AmountDisplayCard, ExchangeRateWidget)
‚úÖ **3 Schemas** (normalized-amount, exchange-rate-record, currency-config)
‚úÖ **20 Complete Sections** (Product, Machinery, Cross-Cutting)
‚úÖ **Multi-Domain Pattern** (Finance ‚Üí Currency, Healthcare ‚Üí International claims, E-commerce ‚Üí Product pricing, Manufacturing ‚Üí Unit conversion)

**Finance Instantiation:**
- Multi-currency transactions normalized to user's base currency
- Exchange rates from ECB (primary) and Federal Reserve (fallback)
- Original + normalized amounts preserved (context preservation)
- Manual rate override with audit trail
- Locale-aware display formatting

**Universal Pattern: Value Normalization + Unit Conversion**
- Dual storage (original + normalized values)
- Multi-source conversion providers (ECB, Federal Reserve, formulas)
- Caching with staleness detection
- Display formatting with locale awareness
- Context preservation for audit and compliance

**Next:** 3.7 Search & Filters (transaction search, faceted filtering, saved searches)
