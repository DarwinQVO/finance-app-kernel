# Vertical 3.6: Unit (Currency & Date Normalization)

> **Type:** Value Normalization System
> **Pattern:** Value Object + Adapter + Strategy Pattern
> **Last Updated:** 2025-10-24

---

## 📋 Overview

The **Unit** vertical provides a **value normalization system** for converting and displaying amounts across currencies, timezones, and numerical formats. While demonstrated in finance domain (multi-currency transactions, exchange rates), the underlying primitives are domain-agnostic and apply to ANY unit conversion and value normalization.

**Key Characteristics:**
- **Multi-Currency:** Support hundreds of currencies with automatic conversion to user's base currency
- **Exchange Rate Management:** Multi-source rate fetching (ECB, Federal Reserve, manual) with caching and staleness detection
- **Context Preservation:** Store original + normalized values to maintain provenance
- **Timezone Normalization:** Convert local dates/times to UTC storage, display in user's timezone
- **Precision Rules:** Configurable decimal places (2 for fiat, 4 for crypto, 8 for BTC)
- **Display Formatting:** Locale-aware number formatting (thousands separators, decimal symbols)

**Finance Domain Examples:**
- Convert USD transactions to MXN base currency for Mexican user
- Display EUR expense with original amount + USD equivalent
- Fetch exchange rates from ECB (European Central Bank) with Federal Reserve fallback
- Store transaction dates in UTC, display in America/Mexico_City timezone
- Format $1,234.56 as "$1,234.56" (US) or "$1.234,56" (ES)

**Multi-Domain Applicability:**
- Healthcare: Currency conversion for international medical claims, timezone handling for global clinical trials
- E-commerce: Product pricing in multiple currencies, cross-border transaction display
- Legal: International billing with currency conversion, jurisdiction timezone normalization
- Travel: Expense reporting in foreign currencies with automatic conversion
- Manufacturing: Unit conversion (imperial ↔ metric), temperature scales (F ↔ C)

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Multi-currency normalization (convert to user's base currency)
- Exchange rate fetching from multiple sources (ECB, Federal Reserve, manual override)
- Exchange rate caching with staleness detection (24-hour TTL)
- Historical exchange rate support (get rate for specific date)
- Original + normalized amount storage (context preservation)
- Date/time normalization (user timezone → UTC storage)
- Display formatting with locale awareness (en-US, es-MX, de-DE, etc.)
- Precision rules by currency type (fiat 2 decimals, crypto 4-8 decimals)
- Currency configuration per user (base currency, timezone, display locale)
- Rate refresh UI (manual refresh for stale rates)

**Out of Scope:**
- Cryptocurrency price tracking (real-time updates, covered in future vertical)
- Tax calculation on currency gains/losses (covered in 4.x Tax Engine)
- Payment processing with currency conversion (separate workflow)
- Historical price charts (covered in 2.3 Dashboard)
- Forward rate contracts or hedging (advanced treasury)
- Blockchain integration for crypto transactions

**Boundaries:**
- Exchange rates updated daily (not real-time, except manual refresh)
- Rates older than 24 hours marked as "stale" (visual indicator)
- User can override system rate with manual rate (audit trail)
- One base currency per user (cannot have multi-base simultaneously)
- Timezone applies globally to all dates (not per-transaction)

---

### 2. User Flow (Real Usage)

**Scenario 1: User sets base currency during onboarding**

User: "I want to track all expenses in Mexican Pesos (MXN)"

System:
1. During onboarding, CurrencySelectorDialog appears
2. User sees list of popular currencies first:
   - 🇺🇸 USD - US Dollar
   - 🇪🇺 EUR - Euro
   - 🇲🇽 MXN - Mexican Peso
   - 🇬🇧 GBP - British Pound
   - 🇯🇵 JPY - Japanese Yen
3. User clicks "🇲🇽 MXN - Mexican Peso"
4. System prompts for timezone: "America/Mexico_City" (auto-detected)
5. System prompts for display locale: "es-MX" (auto-detected from browser)
6. System creates CurrencyConfig:
   ```json
   {
     "user_id": "user_123",
     "base_currency": "MXN",
     "precision": 2,
     "display_locale": "es-MX",
     "timezone": "America/Mexico_City",
     "rate_sources": ["ecb", "federal_reserve", "manual"]
   }
   ```
7. User sees confirmation: "✅ Base currency set to MXN"

**Scenario 2: User views transaction with currency conversion**

User: "I spent $100 USD while traveling - how much is that in my base currency (MXN)?"

System:
1. User imports transaction from credit card:
   - Original: $100.00 USD
   - Date: 2024-11-01
2. CurrencyConverter.convert() runs automatically:
   - from_currency: USD
   - to_currency: MXN (user's base)
   - rate_date: 2024-11-01
3. ExchangeRateProvider.get_rate() fetches rate:
   - Checks cache first (rate_usd_mxn_20241101)
   - Cache miss → Fetch from ECB API
   - ECB returns: 1 USD = 18.5000 MXN
   - Cache rate with 24h TTL
4. Normalized amount calculated:
   - $100.00 USD × 18.5000 = $1,850.00 MXN
5. Creates NormalizedAmount:
   ```json
   {
     "original_amount": 100.00,
     "original_currency": "USD",
     "normalized_amount": 1850.00,
     "base_currency": "MXN",
     "exchange_rate": 18.5000,
     "rate_date": "2024-11-01",
     "rate_source": "ecb"
   }
   ```
6. User sees in TransactionList:
   - Primary: $1,850.00 MXN
   - Secondary: ($100.00 USD @ 18.50)
7. AmountDisplayCard shows dual currency display

**Scenario 3: User refreshes stale exchange rate**

Background: Rate was fetched 25 hours ago (stale threshold: 24h)

User: "This rate looks outdated - I want to refresh it"

System:
1. User views transaction, sees stale indicator: "⚠️ Rate from 2024-10-31 (stale)"
2. ExchangeRateWidget displays:
   - From: USD
   - To: MXN
   - Rate: 18.5000
   - Date: 2024-10-31
   - Status: "Stale (fetched 25 hours ago)"
3. User clicks "🔄 Refresh Rate"
4. System:
   - Shows loading spinner: "Refreshing..."
   - Calls ExchangeRateProvider.refresh_cache()
   - Fetches latest rate from ECB
   - New rate: 1 USD = 18.7500 MXN (rate changed!)
5. System asks: "Update all transactions using old rate?"
   - Option A: "Update all USD→MXN transactions from Oct 31" (batch update)
   - Option B: "Only this transaction" (single update)
6. User selects Option A
7. System:
   - Re-normalizes all affected transactions
   - Updates normalized_amount: $100.00 × 18.7500 = $1,875.00 MXN
   - Logs rate change in audit trail
8. User sees updated display:
   - $1,875.00 MXN ($100.00 USD @ 18.75)
   - "✅ Rate updated to 2024-11-01"

**Scenario 4: User manually overrides exchange rate**

User: "The bank charged me a different rate - I want to use the actual rate I paid"

System:
1. User views transaction: $100.00 USD → $1,850.00 MXN (@ 18.50)
2. User clicks "Edit Rate" in ExchangeRateWidget
3. Dialog appears:
   - Current Rate: 18.5000 (from ECB)
   - Override Rate: [input field]
   - Reason: [text area]
4. User enters:
   - Override Rate: 19.0000
   - Reason: "Bank charged higher rate due to foreign transaction fee"
5. System validates:
   - Rate > 0? ✅
   - Variance from ECB rate: 2.7% (within 10% tolerance) ✅
6. System recalculates:
   - $100.00 USD × 19.0000 = $1,900.00 MXN
7. Updates NormalizedAmount:
   ```json
   {
     "original_amount": 100.00,
     "original_currency": "USD",
     "normalized_amount": 1900.00,
     "base_currency": "MXN",
     "exchange_rate": 19.0000,
     "rate_date": "2024-11-01",
     "rate_source": "manual",
     "override_reason": "Bank charged higher rate due to foreign transaction fee"
   }
   ```
8. User sees: $1,900.00 MXN ($100.00 USD @ 19.00*)
   - "*" indicates manual override
9. Audit trail logs manual rate change

**Scenario 5: User changes timezone**

User: "I moved from Mexico to Spain - I want dates in Europe/Madrid timezone"

System:
1. User opens Settings → Currency & Display
2. Current timezone: "America/Mexico_City (GMT-6)"
3. User clicks "Change Timezone"
4. Dropdown shows:
   - Popular timezones (America/New_York, Europe/London, Asia/Tokyo)
   - Search: "madrid"
5. User selects "Europe/Madrid (GMT+1)"
6. System updates CurrencyConfig:
   ```json
   {
     "timezone": "Europe/Madrid"
   }
   ```
7. System re-renders all dates:
   - Before: "Nov 1, 2024 10:00 AM" (Mexico City time)
   - After: "Nov 1, 2024 5:00 PM" (Madrid time)
   - UTC stored value unchanged: "2024-11-01T16:00:00Z"
8. User sees confirmation: "✅ Timezone changed to Europe/Madrid"

**Scenario 6: User views historical exchange rate**

User: "What was the USD/EUR rate 6 months ago?"

System:
1. User navigates to Settings → Exchange Rate History
2. Input form appears:
   - From Currency: [dropdown] → USD
   - To Currency: [dropdown] → EUR
   - Date: [date picker] → 2024-05-01
3. User submits
4. System calls ExchangeRateProvider.get_rate(USD, EUR, "2024-05-01")
5. Checks historical cache (rate_usd_eur_20240501)
6. Cache miss → Fetch from ECB historical API
7. Returns: 1 USD = 0.9200 EUR (May 1, 2024)
8. Displays:
   - Rate: 0.9200
   - Date: May 1, 2024
   - Source: ECB Historical
   - Trend: "+2.1% vs today's rate (0.9400)"

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `CurrencyConverter` - Convert amounts between currencies (NEW - this vertical)
- `DateNormalizer` - Normalize dates between timezones and UTC (NEW - this vertical)
- `AmountFormatter` - Format amounts with locale-aware display rules (NEW - this vertical)
- `ExchangeRateProvider` - Fetch and cache exchange rates from multiple sources (NEW - this vertical)
- `CurrencyConfigStore` - CRUD for user currency configuration (NEW - this vertical)
- `TransactionStore` - Store normalized_amount on transactions (from 1.3)

**Interaction Layer (IL):**
- `CurrencySelectorDialog` - Modal for selecting base currency (NEW - this vertical)
- `AmountDisplayCard` - Display original + normalized amounts side-by-side (NEW - this vertical)
- `ExchangeRateWidget` - Display rate with refresh button and staleness indicator (NEW - this vertical)
- `TransactionList` - View transactions with normalized amounts (from 2.1)
- `DrillDownPanel` - View currency details in transaction detail (from 2.2)

**Schemas:**
- `normalized-amount.schema.json` - Original + normalized amount with rate metadata (NEW - this vertical)
- `exchange-rate-record.schema.json` - Cached exchange rate record (NEW - this vertical)
- `currency-config.schema.json` - User currency and display preferences (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# Get User Currency Configuration
GET /api/user/currency-config
Authorization: Bearer {token}

Response 200:
{
  "user_id": "user_123",
  "base_currency": "MXN",
  "precision": 2,
  "display_locale": "es-MX",
  "timezone": "America/Mexico_City",
  "rate_sources": ["ecb", "federal_reserve", "manual"],
  "created_at": "2024-11-01T10:00:00Z",
  "updated_at": "2024-11-01T10:00:00Z"
}
```

```http
# Update Base Currency
PATCH /api/user/currency-config
Authorization: Bearer {token}
Content-Type: application/json

{
  "base_currency": "EUR",
  "timezone": "Europe/Madrid",
  "display_locale": "es-ES"
}

Response 200:
{
  "user_id": "user_123",
  "base_currency": "EUR",
  "precision": 2,
  "display_locale": "es-ES",
  "timezone": "Europe/Madrid",
  "rate_sources": ["ecb", "federal_reserve", "manual"],
  "updated_at": "2024-11-01T10:30:00Z"
}
```

```http
# Get Exchange Rate (specific date)
GET /api/exchange-rates?from=USD&to=MXN&date=2024-11-01
Authorization: Bearer {token}

Response 200:
{
  "rate_id": "rate_usd_mxn_20241101",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 18.5000,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "fetched_at": "2024-11-01T08:00:00Z",
  "is_stale": false,
  "expires_at": "2024-11-02T08:00:00Z"
}
```

```http
# Refresh Exchange Rate (force update)
POST /api/exchange-rates/refresh
Authorization: Bearer {token}
Content-Type: application/json

{
  "from_currency": "USD",
  "to_currency": "MXN",
  "apply_to_transactions": true  // Update all transactions using this rate
}

Response 200:
{
  "old_rate": 18.5000,
  "new_rate": 18.7500,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "transactions_updated": 15,
  "message": "Rate refreshed and applied to 15 transactions"
}
```

```http
# Override Exchange Rate (manual)
POST /api/exchange-rates/override
Authorization: Bearer {token}
Content-Type: application/json

{
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 19.0000,
  "rate_date": "2024-11-01",
  "reason": "Bank charged higher rate due to foreign transaction fee",
  "transaction_id": "txn_12345"  // Optional: apply only to this transaction
}

Response 201:
{
  "rate_id": "rate_usd_mxn_20241101_manual_user123",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 19.0000,
  "rate_date": "2024-11-01",
  "source": "manual",
  "override_reason": "Bank charged higher rate due to foreign transaction fee",
  "variance_from_ecb": 2.7,
  "created_at": "2024-11-01T10:30:00Z"
}
```

```http
# Convert Amount (preview - no persistence)
POST /api/convert
Authorization: Bearer {token}
Content-Type: application/json

{
  "amount": 100.00,
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate_date": "2024-11-01"
}

Response 200:
{
  "original_amount": 100.00,
  "original_currency": "USD",
  "converted_amount": 1850.00,
  "target_currency": "MXN",
  "exchange_rate": 18.5000,
  "rate_date": "2024-11-01",
  "rate_source": "ecb"
}
```

**Internal OL API:**

```python
class CurrencyConverter:
    def convert(self, amount: Decimal, from_currency: str, to_currency: str,
                rate_date: date) -> NormalizedAmount:
        """
        Converts amount from one currency to another.

        Args:
            amount: Original amount
            from_currency: ISO 4217 currency code (e.g., "USD")
            to_currency: ISO 4217 currency code (e.g., "MXN")
            rate_date: Date for exchange rate lookup

        Returns:
            NormalizedAmount with original + converted values and rate metadata

        Raises:
            UnsupportedCurrencyError: If currency not in ISO 4217
            RateNotAvailableError: If no rate found for date
        """

    def batch_convert(self, transactions: List[Transaction]) -> Dict[str, NormalizedAmount]:
        """Batch conversion for performance (single rate fetch per currency pair)."""

class DateNormalizer:
    def normalize(self, user_date: datetime, user_tz: str) -> datetime:
        """
        Converts user timezone datetime to UTC.

        Args:
            user_date: Datetime in user's local timezone
            user_tz: IANA timezone (e.g., "America/Mexico_City")

        Returns:
            UTC datetime (timezone-aware)
        """

    def display(self, utc_datetime: datetime, user_tz: str) -> str:
        """
        Formats UTC datetime for display in user's timezone.

        Returns:
            Formatted string (e.g., "Nov 1, 2024 10:00 AM")
        """

class AmountFormatter:
    def format(self, amount: Decimal, currency: str, locale: str) -> str:
        """
        Formats amount with locale-aware rules.

        Args:
            amount: Decimal amount
            currency: ISO 4217 currency code
            locale: BCP 47 locale (e.g., "en-US", "es-MX")

        Returns:
            Formatted string (e.g., "$1,234.56" for en-US, "$1.234,56" for es-ES)
        """

class ExchangeRateProvider:
    def get_rate(self, from_currency: str, to_currency: str,
                 rate_date: date) -> ExchangeRateRecord:
        """
        Gets exchange rate from cache or fetches from source.

        Rate Source Priority:
        1. Cache (if fresh, < 24h)
        2. ECB API (European Central Bank)
        3. Federal Reserve API
        4. Manual override (user-provided)

        Returns:
            ExchangeRateRecord with rate and metadata

        Raises:
            RateNotAvailableError: If all sources fail
        """

    def refresh_cache(self, from_currency: str, to_currency: str) -> ExchangeRateRecord:
        """Forces cache invalidation and fetches fresh rate."""

    def get_historical(self, from_currency: str, to_currency: str,
                       start_date: date, end_date: date) -> List[ExchangeRateRecord]:
        """Fetches historical rates for date range (for charts)."""

class CurrencyConfigStore:
    def get(self, user_id: str) -> CurrencyConfig:
        """Gets user's currency configuration."""

    def update(self, user_id: str, base_currency: Optional[str] = None,
               timezone: Optional[str] = None,
               display_locale: Optional[str] = None) -> CurrencyConfig:
        """
        Updates user's currency configuration.

        Raises:
            InvalidCurrencyError: If base_currency not in ISO 4217
            InvalidTimezoneError: If timezone not in IANA database
            InvalidLocaleError: If locale not in BCP 47
        """
```

---

### 5. Schemas / Tipos (Persistencia)

**NormalizedAmount Schema (embedded in Transaction):**

```json
{
  "original_amount": 100.00,
  "original_currency": "USD",
  "normalized_amount": 1850.00,
  "base_currency": "MXN",
  "exchange_rate": 18.5000,
  "rate_date": "2024-11-01",
  "rate_source": "ecb",
  "override_reason": null
}
```

**ExchangeRateRecord Schema:**

```json
{
  "rate_id": "rate_usd_mxn_20241101",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 18.5000,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "fetched_at": "2024-11-01T08:00:00Z",
  "is_stale": false,
  "expires_at": "2024-11-02T08:00:00Z"
}
```

**CurrencyConfig Schema:**

```json
{
  "user_id": "user_123",
  "base_currency": "MXN",
  "precision": 2,
  "display_locale": "es-MX",
  "timezone": "America/Mexico_City",
  "rate_sources": ["ecb", "federal_reserve", "manual"],
  "created_at": "2024-11-01T10:00:00Z",
  "updated_at": "2024-11-01T10:00:00Z"
}
```

**Supported Currencies (ISO 4217):**
- Major: USD, EUR, GBP, JPY, MXN, CAD, AUD, CHF, CNY
- Crypto: BTC, ETH (precision: 8 decimals)
- Total: 150+ fiat currencies supported

**Exchange Rate Sources:**
- `ecb` - European Central Bank (primary, updated daily at 16:00 CET)
- `federal_reserve` - US Federal Reserve (fallback, updated daily)
- `manual` - User-provided override

**Precision Rules:**
- Fiat currencies: 2 decimals (e.g., $1.23)
- Crypto (major): 4 decimals (e.g., 0.1234 ETH)
- Bitcoin: 8 decimals (e.g., 0.00012345 BTC)

---

### 6. Validaciones & Estados

**Currency Configuration Validations:**
- Base currency: Must be valid ISO 4217 code (3 uppercase letters)
- Timezone: Must be valid IANA timezone (e.g., "America/Mexico_City")
- Display locale: Must be valid BCP 47 locale (e.g., "es-MX")
- Precision: Integer, 0-8 (matches currency type)
- Rate sources: Array of ["ecb", "federal_reserve", "manual"]

**Exchange Rate Validations:**
- From/To currency: Must be valid ISO 4217, cannot be equal
- Rate: Decimal > 0, max 6 decimals (e.g., 18.5000)
- Rate date: Cannot be in future
- Manual override: Variance from system rate < 10% (warning if higher)

**Amount Conversion Validations:**
- Amount: Decimal, can be negative (for expenses)
- Precision matches target currency (2 for fiat, 4-8 for crypto)
- Overflow protection: Max amount = 999,999,999.99

**State Machine (Exchange Rate):**
```
┌──────────┐
│  fresh   │──24h elapsed──▶│  stale  │
└──────────┘                └─────────┘
     ▲                           │
     │ refresh_cache()           │
     │                           │
     └───────────────────────────┘

States:
- fresh: Rate fetched < 24h ago, use cached value
- stale: Rate fetched ≥ 24h ago, show warning, allow refresh
```

---

### 7. Edge Cases

**EC1: Rate not available for historical date**
- Problem: User imports transaction from 2020, but ECB only has data since 2021
- **Solution:**
  - Try Federal Reserve (longer history)
  - If still unavailable, require manual rate entry
  - Show warning: "Rate not available - please enter manually"

**EC2: Currency mismatch (transaction currency ≠ account currency)**
- Problem: USD account, but transaction in EUR (foreign merchant)
- **Solution:**
  - Convert EUR → USD (account currency) → MXN (base currency)
  - Store intermediate conversion in audit trail
  - Example: €100 → $110 USD → $2,035 MXN (two-step conversion)

**EC3: Same-day rate changes (multiple fetches)**
- Problem: User refreshes rate twice in same day, but ECB updates at 16:00 CET
- **Solution:**
  - Check if fetched_at > ECB update time (16:00 CET)
  - If before, show: "Waiting for today's rate (updates at 16:00 CET)"
  - If after, allow refresh

**EC4: Leap second / DST transition**
- Problem: Date normalization during daylight saving time change
- **Solution:**
  - Use pytz/tzinfo for DST-aware conversions
  - Store UTC timestamp (no DST ambiguity)
  - Display in user's local time with DST indicator

**EC5: Crypto currency high volatility**
- Problem: BTC/USD rate changes 5% in 1 hour
- **Solution:**
  - Mark crypto rates as stale after 1 hour (not 24h)
  - Show real-time warning: "⚠️ Crypto rates are volatile"
  - Allow manual refresh more frequently

**EC6: User changes base currency mid-month**
- Problem: User has 50 transactions in USD, switches base from USD to EUR
- **Solution:**
  - Re-normalize ALL transactions (batch operation)
  - Show progress: "Re-normalizing 50 transactions..."
  - Preserve original amounts (no data loss)
  - Log base currency change in audit trail

**EC7: Inverse rate calculation**
- Problem: System has USD→MXN rate (18.50), user needs MXN→USD
- **Solution:**
  - Calculate inverse: MXN→USD = 1 / 18.50 = 0.0541
  - Cache both directions (rate_usd_mxn and rate_mxn_usd)
  - Ensure precision maintained (6 decimals)

---

### 8. Acceptance Criteria (Definition of Done)

**Currency Configuration:**
- [ ] User can select base currency from 150+ ISO 4217 currencies
- [ ] User can set timezone from IANA database
- [ ] User can set display locale (en-US, es-MX, de-DE, etc.)
- [ ] System validates all configuration fields
- [ ] User can change base currency (triggers re-normalization of all transactions)

**Currency Conversion:**
- [ ] System automatically converts all transactions to base currency
- [ ] System stores original + normalized amounts (context preservation)
- [ ] System fetches rates from ECB (primary) and Federal Reserve (fallback)
- [ ] System caches rates with 24-hour TTL
- [ ] User can see both original and normalized amounts side-by-side
- [ ] User can manually override exchange rate with reason

**Exchange Rate Management:**
- [ ] System marks rates older than 24h as "stale"
- [ ] User can refresh stale rates manually
- [ ] User can view historical rates (date range query)
- [ ] System logs all rate fetches and manual overrides
- [ ] System shows rate source (ECB, Federal Reserve, manual)
- [ ] User can batch-update transactions after rate refresh

**Date/Time Normalization:**
- [ ] System stores all dates in UTC (timezone-agnostic)
- [ ] System displays dates in user's local timezone
- [ ] User can change timezone (re-renders all dates)
- [ ] System handles DST transitions correctly
- [ ] System uses ISO 8601 format for API responses

**Display Formatting:**
- [ ] System formats amounts with locale-aware rules (thousands separator, decimal symbol)
- [ ] System applies precision rules (2 for fiat, 4-8 for crypto)
- [ ] User sees currency symbol based on locale ($ vs € vs £)
- [ ] System handles negative amounts (expenses) correctly

**Multi-Domain:**
- [ ] Pattern applies to Healthcare (currency conversion for international claims)
- [ ] Pattern applies to E-commerce (product pricing in multiple currencies)
- [ ] Pattern applies to Travel (expense reporting in foreign currencies)
- [ ] Pattern applies to Manufacturing (unit conversion: imperial ↔ metric)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "currency_converted",
  "transaction_id": "txn_12345",
  "original_amount": 100.00,
  "original_currency": "USD",
  "normalized_amount": 1850.00,
  "base_currency": "MXN",
  "exchange_rate": 18.5000,
  "rate_source": "ecb",
  "rate_date": "2024-11-01",
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:00:00Z"
}
```

```json
{
  "event": "exchange_rate_refreshed",
  "from_currency": "USD",
  "to_currency": "MXN",
  "old_rate": 18.5000,
  "new_rate": 18.7500,
  "rate_date": "2024-11-01",
  "source": "ecb",
  "transactions_updated": 15,
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:30:00Z"
}
```

```json
{
  "event": "exchange_rate_manual_override",
  "from_currency": "USD",
  "to_currency": "MXN",
  "system_rate": 18.5000,
  "manual_rate": 19.0000,
  "variance_percent": 2.7,
  "reason": "Bank charged higher rate due to foreign transaction fee",
  "transaction_id": "txn_12345",
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:35:00Z"
}
```

```json
{
  "event": "base_currency_changed",
  "old_currency": "USD",
  "new_currency": "EUR",
  "transactions_renormalized": 50,
  "user_id": "user_123",
  "timestamp": "2024-11-01T11:00:00Z"
}
```

**Provenance Chain:**
```
Transaction Imported (1.1)
  ↓
Original Amount Extracted (1.3 Normalization)
  ↓
ExchangeRateProvider.get_rate() (3.6)
  ↓
  ├─ Check Cache (fresh/stale?)
  │   ├─ Cache HIT (fresh) → Use cached rate
  │   └─ Cache MISS/stale → Fetch from ECB
  │       ├─ ECB Success → Cache + Return
  │       └─ ECB Fail → Fallback to Federal Reserve
  ↓
CurrencyConverter.convert() (3.6)
  ↓
NormalizedAmount Created
  ↓
Stored in Transaction.normalized_amount (1.3)
  ↓
Displayed in TransactionList (2.1)
```

---

### 10. Risks & Deferred

**Risks:**
- **R1: Exchange rate API downtime** - ECB or Federal Reserve APIs unavailable
  - **Mitigation:** Multi-source fallback, cache last-known-good rates, manual override option
- **R2: Rate volatility (crypto)** - Crypto rates change rapidly (5%+ per hour)
  - **Mitigation:** Shorter staleness threshold for crypto (1h vs 24h), real-time warning
- **R3: Timezone complexity** - DST transitions, leap seconds, historical timezone changes
  - **Mitigation:** Use battle-tested libraries (pytz, moment-timezone), store UTC only
- **R4: Precision loss** - Floating-point arithmetic errors in currency conversion
  - **Mitigation:** Use Decimal type (Python) or BigDecimal (Java), fixed-point arithmetic

**Deferred:**
- **D1: Real-time crypto prices** - Live BTC/ETH price tracking moved to 4.x Crypto vertical
- **D2: Forward rate contracts** - Currency hedging for future transactions (advanced treasury)
- **D3: Multi-base currency** - Allow users to track in multiple base currencies simultaneously
- **D4: Rate alerts** - Notify user when rate crosses threshold (e.g., USD/MXN > 20.00)
- **D5: Historical price charts** - Line chart showing rate trends moved to 2.3 Dashboard

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 5 new primitives:**

1. **CurrencyConverter** - Convert amounts between currencies
   - File: `docs/primitives/ol/CurrencyConverter.md`
   - Methods: convert, batch_convert, get_precision
   - Responsibilities: Currency conversion, precision handling, batch optimization

2. **DateNormalizer** - Normalize dates between timezones and UTC
   - File: `docs/primitives/ol/DateNormalizer.md`
   - Methods: normalize, display, parse_iso8601
   - Responsibilities: Timezone conversion, DST handling, ISO 8601 compliance

3. **AmountFormatter** - Format amounts with locale-aware rules
   - File: `docs/primitives/ol/AmountFormatter.md`
   - Methods: format, parse, get_locale_rules
   - Responsibilities: Number formatting, currency symbols, locale handling

4. **ExchangeRateProvider** - Fetch and cache exchange rates
   - File: `docs/primitives/ol/ExchangeRateProvider.md`
   - Methods: get_rate, refresh_cache, get_historical, fetch_from_ecb, fetch_from_fed
   - Responsibilities: Multi-source fetching, caching, staleness detection

5. **CurrencyConfigStore** - CRUD for user currency configuration
   - File: `docs/primitives/ol/CurrencyConfigStore.md`
   - Methods: get, update, validate_currency, validate_timezone
   - Responsibilities: Configuration persistence, validation

**Interaction Layer (IL) - 3 new components:**

6. **CurrencySelectorDialog** - Modal for selecting base currency
   - File: `docs/primitives/il/CurrencySelectorDialog.md`
   - Features: Currency list with flags, search, popular currencies first
   - Responsibilities: Currency selection UI, search functionality

7. **AmountDisplayCard** - Display original + normalized amounts
   - File: `docs/primitives/il/AmountDisplayCard.md`
   - Features: Dual currency display, rate tooltip, original amount toggle
   - Responsibilities: Amount visualization, side-by-side display

8. **ExchangeRateWidget** - Display rate with refresh button
   - File: `docs/primitives/il/ExchangeRateWidget.md`
   - Features: Rate display, staleness indicator, refresh button, source badge
   - Responsibilities: Rate visualization, refresh UI, staleness warning

**Schemas - 3 new:**

9. **normalized-amount.schema.json** - Original + normalized amount with rate metadata
10. **exchange-rate-record.schema.json** - Cached exchange rate record
11. **currency-config.schema.json** - User currency and display preferences

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **1.3 Normalization** - Transactions must be normalized before currency conversion
- **1.1 Observation Capture** - Original currency detected from source data
- **2.1 Transaction List** - Display normalized amounts in list view

**Used By:**
- **2.3 Finance Dashboard** - Display totals in base currency
- **4.2 Forecast** - Project future expenses in base currency
- **3.4 Tax Categorization** - Deductions calculated in base currency
- **Future: 4.x Reporting** - Export data in base currency

**Data Flow:**
```
Transaction Imported (1.1)
  ↓
Original Amount Extracted (1.3) → "100.00 USD"
  ↓
ExchangeRateProvider fetches rate (3.6) → "18.5000"
  ↓
CurrencyConverter normalizes (3.6) → "1,850.00 MXN"
  ↓
NormalizedAmount stored in Transaction
  ↓
TransactionList displays (2.1) → "$1,850.00 MXN ($100.00 USD)"
  ↓
Dashboard aggregates (2.3) → "Total: $45,000 MXN"
```

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Value Normalization + Unit Conversion + Context Preservation**

This pattern applies to **any domain requiring unit conversion and display normalization**:

**Finance:**
- Unit: Currency (USD, EUR, MXN)
- Conversion: Exchange rates from ECB/Federal Reserve
- Context: Original amount + normalized amount + rate metadata
- Use Case: Multi-currency expense tracking

**Healthcare:**
- Unit: Currency (USD, EUR) for international claims
- Conversion: Exchange rates for cross-border reimbursement
- Context: Original claim amount + USD equivalent + rate date
- Use Case: International medical billing

**E-commerce:**
- Unit: Currency (customer's local currency → merchant's base currency)
- Conversion: Real-time exchange rates + payment processor fees
- Context: Display price + actual charged amount + conversion rate
- Use Case: Cross-border online shopping

**Travel:**
- Unit: Currency (foreign currency → traveler's home currency)
- Conversion: Exchange rates + credit card foreign transaction fees
- Context: Merchant charge + home currency equivalent + total fees
- Use Case: Travel expense reporting

**Manufacturing:**
- Unit: Temperature (Fahrenheit ↔ Celsius ↔ Kelvin)
- Conversion: Fixed formula (no external API)
- Context: Original reading + normalized value + conversion formula
- Use Case: Quality control in global factories

**Science/Research:**
- Unit: Measurement (imperial ↔ metric, pounds ↔ kilograms)
- Conversion: Fixed conversion factors
- Context: Original measurement + SI unit + conversion factor
- Use Case: Lab data normalization

**Key Abstraction:**
```python
class ValueNormalizer[TOriginal, TNormalized]:
    """
    Universal pattern for value normalization with context preservation.

    Generic enough to apply across:
    - Finance: Currency conversion (USD → EUR)
    - Temperature: Scale conversion (F → C)
    - Distance: Unit conversion (miles → km)
    - Time: Timezone conversion (EST → UTC)
    """
    original_value: TOriginal
    original_unit: str
    normalized_value: TNormalized
    target_unit: str
    conversion_rate: Decimal  # or formula
    conversion_source: str  # API, formula, manual
    converted_at: datetime

class ConversionRateProvider[TFromUnit, TToUnit]:
    """
    Fetches conversion rates/formulas with caching.

    Examples:
    - Currency: Fetch from ECB API, cache 24h
    - Temperature: Return fixed formula, cache forever
    - Distance: Return fixed factor, cache forever
    """
    def get_rate(from_unit: TFromUnit, to_unit: TToUnit,
                 context_date: Optional[date] = None) -> Decimal:
        """Returns conversion rate/factor."""

    def refresh_cache(from_unit: TFromUnit, to_unit: TToUnit) -> Decimal:
        """Forces cache invalidation and refetch."""
```

---

### 14. Pattern Abstraction

**Pattern Name:** Value Normalization + Unit Conversion + Context Preservation

**Problem Statement:**
Users need to work with values in different units (currencies, temperatures, distances, timezones) while maintaining the original context for audit and provenance. System must convert values to a standard unit for aggregation while preserving the original for display and compliance.

**Solution Architecture:**

1. **Dual Storage** - Store both original and normalized values
2. **Conversion Metadata** - Track conversion rate, source, and date
3. **Multi-Source Providers** - Fetch conversion rates from multiple sources with fallback
4. **Caching Layer** - Cache conversion rates with staleness detection
5. **Display Formatting** - Locale-aware formatting for user display

**Components:**
- **ValueNormalizer** - Converts values while preserving original context
- **ConversionRateProvider** - Fetches conversion rates/formulas with caching and fallback
- **DisplayFormatter** - Formats normalized values for display with locale awareness
- **ConfigStore** - Manages user preferences (target unit, locale, timezone)

**When to Use:**
- ✅ Need to aggregate values in different units (sum expenses in multiple currencies)
- ✅ Must preserve original context (audit trail, compliance)
- ✅ Conversion rates/formulas change over time (exchange rates, regulations)
- ✅ Display format varies by user locale (US: $1,234.56 vs ES: $1.234,56)
- ❌ Simple one-way conversion with no history (use direct formula)
- ❌ No aggregation needed (display original values only)

**Examples:**

**Finance (Currency):**
```python
# Original: $100 USD, User's base: MXN
normalizer = ValueNormalizer()
result = normalizer.normalize(
    original_value=100.00,
    original_unit="USD",
    target_unit="MXN",
    context_date=date(2024, 11, 1)
)
# Result: NormalizedAmount(
#   original=100.00, original_unit="USD",
#   normalized=1850.00, target_unit="MXN",
#   conversion_rate=18.50, source="ecb"
# )
```

**Manufacturing (Temperature):**
```python
# Original: 212°F, Target: Celsius
result = normalizer.normalize(
    original_value=212.0,
    original_unit="fahrenheit",
    target_unit="celsius",
    context_date=None  # No time dependency
)
# Result: NormalizedValue(
#   original=212.0, original_unit="fahrenheit",
#   normalized=100.0, target_unit="celsius",
#   conversion_formula="(F - 32) * 5/9", source="fixed"
# )
```

**Travel (Distance):**
```python
# Original: 100 miles, Target: kilometers
result = normalizer.normalize(
    original_value=100.0,
    original_unit="miles",
    target_unit="kilometers",
    context_date=None
)
# Result: NormalizedValue(
#   original=100.0, original_unit="miles",
#   normalized=160.93, target_unit="kilometers",
#   conversion_factor=1.60934, source="fixed"
# )
```

---

### 15. Métricas de Madurez

**Coverage Metrics:**
- % of transactions with normalized amounts (target: 100%)
- % of transactions with fresh rates (<24h) (target: >95%)
- % of rates from primary source (ECB) vs fallback (target: >90% ECB)
- % of manual rate overrides (target: <5%)

**Quality Metrics:**
- Exchange rate fetch success rate (target: >99%)
- Rate variance from multiple sources (ECB vs Fed) (target: <0.5% variance)
- Precision accuracy (no rounding errors) (target: 100%)
- Timezone conversion accuracy (DST transitions) (target: 100%)

**Performance Metrics:**
- Rate fetch latency from cache (target: <10ms p95)
- Rate fetch latency from ECB API (target: <500ms p95)
- Batch conversion throughput (target: >1000 transactions/sec)
- Display formatting latency (target: <5ms p95)

**User Engagement:**
- % users who customize base currency (target: >80%)
- % users who refresh stale rates (target: >30%)
- % users who override rates manually (target: <10%)
- Avg transactions per user in foreign currency (target: >5/month)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All operations require valid bearer token
- Users can only update their own currency configuration
- Rate refresh limited to user's own transactions
- Manual overrides logged with user_id

**Input Validation:**
- Currency code: Pattern validation ^[A-Z]{3}$ (prevent injection)
- Amount: Decimal validation, range check (prevent overflow)
- Timezone: IANA database validation (prevent arbitrary string)
- Locale: BCP 47 validation (prevent XSS)
- Exchange rate: Range validation (0.0001 to 1,000,000)

**API Security:**
- **Rate limiting:**
  - Get rate: 1000 requests/minute per user
  - Refresh rate: 10 requests/minute per user (prevent API abuse)
  - Convert amount: 100 requests/minute per user
- **SQL Injection Prevention:** Use parameterized queries
  - Example: `SELECT * FROM exchange_rates WHERE from_currency = ? AND to_currency = ?`

**Trust Construction Elements:**
- **Audit trail:** All rate overrides logged with reason and user_id
- **Variance validation:** Manual rates >10% variance require confirmation
- **Source transparency:** Always display rate source (ECB, Federal Reserve, manual)
- **Staleness indicator:** Visual warning for rates >24h old
- **Precision guarantee:** Use Decimal type, never float (prevent rounding errors)

**Data Privacy:**
- Override reasons may contain sensitive info (e.g., "negotiated rate with vendor ABC")
- Do not log override reasons in external systems
- Redact PII in error messages

**External API Security:**
- **ECB API:** HTTPS only, validate SSL certificate
- **Federal Reserve API:** HTTPS only, API key in environment variable (not code)
- **Timeout:** 5 seconds max (prevent hang)
- **Circuit breaker:** After 3 failures, disable source for 5 minutes

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `GET /api/user/currency-config`: <50ms
- `GET /api/exchange-rates?from=USD&to=MXN`: <100ms (cache hit), <500ms (cache miss)
- `POST /api/exchange-rates/refresh`: <1000ms (includes API call)
- `POST /api/convert`: <50ms (cache hit)
- `PATCH /api/user/currency-config`: <200ms

**Scalability:**
- Rates cached per currency pair per date: ~50,000 unique rates (150 currencies × 150 × 2 days)
- Cache size: ~10 MB (50,000 × 200 bytes)
- Batch conversion: 1,000 transactions/second (single rate fetch, loop conversion)
- Concurrent users: 10,000 (cache shared across users)

**Database Indexes:**
```sql
-- Exchange rates cache
CREATE INDEX idx_exchange_rates_pair_date
ON exchange_rates(from_currency, to_currency, rate_date);

CREATE INDEX idx_exchange_rates_fetched
ON exchange_rates(fetched_at);  -- For staleness detection

CREATE INDEX idx_exchange_rates_source
ON exchange_rates(source);  -- For source analytics

-- User currency config
CREATE UNIQUE INDEX idx_currency_config_user
ON currency_configs(user_id);

-- Transactions (normalized_amount is JSONB)
CREATE INDEX idx_transactions_normalized
ON transactions((normalized_amount->>'base_currency'), (normalized_amount->>'normalized_amount'));
```

**Caching Strategy:**
- **Exchange rates:**
  - Key: `rate_{from}_{to}_{date}` (e.g., `rate_usd_mxn_20241101`)
  - TTL: 24 hours (configurable per currency type: crypto 1h, fiat 24h)
  - Storage: Redis (fast lookup, distributed)
  - Eviction: LRU (Least Recently Used)

- **User configuration:**
  - Key: `currency_config_{user_id}`
  - TTL: 5 minutes (low write frequency)
  - Storage: Redis
  - Invalidation: On update (write-through)

- **Timezone data:**
  - Key: `timezone_db`
  - TTL: 7 days (rarely changes)
  - Storage: Redis
  - Size: ~500 KB (all IANA timezones)

**Background Jobs:**
- **Daily (02:00 UTC):** Fetch rates for popular pairs (USD/EUR, USD/MXN, etc.) - proactive caching
- **Hourly:** Refresh crypto rates (BTC/USD, ETH/USD) - volatility handling
- **Daily (03:00 UTC):** Purge stale cache entries (>30 days old)
- **Weekly:** Audit manual overrides (variance analysis)

**Optimization Techniques:**
- **Batch fetching:** Fetch multiple currency pairs in single API call (ECB supports batch)
- **Inverse caching:** Cache both USD→MXN and MXN→USD (avoid recalculation)
- **Connection pooling:** Reuse HTTP connections to ECB/Fed APIs
- **Compression:** Gzip cache entries (reduce Redis memory by 60%)

---

### 18. Observability

**Metrics:**
```
# Exchange rate metrics
exchange_rates.fetched.count (counter, labels: source, from_currency, to_currency)
exchange_rates.cache_hit.count (counter, labels: from_currency, to_currency)
exchange_rates.cache_miss.count (counter, labels: from_currency, to_currency)
exchange_rates.stale.count (counter, labels: from_currency, to_currency)
exchange_rates.manual_override.count (counter, labels: from_currency, to_currency)
exchange_rates.variance.gauge (gauge, labels: from_currency, to_currency)

# API latency
exchange_rates.fetch.latency (histogram, labels: source)  # ECB, Fed, manual
currency.convert.latency (histogram)
currency.format.latency (histogram)

# Accuracy
exchange_rates.source_variance (gauge)  # ECB vs Fed variance %
timezone.conversion.errors (counter)

# User behavior
currency_config.updates.count (counter, labels: user_id)
base_currency.changes.count (counter, labels: old_currency, new_currency)
```

**Structured Logs:**
- All rate fetches (source, latency, success/failure)
- All manual overrides (user_id, reason, variance %)
- All cache misses (currency pair, date)
- All API failures (source, error, retry count)
- All base currency changes (user_id, old, new, transactions updated)

**Dashboards:**

**Dashboard 1: Exchange Rate Health**
- Rate fetch success rate by source (target: >99%)
- Cache hit rate (target: >90%)
- Stale rate count (target: <5% of total)
- Manual override rate (target: <5%)
- ECB vs Federal Reserve variance (target: <0.5%)

**Dashboard 2: Performance**
- API latency histogram (p50, p95, p99)
- Cache hit latency (target: <10ms p95)
- Cache miss latency (target: <500ms p95)
- Batch conversion throughput (transactions/sec)

**Dashboard 3: User Behavior**
- Base currency distribution (pie chart: USD, EUR, MXN, etc.)
- Currency pair popularity (bar chart: USD/EUR, USD/MXN, etc.)
- Manual override frequency (line chart over time)
- Base currency changes per week

**Alerts:**
- **Critical:** Exchange rate fetch failure rate >5% (check API connectivity)
- **Critical:** Cache hit rate <50% (check Redis)
- **Warning:** Stale rate count >10% (investigate slow refresh)
- **Warning:** Manual override variance >10% (investigate user behavior or rate accuracy)
- **Info:** ECB vs Fed variance >1% (investigate data source discrepancy)

**Tracing:**
- Trace conversion flow: Transaction → get_rate → check_cache → fetch_ecb → convert → format
- Include: transaction_id, from/to currency, rate, source, latency for each step
- Distributed tracing: Link frontend conversion request to backend API calls

**Log Examples:**
```json
{
  "timestamp": "2024-11-01T10:00:00Z",
  "level": "INFO",
  "event": "exchange_rate_fetched",
  "from_currency": "USD",
  "to_currency": "MXN",
  "rate": 18.5000,
  "source": "ecb",
  "latency_ms": 245,
  "cache_miss": true
}
```

```json
{
  "timestamp": "2024-11-01T10:30:00Z",
  "level": "WARN",
  "event": "exchange_rate_manual_override",
  "user_id": "user_123",
  "from_currency": "USD",
  "to_currency": "MXN",
  "system_rate": 18.5000,
  "manual_rate": 19.0000,
  "variance_percent": 2.7,
  "reason": "Bank charged higher rate"
}
```

---

### 19. Testing Strategy

**Unit Tests:**

```python
# CurrencyConverter tests
def test_convert_usd_to_mxn():
    converter = CurrencyConverter(rate_provider=mock_provider)
    result = converter.convert(
        amount=Decimal("100.00"),
        from_currency="USD",
        to_currency="MXN",
        rate_date=date(2024, 11, 1)
    )
    assert result.original_amount == Decimal("100.00")
    assert result.normalized_amount == Decimal("1850.00")
    assert result.exchange_rate == Decimal("18.5000")
    assert result.rate_source == "ecb"

def test_convert_same_currency():
    result = converter.convert(
        amount=Decimal("100.00"),
        from_currency="USD",
        to_currency="USD",
        rate_date=date(2024, 11, 1)
    )
    assert result.exchange_rate == Decimal("1.0000")
    assert result.normalized_amount == Decimal("100.00")

def test_convert_precision_crypto():
    result = converter.convert(
        amount=Decimal("0.12345678"),  # 8 decimals (BTC)
        from_currency="BTC",
        to_currency="USD",
        rate_date=date(2024, 11, 1)
    )
    assert result.normalized_amount.as_tuple().exponent == -2  # 2 decimals for USD

# ExchangeRateProvider tests
def test_get_rate_cache_hit():
    provider = ExchangeRateProvider(cache=mock_cache)
    mock_cache.get.return_value = {"rate": 18.5000, "fetched_at": "2024-11-01T08:00:00Z"}

    rate = provider.get_rate("USD", "MXN", date(2024, 11, 1))

    assert rate.rate == Decimal("18.5000")
    assert rate.is_stale == False
    mock_cache.get.assert_called_once()

def test_get_rate_cache_miss_fetch_ecb():
    provider = ExchangeRateProvider(cache=mock_cache)
    mock_cache.get.return_value = None

    with mock.patch('requests.get') as mock_get:
        mock_get.return_value.json.return_value = {"rates": {"MXN": 18.5000}}
        rate = provider.get_rate("USD", "MXN", date(2024, 11, 1))

    assert rate.rate == Decimal("18.5000")
    assert rate.source == "ecb"
    mock_cache.set.assert_called_once()  # Cache the result

def test_get_rate_ecb_fail_fallback_fed():
    provider = ExchangeRateProvider(cache=mock_cache)
    mock_cache.get.return_value = None

    with mock.patch('requests.get') as mock_get:
        # ECB fails
        mock_get.side_effect = [
            requests.exceptions.Timeout(),
            # Federal Reserve succeeds
            Mock(json=lambda: {"rates": {"MXN": 18.6000}})
        ]
        rate = provider.get_rate("USD", "MXN", date(2024, 11, 1))

    assert rate.source == "federal_reserve"
    assert rate.rate == Decimal("18.6000")

# DateNormalizer tests
def test_normalize_to_utc():
    normalizer = DateNormalizer()
    user_date = datetime(2024, 11, 1, 10, 0, 0)  # 10:00 AM Mexico City

    utc_date = normalizer.normalize(user_date, "America/Mexico_City")

    assert utc_date.tzinfo == pytz.UTC
    assert utc_date.hour == 16  # 10 AM CST = 4 PM UTC (GMT-6)

def test_display_in_user_timezone():
    normalizer = DateNormalizer()
    utc_date = datetime(2024, 11, 1, 16, 0, 0, tzinfo=pytz.UTC)

    display_str = normalizer.display(utc_date, "America/Mexico_City")

    assert display_str == "Nov 1, 2024 10:00 AM"  # Back to Mexico City time

def test_dst_transition():
    normalizer = DateNormalizer()
    # Test date during DST transition (spring forward)
    user_date = datetime(2024, 3, 10, 2, 30, 0)  # 2:30 AM doesn't exist!

    utc_date = normalizer.normalize(user_date, "America/New_York")

    assert utc_date.hour == 7  # Correctly handles DST (3:30 AM EDT = 7:30 AM UTC)

# AmountFormatter tests
def test_format_usd_en_us():
    formatter = AmountFormatter()
    formatted = formatter.format(Decimal("1234.56"), "USD", "en-US")
    assert formatted == "$1,234.56"

def test_format_eur_es_es():
    formatter = AmountFormatter()
    formatted = formatter.format(Decimal("1234.56"), "EUR", "es-ES")
    assert formatted == "1.234,56 €"  # European format

def test_format_crypto_btc():
    formatter = AmountFormatter()
    formatted = formatter.format(Decimal("0.12345678"), "BTC", "en-US")
    assert formatted == "0.12345678 BTC"  # 8 decimals preserved
```

**Integration Tests:**

```python
def test_end_to_end_currency_conversion():
    # 1. Create user with MXN base currency
    user = create_user(base_currency="MXN", timezone="America/Mexico_City")

    # 2. Import transaction in USD
    transaction = import_transaction(
        amount=100.00,
        currency="USD",
        date="2024-11-01",
        user_id=user.id
    )

    # 3. Verify normalization happened automatically
    assert transaction.normalized_amount.original_currency == "USD"
    assert transaction.normalized_amount.base_currency == "MXN"
    assert transaction.normalized_amount.normalized_amount == Decimal("1850.00")
    assert transaction.normalized_amount.rate_source == "ecb"

    # 4. Verify display
    response = client.get(f"/api/transactions/{transaction.id}")
    assert "$1,850.00 MXN" in response.json()["display_amount"]
    assert "($100.00 USD @ 18.50)" in response.json()["display_amount"]

def test_rate_refresh_flow():
    # 1. Create transaction with stale rate (25h old)
    transaction = create_transaction_with_stale_rate()

    # 2. User refreshes rate
    response = client.post("/api/exchange-rates/refresh", json={
        "from_currency": "USD",
        "to_currency": "MXN",
        "apply_to_transactions": True
    })

    assert response.status_code == 200
    assert response.json()["transactions_updated"] == 1

    # 3. Verify transaction updated
    updated_transaction = client.get(f"/api/transactions/{transaction.id}")
    assert updated_transaction.json()["normalized_amount"]["rate_source"] == "ecb"
    assert updated_transaction.json()["normalized_amount"]["is_stale"] == False

def test_manual_override_flow():
    # 1. Create transaction
    transaction = create_transaction(amount=100, currency="USD")

    # 2. User overrides rate
    response = client.post("/api/exchange-rates/override", json={
        "from_currency": "USD",
        "to_currency": "MXN",
        "rate": 19.0000,
        "rate_date": "2024-11-01",
        "reason": "Bank charged higher rate",
        "transaction_id": transaction.id
    })

    assert response.status_code == 201

    # 3. Verify transaction updated
    updated = client.get(f"/api/transactions/{transaction.id}")
    assert updated.json()["normalized_amount"]["exchange_rate"] == 19.0000
    assert updated.json()["normalized_amount"]["rate_source"] == "manual"
    assert updated.json()["normalized_amount"]["override_reason"] == "Bank charged higher rate"

def test_base_currency_change_renormalization():
    # 1. Create user with USD base, import 10 transactions
    user = create_user(base_currency="USD")
    transactions = [create_transaction(user_id=user.id) for _ in range(10)]

    # 2. Change base currency to EUR
    response = client.patch("/api/user/currency-config", json={
        "base_currency": "EUR"
    })

    assert response.status_code == 200

    # 3. Verify all transactions re-normalized
    for txn_id in [t.id for t in transactions]:
        txn = client.get(f"/api/transactions/{txn_id}")
        assert txn.json()["normalized_amount"]["base_currency"] == "EUR"
```

**Multi-Domain Tests:**

```python
# Healthcare: International medical claim currency conversion
def test_healthcare_international_claim():
    # Claim filed in EUR, patient's insurance in USD
    claim = create_medical_claim(amount=1000, currency="EUR")
    normalized = converter.convert(1000, "EUR", "USD", date(2024, 11, 1))
    assert normalized.base_currency == "USD"
    # Reimbursement calculated in USD

# E-commerce: Product pricing in multiple currencies
def test_ecommerce_product_pricing():
    # Product priced in USD, display in user's local currency (MXN)
    product_price = Decimal("99.99")
    user_currency = "MXN"
    displayed_price = converter.convert(product_price, "USD", user_currency, date.today())
    assert displayed_price.base_currency == user_currency
    # User sees price in MXN

# Travel: Expense reporting in foreign currency
def test_travel_expense_reporting():
    # Employee spent EUR abroad, company reimburses in USD
    expense = create_expense(amount=200, currency="EUR", category="meals")
    reimbursement = converter.convert(200, "EUR", "USD", expense.date)
    assert reimbursement.base_currency == "USD"
    # Company pays in USD

# Manufacturing: Temperature conversion
def test_manufacturing_temperature_conversion():
    # Sensor reads Fahrenheit, system stores Celsius
    fahrenheit = Decimal("212.0")
    celsius = temperature_converter.convert(fahrenheit, "fahrenheit", "celsius")
    assert celsius.normalized_value == Decimal("100.0")
    # Boiling point of water
```

**Performance Tests:**

```python
def test_batch_conversion_performance():
    # Convert 1000 transactions in batch
    transactions = [create_transaction() for _ in range(1000)]

    start = time.time()
    results = converter.batch_convert(transactions)
    elapsed = time.time() - start

    assert elapsed < 1.0  # Target: <1 second for 1000 transactions
    assert len(results) == 1000

def test_cache_hit_performance():
    # Measure cache hit latency
    provider = ExchangeRateProvider(cache=redis_cache)

    # Warm cache
    provider.get_rate("USD", "MXN", date(2024, 11, 1))

    # Measure cache hit
    start = time.time()
    for _ in range(1000):
        provider.get_rate("USD", "MXN", date(2024, 11, 1))
    elapsed = time.time() - start

    assert elapsed / 1000 < 0.010  # Target: <10ms per lookup
```

---

### 20. Operations Runbook

**Deployment:**

**1. Database Migrations:**

```sql
-- Create currency_configs table
CREATE TABLE currency_configs (
    user_id UUID PRIMARY KEY,
    base_currency VARCHAR(3) NOT NULL CHECK (base_currency ~ '^[A-Z]{3}$'),
    precision INTEGER NOT NULL CHECK (precision >= 0 AND precision <= 8),
    display_locale VARCHAR(10) NOT NULL,
    timezone VARCHAR(50) NOT NULL,
    rate_sources JSONB NOT NULL DEFAULT '["ecb", "federal_reserve", "manual"]'::jsonb,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Create exchange_rates cache table
CREATE TABLE exchange_rates (
    rate_id VARCHAR(100) PRIMARY KEY,
    from_currency VARCHAR(3) NOT NULL,
    to_currency VARCHAR(3) NOT NULL,
    rate DECIMAL(12, 6) NOT NULL CHECK (rate > 0),
    rate_date DATE NOT NULL,
    source VARCHAR(20) NOT NULL CHECK (source IN ('ecb', 'federal_reserve', 'manual')),
    fetched_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    is_stale BOOLEAN GENERATED ALWAYS AS (NOW() > expires_at) STORED,
    metadata JSONB,
    UNIQUE(from_currency, to_currency, rate_date, source)
);

-- Add normalized_amount to transactions table (JSONB column)
ALTER TABLE transactions ADD COLUMN normalized_amount JSONB;

-- Indexes
CREATE INDEX idx_exchange_rates_pair_date
ON exchange_rates(from_currency, to_currency, rate_date);

CREATE INDEX idx_exchange_rates_fetched
ON exchange_rates(fetched_at);

CREATE INDEX idx_exchange_rates_stale
ON exchange_rates(is_stale) WHERE is_stale = true;

CREATE UNIQUE INDEX idx_currency_config_user
ON currency_configs(user_id);

CREATE INDEX idx_transactions_normalized_currency
ON transactions((normalized_amount->>'base_currency'));
```

**2. Seed Initial Data:**

```bash
# Set default currency config for existing users
python /app/scripts/seed_currency_configs.py --default-currency=USD --default-timezone=UTC

# Pre-cache popular exchange rates
python /app/scripts/prefetch_rates.py --pairs=USD/EUR,USD/MXN,USD/GBP,EUR/GBP --days=7
```

**3. Environment Variables:**

```bash
# Exchange rate API keys
ECB_API_URL=https://api.exchangerate.host/latest
FEDERAL_RESERVE_API_KEY=your_api_key_here
FEDERAL_RESERVE_API_URL=https://api.federalreserve.gov/data

# Cache settings
REDIS_URL=redis://localhost:6379/0
EXCHANGE_RATE_CACHE_TTL_SECONDS=86400  # 24 hours
CRYPTO_RATE_CACHE_TTL_SECONDS=3600  # 1 hour

# Rate fetch settings
EXCHANGE_RATE_FETCH_TIMEOUT_SECONDS=5
EXCHANGE_RATE_MAX_RETRIES=3
```

**Monitoring:**

**Health Check:**
```bash
# Check if currency conversion is working
curl -X GET "https://api.example.com/api/health/currency" \
  -H "Authorization: Bearer TOKEN"

# Expected response:
# {
#   "status": "healthy",
#   "exchange_rate_provider": "ecb",
#   "cache_hit_rate": 0.92,
#   "last_rate_fetch": "2024-11-01T08:00:00Z"
# }
```

**Metric Alerts:**
- **Critical:** Exchange rate fetch failure rate >5% → Check ECB/Fed API connectivity
- **Critical:** Cache hit rate <50% → Check Redis connectivity
- **Warning:** Stale rate count >10% → Investigate refresh job
- **Warning:** Manual override rate >10% → Investigate rate accuracy or user confusion
- **Info:** ECB vs Fed variance >1% → Investigate data source discrepancy

**Common Issues:**

**Issue 1: Exchange rate API down (ECB)**
- **Symptom:** All rate fetches failing with timeout error
- **Debug:**
  1. Check ECB API status: `curl https://api.exchangerate.host/latest?base=USD`
  2. Check network connectivity: `ping api.exchangerate.host`
  3. Check logs for error messages
- **Fix:**
  - System automatically falls back to Federal Reserve
  - If both fail, rates served from cache (may be stale)
  - Monitor alert will trigger, ops team notified
- **Recovery:** Once ECB API restored, system auto-recovers (cache refreshes on next fetch)

**Issue 2: Stale rates accumulating**
- **Symptom:** >10% of rates marked as stale, users seeing warnings
- **Debug:**
  1. Check background refresh job: `ps aux | grep prefetch_rates`
  2. Check Redis cache size: `redis-cli INFO memory`
  3. Check rate fetch latency: Check Datadog/Grafana dashboard
- **Fix:**
  - Manually trigger refresh: `python /app/scripts/prefetch_rates.py --all`
  - Check if job scheduler (cron/Kubernetes CronJob) is running
  - Increase cache TTL temporarily: `export EXCHANGE_RATE_CACHE_TTL_SECONDS=172800`  # 48h
- **Recovery:** Resume normal refresh schedule, rates auto-refresh

**Issue 3: Currency conversion producing incorrect results**
- **Symptom:** User reports $100 USD showing as $100 MXN (rate = 1.0)
- **Debug:**
  1. Check rate fetch for currency pair:
     ```bash
     curl -X GET "/api/exchange-rates?from=USD&to=MXN&date=2024-11-01"
     ```
  2. Verify rate in database:
     ```sql
     SELECT * FROM exchange_rates
     WHERE from_currency='USD' AND to_currency='MXN'
     ORDER BY rate_date DESC LIMIT 10;
     ```
  3. Check for manual overrides:
     ```sql
     SELECT * FROM exchange_rates
     WHERE from_currency='USD' AND to_currency='MXN' AND source='manual';
     ```
- **Fix:**
  - If rate is 1.0 (incorrect), invalidate cache and refetch:
    ```bash
    redis-cli DEL rate_usd_mxn_20241101
    curl -X POST "/api/exchange-rates/refresh" -d '{"from":"USD","to":"MXN"}'
    ```
  - If manual override is wrong, delete and refetch:
    ```sql
    DELETE FROM exchange_rates WHERE rate_id='rate_usd_mxn_20241101_manual_user123';
    ```

**Issue 4: Timezone conversion showing wrong times**
- **Symptom:** Transaction dated "Nov 1, 2024 10:00 AM" shows as "Nov 1, 2024 4:00 PM"
- **Debug:**
  1. Check user's timezone setting:
     ```sql
     SELECT timezone FROM currency_configs WHERE user_id='user_123';
     ```
  2. Verify UTC storage:
     ```sql
     SELECT date, timezone FROM transactions WHERE transaction_id='txn_12345';
     ```
  3. Check for DST transition (spring forward / fall back)
- **Fix:**
  - If timezone incorrect, update user config:
    ```bash
    curl -X PATCH "/api/user/currency-config" \
      -d '{"timezone":"America/Mexico_City"}'
    ```
  - If DST issue, verify pytz library is up-to-date:
    ```bash
    pip install --upgrade pytz
    ```

**Issue 5: High variance between ECB and Federal Reserve rates**
- **Symptom:** ECB rate: 18.50, Fed rate: 18.90 (2.2% variance)
- **Debug:**
  1. Fetch rates from both sources manually:
     ```bash
     curl "https://api.exchangerate.host/latest?base=USD&symbols=MXN"
     curl "https://api.federalreserve.gov/data?series_id=DEXMXUS"
     ```
  2. Check rate dates (ensure same date)
  3. Check if one source has stale data
- **Fix:**
  - If variance within 1%, no action (normal market fluctuation)
  - If variance >1%, investigate which source is more accurate:
    - Compare to third source (e.g., xe.com, Bloomberg)
    - Temporarily disable less accurate source
    - Log variance in audit trail for analysis

**Incident Response Commands:**

```bash
# Force refresh all rates for today
python /app/scripts/prefetch_rates.py --all --date=today

# Invalidate all cache entries (nuclear option)
redis-cli FLUSHDB

# Re-normalize all transactions for user (after base currency change)
python /app/scripts/renormalize_transactions.py --user-id=user_123

# Audit manual overrides (variance >5%)
python /app/scripts/audit_manual_overrides.py --variance-threshold=5.0

# Export exchange rate history for debugging
python /app/scripts/export_rate_history.py --from=USD --to=MXN --start=2024-10-01 --end=2024-11-01 --output=/tmp/rates.csv

# Check cache health
redis-cli INFO stats
redis-cli DBSIZE
redis-cli --scan --pattern "rate_*" | wc -l  # Count cached rates
```

**Backup & Recovery:**

```bash
# Backup exchange rates cache (daily)
redis-cli --rdb /backups/exchange_rates_$(date +%Y%m%d).rdb

# Restore cache from backup
redis-cli --rdb /backups/exchange_rates_20241101.rdb

# Backup user currency configs (daily)
pg_dump -t currency_configs > /backups/currency_configs_$(date +%Y%m%d).sql

# Restore user configs
psql < /backups/currency_configs_20241101.sql
```

**Performance Tuning:**

```bash
# Increase Redis max memory
redis-cli CONFIG SET maxmemory 2gb
redis-cli CONFIG SET maxmemory-policy allkeys-lru

# Optimize database indexes
VACUUM ANALYZE exchange_rates;
REINDEX TABLE exchange_rates;

# Monitor slow queries
SELECT * FROM pg_stat_statements
WHERE query LIKE '%exchange_rates%'
ORDER BY total_time DESC
LIMIT 10;
```

---

## 🎯 Summary

Vertical 3.6 delivers a **value normalization system** with:

✅ **5 OL Primitives** (CurrencyConverter, DateNormalizer, AmountFormatter, ExchangeRateProvider, CurrencyConfigStore)
✅ **3 IL Components** (CurrencySelectorDialog, AmountDisplayCard, ExchangeRateWidget)
✅ **3 Schemas** (normalized-amount, exchange-rate-record, currency-config)
✅ **20 Complete Sections** (Product, Machinery, Cross-Cutting)
✅ **Multi-Domain Pattern** (Finance → Currency, Healthcare → International claims, E-commerce → Product pricing, Manufacturing → Unit conversion)

**Finance Instantiation:**
- Multi-currency transactions normalized to user's base currency
- Exchange rates from ECB (primary) and Federal Reserve (fallback)
- Original + normalized amounts preserved (context preservation)
- Manual rate override with audit trail
- Locale-aware display formatting

**Universal Pattern: Value Normalization + Unit Conversion**
- Dual storage (original + normalized values)
- Multi-source conversion providers (ECB, Federal Reserve, formulas)
- Caching with staleness detection
- Display formatting with locale awareness
- Context preservation for audit and compliance

**Next:** 3.7 Search & Filters (transaction search, faceted filtering, saved searches)
