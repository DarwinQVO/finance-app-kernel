# Vertical 3.9: Reconciliation Strategies (Multi-Source Transaction Matching)

> **Type:** Multi-Source Matching System
> **Pattern:** Fuzzy Matching + Confidence Scoring + Threshold-Based Decision
> **Last Updated:** 2025-10-24

---

## 📋 Overview

The **Reconciliation Strategies** vertical provides a **multi-source matching system** for reconciling transactions across different data sources (bank statements, credit cards, invoices, payment processors) with fuzzy matching, confidence scoring, and threshold-based automated decisions. While demonstrated in finance domain (bank-to-invoice, credit-card-to-bank reconciliation), the underlying primitives are domain-agnostic and apply to ANY entity matching across heterogeneous sources.

**Key Characteristics:**
- **Fuzzy Matching:** Tolerance-based matching (amount ±5%, date ±7 days, counterparty name similarity)
- **Multi-Feature Scoring:** Weighted similarity scores (40% amount, 30% date, 20% counterparty, 10% description)
- **Confidence Thresholds:** Auto-link (≥0.95), auto-suggest (0.70-0.94), manual review (0.50-0.69), no-match (<0.50)
- **Cardinality Support:** One-to-one, one-to-many, many-to-one matching
- **Manual Override:** User can create/reject matches, system learns from decisions
- **Audit Trail:** Full provenance of match decisions (automated vs manual)

**Finance Domain Examples:**
- **Bank-to-Invoice:** Match bank payment ($5,000) with invoice INV-2024-001 ($5,000) by amount + date + vendor
- **Credit-Card-to-Bank:** Match credit card charge ($150 from "AMZN") with bank payment ($150 to "Amazon.com")
- **Multi-Payment:** Match single invoice ($10,000) with 3 partial payments ($5K, $3K, $2K)
- **Split Payment:** Match single bank transaction ($1,500) with 2 invoices ($800 + $700)
- **FX Reconciliation:** Match USD payment ($1,000) with EUR invoice (€920) using exchange rates

**Multi-Domain Applicability:**
- **Healthcare:** Match insurance claims with payments across payer systems (EOB vs claim, patient payment vs invoice)
- **Legal:** Match court filings across jurisdictions (PACER vs state court systems, case number variations)
- **Research:** Match citations across databases (DOI, arXiv, PubMed, Google Scholar - same paper, different IDs)
- **E-commerce:** Match orders with shipments and payments (order #123 → shipment #456 → payment txn_789)
- **Logistics:** Match shipments with customs declarations and delivery confirmations

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Fuzzy matching across multiple data sources with configurable tolerances
- Multi-feature similarity scoring (amount, date, counterparty, description, custom fields)
- Threshold-based decision automation (auto-link, auto-suggest, manual review)
- One-to-one, one-to-many, many-to-one reconciliation
- Manual match creation and rejection (user override)
- Match confidence scoring with feature breakdown
- Blocking strategies for performance (pre-filter candidates by date range, amount range)
- Match audit trail (who matched, when, confidence, method)
- Bulk reconciliation operations (reconcile 1000s of transactions)

**Out of Scope:**
- Financial close process (covered in future vertical 4.x Accounting)
- Double-entry bookkeeping (covered in 4.x General Ledger)
- Automated payment execution (covered in 3.x Payment Automation)
- Machine learning model training (initial version uses rule-based, ML in v2)
- Real-time streaming reconciliation (batch processing only in v1)

**Boundaries:**
- Sources must be normalized first (1.3 Normalization runs before reconciliation)
- Matching is within same currency (FX conversion via 3.6 Unit before reconciliation)
- User defines what sources to reconcile (system doesn't auto-detect source pairs)
- One match per item (can't link same transaction to multiple invoices, use many-to-one instead)
- Confidence thresholds are system-wide defaults (user can override per-source in v2)

---

### 2. User Flow (Real Usage)

**Scenario 1: User reconciles bank payment with invoice (auto-link)**

User: "I paid invoice INV-2024-001 via bank transfer, need to confirm it matched"

System:
1. User navigates to Reconciliation Dashboard
2. Selects source pair: "Bank Account (Chase Business)" vs "Invoices (QuickBooks)"
3. Dashboard shows:
   - Unmatched Bank Transactions: 15
   - Unmatched Invoices: 8
   - Auto-Linked (high confidence): 3
   - Suggested Matches (review needed): 5
4. User clicks "Auto-Linked" tab
5. Sees match:
   ```
   Bank Payment: -$5,000.00 • Oct 15, 2024 • "ACH to Acme Corp"
   ⬇️ MATCHED (98% confidence)
   Invoice: INV-2024-001 • $5,000.00 • Oct 14, 2024 • "Acme Corporation"

   Match Details:
   ✓ Amount: 100% match ($5,000.00 = $5,000.00)
   ✓ Date: 1 day difference (within ±7 days tolerance)
   ✓ Counterparty: 95% similarity ("Acme Corp" ≈ "Acme Corporation")
   ✓ Description: N/A

   Auto-linked by system on Oct 16, 2024 10:30 AM
   ```
6. User reviews and confirms (or can reject if incorrect)
7. Match status updates to "confirmed"

**Scenario 2: User reviews suggested match (manual approval)**

User: "System suggested a match but I need to verify it's correct"

System:
1. User clicks "Suggested Matches" tab (5 items)
2. Sees match candidate:
   ```
   Credit Card Charge: -$142.50 • Oct 20, 2024 • "AMZN MKTP US"
   ⬇️ SUGGESTED MATCH (82% confidence)
   Bank Transaction: -$142.50 • Oct 22, 2024 • "Amazon.com"

   Match Details:
   ✓ Amount: 100% match ($142.50 = $142.50)
   ⚠️ Date: 2 days difference (payment processed 2 days after charge)
   ✓ Counterparty: 75% similarity ("AMZN MKTP US" ≈ "Amazon.com")

   [Accept Match] [Reject] [View Details]
   ```
3. User clicks "Accept Match"
4. System:
   - Creates reconciliation_result record
   - Links credit card charge → bank transaction
   - Moves to "Matched" list
   - Logs decision: `method: manual_accept, confidence: 0.82, user: user_123`
5. Match appears in "Matched" tab with badge "✅ User Confirmed (82%)"

**Scenario 3: User manually matches when auto-detection fails**

User: "System didn't find a match, but I know invoice INV-2024-042 was paid by check #5678"

System:
1. User views "Unmatched Invoices" (8 items)
2. Clicks invoice: INV-2024-042 ($2,450.00, Oct 10, 2024, "XYZ Consulting")
3. Clicks "Manually Link" button
4. ManualMatchDialog opens:
   ```
   ┌──────────────────────────────────────────────┐
   │ Manually Link Invoice to Payment         [×] │
   ├──────────────────────────────────────────────┤
   │ Invoice: INV-2024-042                        │
   │ Amount: $2,450.00                            │
   │ Date: Oct 10, 2024                           │
   │ Vendor: XYZ Consulting                       │
   │                                              │
   │ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
   │                                              │
   │ Select payment to link:                      │
   │ [Search payments..._______________] 🔍       │
   │                                              │
   │ ○ Bank Check #5678 • -$2,450.00 • Oct 12    │
   │ ○ Bank Wire Transfer • -$2,500.00 • Oct 11  │
   │ ○ Credit Card • -$2,450.00 • Sep 28         │
   │                                              │
   │ Notes (optional):                            │
   │ [Payment made by check, confirmed with...] │
   │                                              │
   │ [Create Match] [Cancel]                      │
   └──────────────────────────────────────────────┘
   ```
5. User selects "Bank Check #5678" and clicks "Create Match"
6. System:
   - Calculates similarity (amount: 100%, date: 2 days, counterparty: 0%)
   - Confidence: 0.65 (below auto-link threshold but user forced)
   - Creates match with `method: manual_create, confidence: 0.65, user: user_123`
7. Match appears with badge "✅ Manually Linked (65%)"

**Scenario 4: User reconciles one invoice with multiple payments (one-to-many)**

User: "Invoice INV-2024-100 ($10,000) was paid in 3 installments"

System:
1. User views invoice INV-2024-100 in "Unmatched Invoices"
2. Clicks "Manually Link" → selects "Link to Multiple Payments"
3. ManualMatchDialog (multi-select mode):
   ```
   ┌──────────────────────────────────────────────┐
   │ Link Invoice to Multiple Payments        [×] │
   ├──────────────────────────────────────────────┤
   │ Invoice: INV-2024-100                        │
   │ Total Amount: $10,000.00                     │
   │ Remaining: $10,000.00                        │
   │                                              │
   │ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
   │                                              │
   │ Selected Payments:                           │
   │ ☑ Payment #1 • -$5,000.00 • Oct 15          │
   │ ☑ Payment #2 • -$3,000.00 • Nov 1           │
   │ ☑ Payment #3 • -$2,000.00 • Nov 15          │
   │                                              │
   │ Total Selected: $10,000.00 ✓                 │
   │ Remaining: $0.00                             │
   │                                              │
   │ [Create Match] [Cancel]                      │
   └──────────────────────────────────────────────┘
   ```
4. User confirms, system creates one-to-many match:
   - 1 reconciliation_result record
   - invoice_id: INV-2024-100
   - payment_ids: [pay_1, pay_2, pay_3]
   - cardinality: "one_to_many"
   - confidence: 0.95 (amounts sum exactly)
5. All 3 payments and invoice marked as "Matched"

**Scenario 5: System handles amount mismatch (fees/FX)**

User: "Why didn't the $1,500 payment match the $1,485 invoice?"

System:
1. ReconciliationEngine runs fuzzy matching
2. Finds candidate:
   - Bank Payment: -$1,500.00
   - Invoice: $1,485.00
   - Amount difference: $15 (1%)
3. Applies amount tolerance (default: ±5%)
4. 1% < 5% → amount feature scores 95% (penalty for variance)
5. Overall confidence: 0.88 (auto-suggest threshold)
6. Shows as suggested match with warning:
   ```
   ⚠️ Amount Mismatch: $15 difference (1%)
   Possible reasons:
   - Transaction fee
   - Currency conversion rounding
   - Partial payment

   [Accept Match] [Reject] [Split Transaction]
   ```
7. User accepts, system logs `amount_variance: 15.00, amount_variance_pct: 0.01`

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `ReconciliationEngine` - Core orchestrator: loads sources, finds candidates, scores matches (NEW - this vertical)
- `MatchScorer` - Calculates similarity scores with weighted features (NEW - this vertical)
- `ThresholdManager` - Manages confidence thresholds and decision rules (NEW - this vertical)
- `ReconciliationStore` - CRUD for reconciliation results, audit trail (NEW - this vertical)
- `FuzzyMatcher` - String similarity algorithms (Levenshtein, Jaro-Winkler) (from 3.8)
- `TransactionStore` - Load bank transactions for reconciliation (from 1.3)
- `CounterpartyStore` - Reference merchant names for matching (from 3.2)

**Interaction Layer (IL):**
- `ReconciliationDashboard` - Main UI: shows unmatched items, suggested matches, matched items (NEW - this vertical)
- `MatchReviewDialog` - Review and accept/reject match suggestions (NEW - this vertical)
- `ManualMatchDialog` - Manually create matches when auto-detection fails (NEW - this vertical)
- `TransactionList` - View transactions with reconciliation status badges (from 2.1)

**Schemas:**
- `reconciliation-result.schema.json` - Reconciliation result with matched pairs (NEW - this vertical)
- `match-candidate.schema.json` - Match candidate with similarity scores (NEW - this vertical)
- `reconciliation-config.schema.json` - Configuration for thresholds, weights (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# Get Unmatched Items for Source Pair
GET /api/reconciliation/unmatched?source_a=bank_chase&source_b=invoices_qb&status=unmatched
Authorization: Bearer {token}

Response 200:
{
  "source_a_unmatched": [
    {
      "item_id": "txn_12345",
      "type": "bank_transaction",
      "amount": -5000.00,
      "currency": "USD",
      "date": "2024-10-15",
      "counterparty": "Acme Corp",
      "description": "ACH Payment",
      "reconciliation_status": "unmatched"
    }
  ],
  "source_b_unmatched": [
    {
      "item_id": "inv_2024_001",
      "type": "invoice",
      "amount": 5000.00,
      "currency": "USD",
      "date": "2024-10-14",
      "counterparty": "Acme Corporation",
      "description": "Consulting Services - Q3 2024",
      "reconciliation_status": "unmatched"
    }
  ],
  "source_a_count": 15,
  "source_b_count": 8
}
```

```http
# Find Match Candidates
POST /api/reconciliation/find-candidates
Authorization: Bearer {token}
Content-Type: application/json

{
  "source_a_id": "bank_chase",
  "source_b_id": "invoices_qb",
  "item_id": "txn_12345",
  "config": {
    "amount_tolerance_pct": 0.05,
    "date_tolerance_days": 7,
    "min_confidence": 0.50
  }
}

Response 200:
{
  "item": {
    "item_id": "txn_12345",
    "amount": -5000.00,
    "date": "2024-10-15"
  },
  "candidates": [
    {
      "item_id": "inv_2024_001",
      "amount": 5000.00,
      "date": "2024-10-14",
      "confidence": 0.98,
      "decision": "auto_link",
      "scores": {
        "amount": 1.0,
        "date": 0.95,
        "counterparty": 0.95,
        "description": 0.0
      },
      "weights": {
        "amount": 0.4,
        "date": 0.3,
        "counterparty": 0.2,
        "description": 0.1
      },
      "features": {
        "amount_diff": 0.00,
        "amount_diff_pct": 0.00,
        "date_diff_days": 1,
        "counterparty_similarity": 0.95,
        "description_similarity": 0.0
      }
    }
  ]
}
```

```http
# Create Manual Match
POST /api/reconciliation/matches
Authorization: Bearer {token}
Content-Type: application/json

{
  "source_a_id": "bank_chase",
  "source_b_id": "invoices_qb",
  "source_a_items": ["txn_12345"],
  "source_b_items": ["inv_2024_001"],
  "method": "manual_create",
  "notes": "Confirmed with accounting team"
}

Response 201:
{
  "match_id": "match_abc123",
  "source_a_items": ["txn_12345"],
  "source_b_items": ["inv_2024_001"],
  "cardinality": "one_to_one",
  "confidence": 0.65,
  "decision": "manual",
  "method": "manual_create",
  "matched_by": "user_123",
  "matched_at": "2024-10-16T10:30:00Z",
  "notes": "Confirmed with accounting team"
}
```

```http
# Accept Suggested Match
POST /api/reconciliation/matches/{match_id}/accept
Authorization: Bearer {token}

Response 200:
{
  "match_id": "match_abc123",
  "status": "matched",
  "decision": "manual_accept",
  "matched_by": "user_123",
  "matched_at": "2024-10-16T10:35:00Z"
}
```

```http
# Reject Suggested Match
POST /api/reconciliation/matches/{match_id}/reject
Authorization: Bearer {token}
Content-Type: application/json

{
  "reason": "wrong_vendor"
}

Response 200:
{
  "match_id": "match_abc123",
  "status": "rejected",
  "rejected_by": "user_123",
  "rejected_at": "2024-10-16T10:40:00Z",
  "rejection_reason": "wrong_vendor"
}
```

```http
# Bulk Reconciliation
POST /api/reconciliation/bulk-reconcile
Authorization: Bearer {token}
Content-Type: application/json

{
  "source_a_id": "bank_chase",
  "source_b_id": "invoices_qb",
  "config": {
    "amount_tolerance_pct": 0.05,
    "date_tolerance_days": 7,
    "auto_link_threshold": 0.95,
    "auto_suggest_threshold": 0.70
  },
  "auto_accept": false  // If true, automatically accept auto-link matches
}

Response 202:
{
  "job_id": "job_bulk_recon_456",
  "status": "processing",
  "estimated_time_seconds": 120,
  "items_to_process": 1000
}

# Poll for results
GET /api/reconciliation/jobs/{job_id}

Response 200:
{
  "job_id": "job_bulk_recon_456",
  "status": "completed",
  "results": {
    "auto_linked": 450,
    "auto_suggested": 200,
    "manual_review": 100,
    "no_match": 250
  },
  "completed_at": "2024-10-16T10:50:00Z"
}
```

**Internal OL API:**

```python
class ReconciliationEngine:
    def find_candidates(
        self,
        source_a_id: str,
        source_b_id: str,
        item_id: str,
        config: ReconciliationConfig
    ) -> List[MatchCandidate]:
        """
        Finds match candidates for a single item from source_a in source_b.

        Algorithm:
        1. Blocking: Pre-filter source_b items by date range (±30 days) and amount range (±20%)
        2. For each candidate, calculate similarity scores (amount, date, counterparty, description)
        3. Compute weighted confidence score
        4. Filter by min_confidence threshold
        5. Sort by confidence descending
        6. Return top N candidates (default: 10)

        Performance: <2s for 10K × 10K items (with blocking)

        Raises:
            SourceNotFoundError: If source_a or source_b doesn't exist
            ItemNotFoundError: If item_id not in source_a
        """

    def bulk_reconcile(
        self,
        source_a_id: str,
        source_b_id: str,
        config: ReconciliationConfig
    ) -> BulkReconciliationResult:
        """
        Reconciles all unmatched items from source_a with source_b.

        For each unmatched item in source_a:
        1. Find candidates in source_b
        2. Get best candidate (highest confidence)
        3. If confidence >= auto_link_threshold: auto-link
        4. Elif confidence >= auto_suggest_threshold: suggest for review
        5. Elif confidence >= manual_threshold: flag for manual review
        6. Else: no match

        Returns summary: {auto_linked, auto_suggested, manual_review, no_match}
        """

class MatchScorer:
    def calculate_confidence(
        self,
        item_a: ReconciliationItem,
        item_b: ReconciliationItem,
        config: ReconciliationConfig
    ) -> MatchScore:
        """
        Calculates weighted confidence score for match candidate.

        Feature Scores (each 0.0-1.0):
        - amount_score: 1.0 if exact match, penalty for % difference (within tolerance)
        - date_score: 1.0 if same day, decay based on days difference (within tolerance)
        - counterparty_score: String similarity (Jaro-Winkler) on counterparty names
        - description_score: String similarity on descriptions (optional)

        Weighted Confidence (default weights):
        confidence = (0.4 * amount) + (0.3 * date) + (0.2 * counterparty) + (0.1 * description)

        Returns:
            MatchScore with confidence, feature_scores, weights, decision
        """

class ThresholdManager:
    def get_decision(self, confidence: float) -> MatchDecision:
        """
        Maps confidence score to decision.

        Thresholds (configurable):
        - confidence >= 0.95: auto_link (high confidence, auto-match)
        - 0.70 <= confidence < 0.95: auto_suggest (medium confidence, user review)
        - 0.50 <= confidence < 0.70: manual_review (low confidence, manual match)
        - confidence < 0.50: no_match (too low, don't suggest)
        """

    def update_thresholds(
        self,
        auto_link: Optional[float],
        auto_suggest: Optional[float],
        manual: Optional[float]
    ):
        """Updates system-wide thresholds (admin operation)."""

class ReconciliationStore:
    def create(
        self,
        source_a_id: str,
        source_b_id: str,
        source_a_items: List[str],
        source_b_items: List[str],
        confidence: float,
        decision: MatchDecision,
        method: MatchMethod,
        matched_by: str,
        notes: Optional[str] = None
    ) -> ReconciliationResult:
        """
        Creates reconciliation result (match).

        Cardinality auto-detected:
        - len(source_a_items) == 1 and len(source_b_items) == 1: one_to_one
        - len(source_a_items) == 1 and len(source_b_items) > 1: one_to_many
        - len(source_a_items) > 1 and len(source_b_items) == 1: many_to_one
        - len(source_a_items) > 1 and len(source_b_items) > 1: many_to_many

        Raises:
            ItemAlreadyMatchedError: If any item already in another match
        """

    def reject(self, match_id: str, user_id: str, reason: str):
        """Marks match as rejected, items become unmatched again."""

    def get_audit_trail(self, match_id: str) -> List[AuditEntry]:
        """Returns full history of match: created, accepted, rejected, etc."""
```

---

### 5. Schemas / Tipos (Persistencia)

**ReconciliationResult Schema:**

```json
{
  "match_id": "match_abc123",
  "source_a_id": "bank_chase",
  "source_b_id": "invoices_qb",
  "source_a_items": ["txn_12345"],
  "source_b_items": ["inv_2024_001"],
  "cardinality": "one_to_one",
  "confidence": 0.98,
  "decision": "auto_link",
  "method": "auto_matched",
  "matched_by": "system",
  "matched_at": "2024-10-16T10:00:00Z",
  "status": "matched",
  "notes": null,
  "feature_scores": {
    "amount": 1.0,
    "date": 0.95,
    "counterparty": 0.95,
    "description": 0.0
  },
  "feature_details": {
    "amount_diff": 0.00,
    "amount_diff_pct": 0.00,
    "date_diff_days": 1,
    "counterparty_similarity": 0.95
  }
}
```

**MatchCandidate Schema:**

```json
{
  "candidate_id": "cand_xyz789",
  "item_id": "inv_2024_001",
  "type": "invoice",
  "amount": 5000.00,
  "currency": "USD",
  "date": "2024-10-14",
  "counterparty": "Acme Corporation",
  "confidence": 0.98,
  "decision": "auto_link",
  "scores": {
    "amount": 1.0,
    "date": 0.95,
    "counterparty": 0.95,
    "description": 0.0
  },
  "weights": {
    "amount": 0.4,
    "date": 0.3,
    "counterparty": 0.2,
    "description": 0.1
  },
  "features": {
    "amount_diff": 0.00,
    "amount_diff_pct": 0.00,
    "date_diff_days": 1,
    "counterparty_similarity": 0.95,
    "description_similarity": 0.0
  }
}
```

**ReconciliationConfig Schema:**

```json
{
  "config_id": "config_default",
  "source_a_id": "bank_chase",
  "source_b_id": "invoices_qb",
  "amount_tolerance_pct": 0.05,
  "date_tolerance_days": 7,
  "weights": {
    "amount": 0.4,
    "date": 0.3,
    "counterparty": 0.2,
    "description": 0.1
  },
  "thresholds": {
    "auto_link": 0.95,
    "auto_suggest": 0.70,
    "manual": 0.50
  },
  "blocking_enabled": true,
  "blocking_date_range_days": 30,
  "blocking_amount_range_pct": 0.20,
  "created_at": "2024-10-01T00:00:00Z"
}
```

**Cardinality Types:**
- `one_to_one` - Single item from source_a matches single item from source_b
- `one_to_many` - Single item from source_a matches multiple items from source_b (e.g., 1 invoice → 3 payments)
- `many_to_one` - Multiple items from source_a match single item from source_b (e.g., 2 invoices → 1 payment)
- `many_to_many` - Multiple items from both sources (rare, usually avoided)

**Match Decisions:**
- `auto_link` - Confidence ≥ 0.95, automatically matched by system
- `auto_suggest` - Confidence 0.70-0.94, suggested for user review
- `manual_review` - Confidence 0.50-0.69, flagged for manual matching
- `no_match` - Confidence < 0.50, no viable candidate

**Match Methods:**
- `auto_matched` - System automatically created match (high confidence)
- `manual_accept` - User accepted suggested match
- `manual_create` - User manually created match (system didn't suggest)
- `manual_reject` - User rejected suggested match

---

### 6. Validaciones & Estados

**Create Match Validations:**
- source_a_id and source_b_id: Must exist in system
- source_a_items and source_b_items: Non-empty arrays, all items must exist
- Items cannot already be in another match (check reconciliation_status)
- If one_to_many: sum of source_b amounts must match source_a amount (within tolerance)
- If many_to_one: sum of source_a amounts must match source_b amount (within tolerance)
- Confidence: [0.0, 1.0]
- Notes: Max 1000 chars

**Match Candidate Validations:**
- Amount difference: Within tolerance (default: ±5%)
- Date difference: Within tolerance (default: ±7 days)
- Confidence: Must be ≥ min_confidence (default: 0.50)
- Weights: Must sum to 1.0

**Reconciliation Config Validations:**
- amount_tolerance_pct: [0.0, 1.0] (0% to 100%)
- date_tolerance_days: [0, 365]
- Weights: Each [0.0, 1.0], sum must equal 1.0
- Thresholds: 0.0 ≤ manual < auto_suggest < auto_link ≤ 1.0
- blocking_date_range_days: [1, 365]
- blocking_amount_range_pct: [0.0, 1.0]

**State Machine (Match Status):**
```
┌─────────────┐
│  suggested  │──user accepts──▶│ matched │
└─────────────┘                 └─────────┘
      │
      │ user rejects
      ▼
│  rejected   │──can re-match──▶│ suggested │
└─────────────┘                 └───────────┘

┌─────────────┐
│ auto_linked │──always──▶│ matched │
└─────────────┘           └─────────┘
      │
      │ user can reject
      ▼
│  rejected   │
└─────────────┘

┌─────────────┐
│   manual    │──created──▶│ matched │
└─────────────┘            └─────────┘
```

**Reconciliation Status (per item):**
- `unmatched` - Item not yet reconciled
- `matched` - Item successfully matched
- `rejected` - Match was rejected, item available for re-matching
- `excluded` - User manually excluded from reconciliation

---

### 7. Edge Cases

**EC1: Same transaction in both sources (exact duplicate)**
- Problem: Bank feed shows same transaction twice (original + duplicate)
- **Solution:** Deduplicate within source before reconciliation (use 1.3 Normalization deduplication)
- If duplicate slips through: Manual reject match, mark as duplicate

**EC2: One invoice split into multiple payments**
- Problem: Invoice $10K paid as $5K + $3K + $2K
- **Solution:** One-to-many match (1 invoice → 3 payments)
- Validation: Sum of payments must equal invoice amount (within tolerance)
- UI: Multi-select dialog for manual linking

**EC3: Multiple invoices paid in one transaction**
- Problem: Single bank payment $1,500 for 2 invoices ($800 + $700)
- **Solution:** Many-to-one match (2 invoices → 1 payment)
- Validation: Sum of invoices must equal payment amount (within tolerance)

**EC4: Date mismatch beyond tolerance**
- Problem: Invoice dated Oct 1, payment made Nov 15 (45 days later)
- **Solution:**
  - System won't suggest (beyond ±7 days default tolerance)
  - User can manually create match (notes: "Late payment")
  - Confidence score will be low due to date penalty

**EC5: Amount mismatch due to fees/FX**
- Problem: Invoice $1,000, payment $975 (2.5% processing fee deducted)
- **Solution:**
  - If variance within tolerance (5%): Accept with warning
  - Record amount_diff and amount_diff_pct in match
  - User can split transaction: $975 payment + $25 fee (link only payment portion)

**EC6: Counterparty name variations**
- Problem: Bank shows "AMZN MKTP US", invoice shows "Amazon Marketplace Inc"
- **Solution:** FuzzyMatcher handles variations
  - String similarity score (Jaro-Winkler, Levenshtein)
  - Learn from user confirmations (if user confirms match, boost future similarity)
  - Allow user to add counterparty alias (3.2 Counterparty Registry)

**EC7: Item already matched but user wants to re-match**
- Problem: User realizes match was wrong, needs to un-match and re-match
- **Solution:**
  - User clicks "Reject Match" on existing match
  - Items return to "unmatched" status
  - User can manually create new match
  - Audit trail logs: rejected → re-matched

**EC8: Circular matches (A→B, B→C, C→A)**
- Problem: Invalid cycle in match graph
- **Solution:** Validate acyclic graph on match creation
  - Each item can only be in ONE match at a time
  - Reject match if creates cycle

**EC9: Performance with large datasets (10K × 10K)**
- Problem: Brute force matching is O(n²), too slow
- **Solution:** Blocking strategy
  - Pre-filter candidates by date range (±30 days) and amount range (±20%)
  - Only compare items within blocks
  - Target: <2s for 10K × 10K with blocking

---

### 8. Acceptance Criteria (Definition of Done)

**Match Finding:**
- [ ] System finds match candidates for item with configurable tolerances (amount, date)
- [ ] System calculates confidence scores with weighted features
- [ ] System auto-links matches with confidence ≥ 0.95
- [ ] System suggests matches with confidence 0.70-0.94
- [ ] System flags matches with confidence 0.50-0.69 for manual review
- [ ] System ignores candidates with confidence < 0.50

**Manual Matching:**
- [ ] User can manually create match when auto-detection fails
- [ ] User can accept suggested match
- [ ] User can reject suggested match with reason
- [ ] User can create one-to-many match (1 invoice → multiple payments)
- [ ] User can create many-to-one match (multiple invoices → 1 payment)
- [ ] System validates amount sums for multi-item matches

**Dashboard & UI:**
- [ ] User can view unmatched items from both sources
- [ ] User can view auto-linked matches (high confidence)
- [ ] User can view suggested matches (medium confidence)
- [ ] User can view matched items with confidence scores
- [ ] User can filter by source pair, date range, amount range
- [ ] User can export reconciliation results (CSV, Excel)

**Bulk Operations:**
- [ ] System can bulk-reconcile 1000s of items (background job)
- [ ] System shows progress for bulk operations
- [ ] System returns summary: auto_linked, auto_suggested, manual_review, no_match

**Audit Trail:**
- [ ] System logs all match decisions (who, when, method, confidence)
- [ ] User can view match history for item (created, accepted, rejected)
- [ ] System preserves rejected matches (soft delete, audit trail)

**Performance:**
- [ ] Match candidate search: <2s for 10K × 10K items (with blocking)
- [ ] Bulk reconciliation: <5 minutes for 10K items
- [ ] Dashboard load: <1s for up to 1000 unmatched items

**Multi-Domain:**
- [ ] Pattern applies to Healthcare (insurance claim vs payment reconciliation)
- [ ] Pattern applies to Legal (court filing reconciliation across systems)
- [ ] Pattern applies to Research (citation matching across databases)
- [ ] Pattern applies to E-commerce (order-shipment-payment reconciliation)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "match_auto_linked",
  "match_id": "match_abc123",
  "source_a_id": "bank_chase",
  "source_b_id": "invoices_qb",
  "source_a_items": ["txn_12345"],
  "source_b_items": ["inv_2024_001"],
  "confidence": 0.98,
  "decision": "auto_link",
  "method": "auto_matched",
  "feature_scores": {
    "amount": 1.0,
    "date": 0.95,
    "counterparty": 0.95
  },
  "timestamp": "2024-10-16T10:00:00Z"
}
```

```json
{
  "event": "match_suggested",
  "match_id": "match_xyz456",
  "confidence": 0.82,
  "decision": "auto_suggest",
  "reason": "amount match, date within tolerance, counterparty similar",
  "timestamp": "2024-10-16T10:05:00Z"
}
```

```json
{
  "event": "match_accepted",
  "match_id": "match_xyz456",
  "user_id": "user_123",
  "method": "manual_accept",
  "timestamp": "2024-10-16T10:10:00Z"
}
```

```json
{
  "event": "match_rejected",
  "match_id": "match_def789",
  "user_id": "user_123",
  "rejection_reason": "wrong_vendor",
  "timestamp": "2024-10-16T10:15:00Z"
}
```

```json
{
  "event": "match_created_manual",
  "match_id": "match_ghi012",
  "user_id": "user_123",
  "cardinality": "one_to_many",
  "source_a_items": ["inv_100"],
  "source_b_items": ["pay_1", "pay_2", "pay_3"],
  "confidence": 0.95,
  "notes": "Installment payment plan",
  "timestamp": "2024-10-16T10:20:00Z"
}
```

**Provenance Chain:**
```
Sources Loaded (Bank + Invoices)
  ↓
ReconciliationEngine.find_candidates() (3.9)
  ↓
MatchScorer.calculate_confidence() (3.9)
  ↓
ThresholdManager.get_decision() (3.9)
  ↓
If auto_link: ReconciliationStore.create() (auto_matched)
If auto_suggest: Show in UI for user review
  ↓
User accepts/rejects
  ↓
ReconciliationStore.create() or reject()
  ↓
Audit Trail Updated (ProvenanceLedger)
```

---

### 10. Risks & Deferred

**Risks:**
- **R1: False positive matches** - System auto-links incorrect matches
  - **Mitigation:** Conservative thresholds (0.95 for auto-link), user can reject and system learns
- **R2: Performance degradation** - O(n²) matching becomes slow for large datasets
  - **Mitigation:** Blocking strategies (date + amount pre-filtering), target <2s for 10K × 10K
- **R3: Counterparty name variations** - "AMZN MKTP US" vs "Amazon" may not match
  - **Mitigation:** FuzzyMatcher with Jaro-Winkler similarity, user can confirm and train system
- **R4: Multi-currency complexity** - USD payment vs EUR invoice requires FX conversion
  - **Mitigation:** Require FX conversion before reconciliation (3.6 Unit), match on normalized amounts

**Deferred:**
- **D1: Machine learning models** - Initial version uses rule-based matching, ML training in v2
- **D2: Real-time reconciliation** - Batch processing only in v1, real-time streaming in v2
- **D3: Cross-source learning** - Learn patterns from one source pair, apply to others (v2)
- **D4: Automatic threshold tuning** - Adapt thresholds based on user acceptance rate (v2)
- **D5: Multi-hop matching** - Match A→B→C transitively (e.g., order→shipment→payment) (v3)

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 4 new primitives:**

1. **ReconciliationEngine** - Core reconciliation orchestrator
   - File: `docs/primitives/ol/ReconciliationEngine.md`
   - Methods: find_candidates, bulk_reconcile, reconcile_pair, get_unmatched
   - Responsibilities: Load sources, apply blocking, coordinate matching, batch processing

2. **MatchScorer** - Calculate similarity scores with weighted features
   - File: `docs/primitives/ol/MatchScorer.md`
   - Methods: calculate_confidence, score_amount, score_date, score_counterparty, score_description
   - Responsibilities: Feature scoring, weighted aggregation, confidence calculation

3. **ThresholdManager** - Manage auto-suggest vs auto-link thresholds
   - File: `docs/primitives/ol/ThresholdManager.md`
   - Methods: get_decision, update_thresholds, get_config, validate_thresholds
   - Responsibilities: Threshold-based decision rules, config management

4. **ReconciliationStore** - CRUD for reconciliation results
   - File: `docs/primitives/ol/ReconciliationStore.md`
   - Methods: create, get, reject, get_by_item, get_audit_trail, get_stats
   - Responsibilities: Match persistence, audit trail, uniqueness enforcement

**Interaction Layer (IL) - 3 new components:**

5. **ReconciliationDashboard** - Main reconciliation UI
   - File: `docs/primitives/il/ReconciliationDashboard.md`
   - Features: Unmatched items list, suggested matches, matched items, filters, export
   - Responsibilities: Reconciliation overview, source pair selection, bulk actions

6. **MatchReviewDialog** - Review and accept/reject match suggestions
   - File: `docs/primitives/il/MatchReviewDialog.md`
   - Features: Side-by-side comparison, confidence breakdown, accept/reject actions
   - Responsibilities: Match review UI, decision capture

7. **ManualMatchDialog** - Manually create matches
   - File: `docs/primitives/il/ManualMatchDialog.md`
   - Features: Item search, multi-select for one-to-many, amount validation, notes
   - Responsibilities: Manual match creation, cardinality handling

**Schemas - 3 new:**

8. **reconciliation-result.schema.json** - Reconciliation result with matched pairs
9. **match-candidate.schema.json** - Match candidate with similarity scores
10. **reconciliation-config.schema.json** - Configuration for thresholds, weights, tolerances

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **1.3 Normalization** - Transactions must be normalized before reconciliation (deduplication, standardization)
- **3.2 Counterparty Registry** - Merchant names used for counterparty matching
- **3.8 FuzzyMatcher** - String similarity algorithms (Levenshtein, Jaro-Winkler)
- **3.6 Unit** - FX conversion before reconciliation (if multi-currency)

**Used By:**
- **4.x Accounting** - Matched transactions flow to general ledger (future)
- **2.3 Finance Dashboard** - Show reconciliation status widget (matched vs unmatched)
- **Future: 4.x Financial Close** - Month-end reconciliation workflows

**Data Flow:**
```
Transactions Normalized (1.3)
  ↓
Counterparty Names Standardized (3.2)
  ↓
FX Conversion (3.6, if needed)
  ↓
ReconciliationEngine loads sources (3.9)
  ↓
MatchScorer calculates similarities (3.9)
  ↓
ThresholdManager decides action (3.9)
  ↓
Auto-link or suggest to user
  ↓
ReconciliationStore persists matches (3.9)
  ↓
Dashboard shows reconciliation status (2.3)
```

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Multi-Source Entity Matching with Fuzzy Logic**

This pattern applies to **any domain requiring reconciliation of entities across heterogeneous sources**:

**Finance:**
- Source Pair: Bank transactions vs Invoices, Credit card vs Bank account
- Match Features: Amount, date, vendor name, description
- Cardinality: One-to-one (invoice-payment), one-to-many (invoice-installments)
- Use Case: Month-end reconciliation, expense tracking

**Healthcare:**
- Source Pair: Insurance claims vs Payments (EOB), Patient invoices vs Patient payments
- Match Features: Claim amount, service date, patient name, procedure codes
- Cardinality: One-to-one (claim-payment), one-to-many (claim-partial payments)
- Use Case: Insurance reconciliation, patient payment tracking

**Legal:**
- Source Pair: PACER filings vs State court systems, Case numbers across jurisdictions
- Match Features: Case number, filing date, party names, document type
- Cardinality: One-to-one (same case different systems)
- Use Case: Multi-jurisdiction case tracking

**Research:**
- Source Pair: DOI database vs arXiv vs PubMed vs Google Scholar
- Match Features: Title similarity, author names, publication date, abstract similarity
- Cardinality: One-to-one (same paper, multiple IDs)
- Use Case: Citation deduplication, research impact tracking

**E-commerce:**
- Source Pair: Orders vs Shipments vs Payments
- Match Features: Order number, amount, customer name, date
- Cardinality: One-to-one (order-shipment), one-to-many (order-multiple shipments)
- Use Case: Order fulfillment tracking, revenue recognition

**Logistics:**
- Source Pair: Shipments vs Customs declarations vs Delivery confirmations
- Match Features: Tracking number, consignee name, shipment date, origin/destination
- Cardinality: One-to-one (shipment-declaration), many-to-one (shipments-container)
- Use Case: International shipping reconciliation, customs compliance

**Key Abstraction:**
```python
class MultiSourceMatcher:
    """
    Universal pattern for entity matching across heterogeneous sources.

    Generic enough to apply across:
    - Finance: Transaction reconciliation
    - Healthcare: Claim-payment matching
    - Legal: Case filing reconciliation
    - Research: Citation deduplication
    - E-commerce: Order-shipment-payment matching
    - Logistics: Shipment-customs-delivery matching
    """
    source_a: DataSource  # First source (e.g., bank transactions)
    source_b: DataSource  # Second source (e.g., invoices)
    features: List[MatchFeature]  # Features to compare (amount, date, name, etc.)
    weights: Dict[str, float]  # Feature weights (sum to 1.0)
    thresholds: MatchThresholds  # Decision thresholds (auto-link, suggest, manual)
    blocking_strategy: Optional[BlockingStrategy]  # Performance optimization

    def find_candidates(self, item: Entity, config: MatchConfig) -> List[MatchCandidate]:
        """Find potential matches for item in other source."""

    def calculate_confidence(self, item_a: Entity, item_b: Entity) -> float:
        """Calculate weighted similarity score."""

    def reconcile(self, auto_accept: bool = False) -> ReconciliationResult:
        """Reconcile all items from source_a with source_b."""
```

---

### 14. Pattern Abstraction

**Pattern Name:** Multi-Source Entity Matching with Fuzzy Logic + Confidence Scoring

**Problem Statement:**
Users need to match entities (transactions, claims, cases, citations, orders) across multiple heterogeneous data sources that have varying formats, naming conventions, and completeness. Exact matching is insufficient due to data quality issues, timing differences, and format variations. Manual matching is tedious and error-prone at scale.

**Solution Architecture:**

1. **Fuzzy Matching** - Tolerate variance in key fields (amount ±5%, date ±7 days, name similarity)
2. **Multi-Feature Scoring** - Combine multiple signals (amount, date, counterparty, description) with weights
3. **Confidence Thresholds** - Automate decisions based on confidence levels (auto-link ≥95%, suggest 70-94%, manual 50-69%)
4. **Blocking Strategy** - Pre-filter candidates for performance (date range, amount range)
5. **Cardinality Support** - Handle one-to-one, one-to-many, many-to-one matches
6. **Audit Trail** - Log all decisions for explainability and learning

**Components:**
- **ReconciliationEngine** - Orchestrates matching process, applies blocking
- **MatchScorer** - Calculates feature-level scores and weighted confidence
- **ThresholdManager** - Maps confidence to decisions (auto-link, suggest, manual)
- **ReconciliationStore** - Persists matches with audit trail
- **FuzzyMatcher** - String similarity algorithms (Levenshtein, Jaro-Winkler)

**When to Use:**
- ✅ Need to reconcile entities across multiple data sources
- ✅ Exact matching is insufficient (data quality issues)
- ✅ Multiple signals available (amount, date, name, description)
- ✅ Scale requires automation (100s-1000s of items)
- ✅ Explainability required (show why items matched)
- ❌ Exact key-based matching is possible (use JOIN instead)
- ❌ Single source (no reconciliation needed)
- ❌ No tolerance for variance (100% accuracy required)

**Generic Implementation:**
```python
from typing import Generic, TypeVar, List, Dict
from dataclasses import dataclass

T = TypeVar('T')  # Entity type (Transaction, Claim, Case, Citation, Order)

@dataclass
class MatchFeature:
    name: str
    weight: float
    scorer: callable  # Function to calculate similarity [0.0, 1.0]
    tolerance: Optional[float]  # Acceptable variance (e.g., ±5% for amount)

@dataclass
class MatchConfig:
    features: List[MatchFeature]
    thresholds: Dict[str, float]  # {auto_link: 0.95, suggest: 0.70, manual: 0.50}
    blocking: Optional[Dict[str, any]]  # Pre-filtering rules

class GenericReconciliationEngine(Generic[T]):
    """
    Generic reconciliation engine for any entity type.

    Type parameter T represents the entity being matched:
    - Finance: T = Transaction
    - Healthcare: T = Claim or Payment
    - Legal: T = CourtFiling
    - Research: T = Citation
    - E-commerce: T = Order, Shipment, or Payment
    """

    def find_candidates(
        self,
        item: T,
        candidates: List[T],
        config: MatchConfig
    ) -> List[Tuple[T, float]]:
        """
        Find potential matches for item in candidate list.

        1. Apply blocking if configured (pre-filter)
        2. For each candidate, calculate similarity
        3. Filter by min threshold
        4. Sort by confidence descending
        """
        if config.blocking:
            candidates = self._apply_blocking(item, candidates, config.blocking)

        scored_candidates = []
        for candidate in candidates:
            confidence = self._calculate_confidence(item, candidate, config)
            if confidence >= config.thresholds['manual']:
                scored_candidates.append((candidate, confidence))

        return sorted(scored_candidates, key=lambda x: x[1], reverse=True)

    def _calculate_confidence(
        self,
        item_a: T,
        item_b: T,
        config: MatchConfig
    ) -> float:
        """
        Calculate weighted confidence score.

        For each feature:
        1. Extract values from both items
        2. Calculate similarity [0.0, 1.0]
        3. Apply tolerance penalty if applicable
        4. Multiply by weight
        5. Sum weighted scores
        """
        total_score = 0.0
        for feature in config.features:
            value_a = getattr(item_a, feature.name)
            value_b = getattr(item_b, feature.name)
            similarity = feature.scorer(value_a, value_b, feature.tolerance)
            total_score += similarity * feature.weight

        return total_score

    def reconcile(
        self,
        source_a: List[T],
        source_b: List[T],
        config: MatchConfig,
        auto_accept: bool = False
    ) -> Dict[str, List[Tuple[T, T, float]]]:
        """
        Reconcile all items from source_a with source_b.

        Returns:
            {
                'auto_linked': [...],     # confidence >= auto_link threshold
                'suggested': [...],       # confidence >= suggest threshold
                'manual_review': [...],   # confidence >= manual threshold
                'no_match': [...]         # confidence < manual threshold
            }
        """
        results = {
            'auto_linked': [],
            'suggested': [],
            'manual_review': [],
            'no_match': []
        }

        for item_a in source_a:
            candidates = self.find_candidates(item_a, source_b, config)

            if not candidates:
                results['no_match'].append(item_a)
                continue

            best_match, confidence = candidates[0]  # Highest confidence

            if confidence >= config.thresholds['auto_link']:
                results['auto_linked'].append((item_a, best_match, confidence))
                if auto_accept:
                    source_b.remove(best_match)  # Don't match again
            elif confidence >= config.thresholds['suggest']:
                results['suggested'].append((item_a, best_match, confidence))
            elif confidence >= config.thresholds['manual']:
                results['manual_review'].append((item_a, best_match, confidence))
            else:
                results['no_match'].append(item_a)

        return results
```

---

### 15. Métricas de Madurez

**Coverage Metrics:**
- % of items reconciled (target: >85%)
- % auto-linked (high confidence, target: >60%)
- % suggested matches (medium confidence, target: 20-30%)
- % manual review (low confidence, target: <10%)
- % no match (target: <5%)

**Quality Metrics:**
- Auto-link accuracy (user rejection rate, target: <5%)
- Suggestion acceptance rate (target: >70%)
- False positive rate (incorrect auto-links, target: <2%)
- False negative rate (missed matches, target: <10%)

**Performance Metrics:**
- Candidate search latency (target: <2s for 10K × 10K with blocking)
- Bulk reconciliation throughput (target: >200 items/second)
- Dashboard load time (target: <1s for 1000 unmatched items)

**User Engagement:**
- % users who use reconciliation feature (target: >80%)
- Avg matches reviewed per user per month (target: >50)
- % users who manually create matches (indicates auto-detection gaps, target: <20%)

**System Learning:**
- Match confidence distribution (should shift towards higher confidence over time)
- Threshold effectiveness (% items in each decision bucket)
- User override rate (how often users reject auto-links or create manual matches)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All operations require valid bearer token
- Users can only reconcile their own data sources
- Matches are user-scoped (user_id foreign key)
- System admin can configure global thresholds (role-based)

**Input Validation:**
- Source IDs: Pattern validation, existence check
- Item IDs: Validate existence in source before matching
- Confidence: Range [0.0, 1.0]
- Thresholds: Validate auto_link > auto_suggest > manual
- Weights: Validate sum = 1.0, each in [0.0, 1.0]
- Notes: Length limit (1000 chars), XSS prevention

**SQL Injection Prevention:**
- Use parameterized queries for all database operations
- Example: `SELECT * FROM reconciliation_results WHERE match_id = ? AND user_id = ?`

**Trust Construction Elements:**
- **Ownership verification:** All matches checked against user_id
- **Audit trail:** All decisions logged (who, when, method, confidence)
- **Idempotency:** Creating same match twice is idempotent (no duplicates)
- **Uniqueness enforcement:** Item can only be in ONE match at a time
- **Rate limiting:** Bulk reconcile: 5 per hour per user, manual match: 100 per hour

**Data Privacy:**
- Match notes may contain sensitive info (e.g., "Confirmed with vendor ABC")
- Do not log match notes in external systems
- Redact PII in error messages
- Encrypt match audit trail at rest

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `GET /api/reconciliation/unmatched` (list): <500ms (up to 1000 items)
- `POST /api/reconciliation/find-candidates` (search): <2s (10K × 10K with blocking)
- `POST /api/reconciliation/matches` (create): <200ms
- `POST /api/reconciliation/bulk-reconcile` (batch): <5 minutes for 10K items

**Scalability:**
- Items per source: 100K (typical), 1M (max)
- Matches per user: unlimited
- Concurrent reconciliation jobs: 10 per user
- Blocking reduces search space from O(n²) to O(n×m) where m << n

**Database Indexes:**
```sql
-- Reconciliation results
CREATE INDEX idx_recon_results_source_a ON reconciliation_results(source_a_id, user_id);
CREATE INDEX idx_recon_results_source_b ON reconciliation_results(source_b_id, user_id);
CREATE INDEX idx_recon_results_status ON reconciliation_results(status, user_id);
CREATE INDEX idx_recon_results_matched_at ON reconciliation_results(matched_at DESC);

-- Item lookups (composite for blocking)
CREATE INDEX idx_items_date_amount ON reconciliation_items(date, amount, source_id);
CREATE INDEX idx_items_reconciliation_status ON reconciliation_items(reconciliation_status, source_id);

-- Audit trail
CREATE INDEX idx_recon_audit_match_id ON reconciliation_audit(match_id, created_at DESC);
```

**Caching Strategy:**
- Cache unmatched item counts per source (TTL: 5 minutes, invalidate on match)
- Cache reconciliation config per source pair (TTL: 1 hour)
- Cache match statistics (auto-linked, suggested, etc.) (TTL: 10 minutes)
- No caching for match candidates (always fresh data)

**Background Jobs:**
- **Hourly:** Auto-reconcile new transactions (batch 1000 at a time)
- **Daily:** Generate reconciliation summary report (unmatched items by source)
- **Weekly:** Retrain ML models from user accept/reject decisions (future)

**Blocking Strategy:**
```python
def apply_blocking(item, candidates, config):
    """
    Pre-filter candidates to reduce search space.

    Example for finance (bank-invoice reconciliation):
    - Date range: ±30 days (default)
    - Amount range: ±20% (default)

    Reduces 10K × 10K (100M comparisons) to 10K × 500 (5M comparisons)
    Performance gain: 20x faster
    """
    date_min = item.date - timedelta(days=config.blocking_date_range_days)
    date_max = item.date + timedelta(days=config.blocking_date_range_days)

    amount_min = item.amount * (1 - config.blocking_amount_range_pct)
    amount_max = item.amount * (1 + config.blocking_amount_range_pct)

    return [
        c for c in candidates
        if date_min <= c.date <= date_max
        and amount_min <= c.amount <= amount_max
    ]
```

---

### 18. Observability

**Metrics:**
```
reconciliation.matches.created.count (counter, labels: source_pair, decision)
reconciliation.matches.accepted.count (counter, labels: source_pair)
reconciliation.matches.rejected.count (counter, labels: source_pair, reason)
reconciliation.candidates.found.count (histogram, labels: source_pair)
reconciliation.confidence.distribution (histogram, labels: source_pair, decision)
reconciliation.find_candidates.latency (histogram, labels: source_pair)
reconciliation.bulk_reconcile.latency (histogram, labels: source_pair)
reconciliation.items_unmatched.gauge (gauge, labels: source_id)
```

**Structured Logs:**
- All match decisions (auto-link, suggest, manual create, reject)
- All bulk reconciliation jobs (start, progress, completion, stats)
- All threshold changes (admin operations)
- Performance warnings (candidate search >5s, blocking ineffective)

**Dashboards:**
- Reconciliation coverage % by source pair (trend over time)
- Confidence score distribution (should shift higher over time)
- Auto-link accuracy (rejection rate, target <5%)
- Suggestion acceptance rate (target >70%)
- Top unmatched items (by amount, by age)
- Bulk job throughput (items/second)

**Alerts:**
- Auto-link rejection rate >10% (investigate false positives)
- Suggestion acceptance rate <50% (thresholds may be too low)
- Candidate search latency >5s (blocking strategy may need tuning)
- Bulk job failure rate >5% (investigate data quality issues)
- Unmatched items growing >20% week-over-week (investigate source issues)

**Tracing:**
- Trace reconciliation flow: load sources → blocking → scoring → decision
- Include item_ids, source_ids, confidence, decision in trace
- Annotate with performance metrics (blocking reduced candidates from X to Y)

---

### 19. Testing Strategy

**Unit Tests:**

```python
# MatchScorer tests
def test_score_amount_exact_match():
    score = scorer.score_amount(100.00, 100.00, tolerance_pct=0.05)
    assert score == 1.0

def test_score_amount_within_tolerance():
    score = scorer.score_amount(100.00, 102.00, tolerance_pct=0.05)
    # 2% difference, within 5% tolerance
    assert score == 0.96  # Penalty for variance

def test_score_amount_outside_tolerance():
    score = scorer.score_amount(100.00, 110.00, tolerance_pct=0.05)
    # 10% difference, outside 5% tolerance
    assert score == 0.0

def test_score_date_same_day():
    score = scorer.score_date(date(2024, 10, 15), date(2024, 10, 15), tolerance_days=7)
    assert score == 1.0

def test_score_date_within_tolerance():
    score = scorer.score_date(date(2024, 10, 15), date(2024, 10, 17), tolerance_days=7)
    # 2 days difference, within 7 days tolerance
    assert score >= 0.85  # Decay function

def test_score_counterparty_fuzzy_match():
    score = scorer.score_counterparty("Acme Corp", "Acme Corporation")
    assert score >= 0.90  # High similarity

# ReconciliationEngine tests
def test_find_candidates_with_blocking():
    item = BankTransaction(amount=100.00, date=date(2024, 10, 15))
    candidates = engine.find_candidates(item, invoices, config)
    # Should only return invoices within ±7 days and ±5% amount
    assert all(
        abs((c.date - item.date).days) <= 7
        and abs(c.amount - item.amount) / item.amount <= 0.05
        for c in candidates
    )

def test_bulk_reconcile_auto_link():
    result = engine.bulk_reconcile("bank", "invoices", config)
    # High confidence matches should be auto-linked
    assert len(result.auto_linked) > 0
    assert all(match.confidence >= 0.95 for match in result.auto_linked)

# ThresholdManager tests
def test_get_decision_auto_link():
    decision = manager.get_decision(0.98)
    assert decision == MatchDecision.AUTO_LINK

def test_get_decision_suggest():
    decision = manager.get_decision(0.82)
    assert decision == MatchDecision.AUTO_SUGGEST

def test_get_decision_manual():
    decision = manager.get_decision(0.65)
    assert decision == MatchDecision.MANUAL_REVIEW

def test_get_decision_no_match():
    decision = manager.get_decision(0.42)
    assert decision == MatchDecision.NO_MATCH

# ReconciliationStore tests
def test_create_match_one_to_one():
    match = store.create(
        source_a_id="bank",
        source_b_id="invoices",
        source_a_items=["txn_1"],
        source_b_items=["inv_1"],
        confidence=0.98,
        decision=MatchDecision.AUTO_LINK,
        method=MatchMethod.AUTO_MATCHED,
        matched_by="system"
    )
    assert match.cardinality == "one_to_one"

def test_create_match_one_to_many():
    match = store.create(
        source_a_items=["inv_1"],
        source_b_items=["pay_1", "pay_2", "pay_3"],
        ...
    )
    assert match.cardinality == "one_to_many"

def test_item_already_matched_error():
    store.create(source_a_items=["txn_1"], source_b_items=["inv_1"], ...)
    with pytest.raises(ItemAlreadyMatchedError):
        store.create(source_a_items=["txn_1"], source_b_items=["inv_2"], ...)
```

**Integration Tests:**

```python
def test_end_to_end_reconciliation():
    # 1. Create bank transaction and invoice
    txn = create_transaction(amount=-5000.00, date="2024-10-15", merchant="Acme Corp")
    inv = create_invoice(amount=5000.00, date="2024-10-14", vendor="Acme Corporation")

    # 2. Find candidates
    response = client.post("/api/reconciliation/find-candidates", json={
        "source_a_id": "bank",
        "source_b_id": "invoices",
        "item_id": txn.id
    })
    candidates = response.json()["candidates"]
    assert len(candidates) == 1
    assert candidates[0]["item_id"] == inv.id
    assert candidates[0]["confidence"] >= 0.95

    # 3. Verify auto-link decision
    assert candidates[0]["decision"] == "auto_link"

    # 4. Create match
    match_response = client.post("/api/reconciliation/matches", json={
        "source_a_items": [txn.id],
        "source_b_items": [inv.id],
        "method": "auto_matched"
    })
    assert match_response.status_code == 201
    match = match_response.json()

    # 5. Verify match created
    assert match["cardinality"] == "one_to_one"
    assert match["confidence"] >= 0.95

    # 6. Verify items marked as matched
    txn_status = client.get(f"/api/transactions/{txn.id}").json()
    assert txn_status["reconciliation_status"] == "matched"

def test_manual_match_creation():
    txn = create_transaction(amount=-2450.00, date="2024-10-10")
    inv = create_invoice(amount=2450.00, date="2024-09-28")  # >7 days difference

    # Auto-detection should fail (date outside tolerance)
    candidates = client.post("/api/reconciliation/find-candidates", json={
        "item_id": txn.id, ...
    }).json()["candidates"]
    assert len(candidates) == 0  # No auto-match

    # User manually creates match
    match = client.post("/api/reconciliation/matches", json={
        "source_a_items": [txn.id],
        "source_b_items": [inv.id],
        "method": "manual_create",
        "notes": "Late payment confirmed"
    }).json()

    assert match["confidence"] < 0.70  # Low confidence due to date
    assert match["method"] == "manual_create"

def test_one_to_many_match():
    inv = create_invoice(amount=10000.00, date="2024-10-01")
    pay1 = create_payment(amount=-5000.00, date="2024-10-15")
    pay2 = create_payment(amount=-3000.00, date="2024-11-01")
    pay3 = create_payment(amount=-2000.00, date="2024-11-15")

    # User creates one-to-many match
    match = client.post("/api/reconciliation/matches", json={
        "source_a_items": [inv.id],
        "source_b_items": [pay1.id, pay2.id, pay3.id],
        "method": "manual_create"
    }).json()

    assert match["cardinality"] == "one_to_many"
    assert match["confidence"] >= 0.95  # Amounts sum exactly
```

**Multi-Domain Tests:**
- Finance: Reconcile bank transactions with invoices
- Healthcare: Reconcile insurance claims with payments (EOB)
- Legal: Reconcile PACER filings with state court filings
- Research: Reconcile DOI citations with arXiv citations
- E-commerce: Reconcile orders with shipments and payments

**Performance Tests:**
```python
def test_blocking_performance():
    # Create 10K bank transactions and 10K invoices
    txns = [create_transaction(...) for _ in range(10000)]
    invs = [create_invoice(...) for _ in range(10000)]

    start = time.time()
    for txn in txns[:100]:  # Test 100 items
        candidates = engine.find_candidates(txn, invs, config)
    elapsed = time.time() - start

    # Should complete in <2s per item with blocking
    assert elapsed / 100 < 2.0

def test_bulk_reconciliation_throughput():
    start = time.time()
    result = engine.bulk_reconcile("bank", "invoices", config)
    elapsed = time.time() - start

    total_items = len(result.auto_linked) + len(result.suggested) + len(result.no_match)
    throughput = total_items / elapsed

    # Should process >200 items/second
    assert throughput >= 200
```

---

### 20. Operations Runbook

**Deployment:**

1. **Database Migrations:**
```sql
-- Create reconciliation_results table
CREATE TABLE reconciliation_results (
    match_id VARCHAR(100) PRIMARY KEY,
    user_id UUID NOT NULL,
    source_a_id VARCHAR(100) NOT NULL,
    source_b_id VARCHAR(100) NOT NULL,
    source_a_items JSONB NOT NULL,  -- Array of item IDs
    source_b_items JSONB NOT NULL,  -- Array of item IDs
    cardinality VARCHAR(20) NOT NULL,  -- one_to_one, one_to_many, many_to_one, many_to_many
    confidence DECIMAL(4,3) NOT NULL CHECK (confidence >= 0 AND confidence <= 1),
    decision VARCHAR(20) NOT NULL,  -- auto_link, auto_suggest, manual_review, no_match
    method VARCHAR(20) NOT NULL,  -- auto_matched, manual_accept, manual_create
    matched_by VARCHAR(100) NOT NULL,  -- user_id or 'system'
    matched_at TIMESTAMP NOT NULL DEFAULT NOW(),
    status VARCHAR(20) NOT NULL,  -- matched, rejected
    rejected_by VARCHAR(100),
    rejected_at TIMESTAMP,
    rejection_reason TEXT,
    notes TEXT,
    feature_scores JSONB,  -- {amount: 1.0, date: 0.95, counterparty: 0.95, description: 0.0}
    feature_details JSONB,  -- {amount_diff: 0.00, date_diff_days: 1, ...}
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Create reconciliation_config table
CREATE TABLE reconciliation_config (
    config_id VARCHAR(100) PRIMARY KEY,
    user_id UUID NOT NULL,
    source_a_id VARCHAR(100) NOT NULL,
    source_b_id VARCHAR(100) NOT NULL,
    amount_tolerance_pct DECIMAL(4,3) NOT NULL DEFAULT 0.05,
    date_tolerance_days INTEGER NOT NULL DEFAULT 7,
    weights JSONB NOT NULL,  -- {amount: 0.4, date: 0.3, counterparty: 0.2, description: 0.1}
    thresholds JSONB NOT NULL,  -- {auto_link: 0.95, auto_suggest: 0.70, manual: 0.50}
    blocking_enabled BOOLEAN DEFAULT TRUE,
    blocking_date_range_days INTEGER DEFAULT 30,
    blocking_amount_range_pct DECIMAL(4,3) DEFAULT 0.20,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, source_a_id, source_b_id)
);

-- Create reconciliation_audit table
CREATE TABLE reconciliation_audit (
    audit_id SERIAL PRIMARY KEY,
    match_id VARCHAR(100) NOT NULL,
    event VARCHAR(50) NOT NULL,  -- created, accepted, rejected, updated
    user_id VARCHAR(100),
    details JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (match_id) REFERENCES reconciliation_results(match_id)
);

-- Add reconciliation_status to items (transactions, invoices, etc.)
ALTER TABLE transactions ADD COLUMN reconciliation_status VARCHAR(20) DEFAULT 'unmatched';
-- Values: unmatched, matched, rejected, excluded

-- Create indexes (see Section 17)
```

2. **Seed Default Config:**
```bash
# Load default reconciliation config for common source pairs
python /app/scripts/seed_reconciliation_config.py --config-file=default_configs.json
```

**Monitoring:**

- **Health Check:** `GET /api/health/reconciliation` - Returns OK if ReconciliationEngine can query
- **Metric Alerts:**
  - Auto-link rejection rate >10% → investigate false positives
  - Candidate search latency >5s → blocking strategy needs tuning
  - Bulk job failure rate >5% → investigate data quality

**Common Issues:**

**Issue 1: Too many suggested matches, not enough auto-links**
- **Symptom:** >50% of matches in "suggested" state, <30% auto-linked
- **Debug:**
  1. Check confidence distribution (may be clustered around 0.70-0.90)
  2. Review feature weights (may need adjustment)
  3. Check data quality (counterparty names may have high variance)
- **Fix:**
  - Lower auto-link threshold from 0.95 to 0.90 (if acceptable)
  - Improve counterparty normalization (3.2 Counterparty Registry)
  - Increase counterparty weight in scoring

**Issue 2: Blocking strategy not effective (slow performance)**
- **Symptom:** Candidate search >5s, blocking not reducing search space
- **Debug:**
  1. Check blocking config (date_range_days, amount_range_pct)
  2. Verify items have date and amount fields populated
  3. Check index usage (EXPLAIN query plan)
- **Fix:**
  - Tighten blocking ranges (±30 days → ±14 days, ±20% → ±10%)
  - Ensure indexes on date and amount fields
  - Consider additional blocking dimensions (counterparty first letter)

**Issue 3: False positive auto-links (wrong matches)**
- **Symptom:** Users rejecting >10% of auto-linked matches
- **Debug:**
  1. Review rejected matches (common patterns?)
  2. Check feature scores (which features are misleading?)
  3. Verify thresholds (0.95 may be too low for this source pair)
- **Fix:**
  - Increase auto-link threshold to 0.97 or 0.98
  - Add additional required features (e.g., counterparty must match >90%)
  - Implement ML model to learn from user rejections (v2)

**Issue 4: One-to-many matches not validating correctly**
- **Symptom:** User creates one-to-many match but amounts don't sum
- **Debug:**
  1. Check validation logic (sum of payments vs invoice amount)
  2. Verify tolerance is applied (may need ±1% for rounding)
  3. Check for currency mismatches (USD vs EUR)
- **Fix:**
  - Apply tolerance to sum validation (allow ±1% variance)
  - Require FX conversion before reconciliation (3.6 Unit)
  - Show clear error message with amount breakdown

**Incident Response:**

```bash
# Query unmatched items for source pair
SELECT source_id, item_id, amount, date, reconciliation_status
FROM reconciliation_items
WHERE source_id IN ('bank_chase', 'invoices_qb')
  AND reconciliation_status = 'unmatched'
ORDER BY date DESC
LIMIT 100;

# Force create match
curl -X POST /api/reconciliation/matches \
  -H "Authorization: Bearer TOKEN" \
  -d '{
    "source_a_items": ["txn_123"],
    "source_b_items": ["inv_456"],
    "method": "manual_create",
    "notes": "Admin override - confirmed via support ticket"
  }'

# Reject match
curl -X POST /api/reconciliation/matches/{match_id}/reject \
  -H "Authorization: Bearer TOKEN" \
  -d '{"reason": "incorrect_vendor"}'

# Bulk re-reconcile source pair
python /app/scripts/bulk_reconcile.py --source-a=bank_chase --source-b=invoices_qb --auto-accept=false

# Update thresholds (admin)
curl -X PATCH /api/reconciliation/config/{config_id} \
  -H "Authorization: Bearer ADMIN_TOKEN" \
  -d '{
    "thresholds": {
      "auto_link": 0.97,
      "auto_suggest": 0.75,
      "manual": 0.50
    }
  }'

# Query match audit trail
SELECT event, user_id, details, created_at
FROM reconciliation_audit
WHERE match_id = 'match_abc123'
ORDER BY created_at ASC;
```

---

## 💻 Tech Stack (Finance-App Implementation)

**Scale Target:** ~50 invoices/year from QuickBooks, ~195 bank transactions/month → ~650 reconciliation opportunities/year

### Backend

**ReconciliationEngine Implementation (with P1 Fix Applied):**
- **Configurable field_matchers** (P1 fix - NO hardcoded fields):
  ```python
  # Finance-specific matchers
  engine.add_field_matcher(
      field_name="currency",
      matcher_fn=lambda a, b: 1.0 if a.metadata.get('currency') == b.metadata.get('currency') else 0.0,
      weight=0.1,
      blocking=True  # Pre-filter: only compare same currency
  )

  engine.add_field_matcher(
      field_name="counterparty",
      matcher_fn=lambda a, b: jaro_winkler(a.metadata.get('counterparty', ''), b.metadata.get('counterparty', '')),
      weight=0.2,
      blocking=False
  )
  ```
- **Universal ReconciliationItem** (domain-agnostic):
  - Core fields: `amount` (Decimal), `date` (date), `description` (str)
  - Domain fields: Store in `metadata` dict (currency, counterparty, account, etc.)
- **Blocking strategy:**
  - Universal: Date ±30 days, Amount ±20%
  - Domain-specific: Via field_matchers with `blocking=True` (e.g., currency match)
  - Performance: O(n²) → O(n×m) where m << n (10K × 10K → 10K × 500)
- **Performance:** <200ms for 50 candidates (p95)

**MatchScorer Implementation:**
- **Weighted features:**
  - Amount similarity (40%): `1.0 - abs((amt_a - amt_b) / amt_a)` within 5% tolerance
  - Date proximity (30%): `max(0, 1 - abs(date_a - date_b).days / 7)` within 7 days
  - Counterparty similarity (20%): Jaro-Winkler distance (0.0-1.0)
  - Description similarity (10%): Levenshtein distance
- **Confidence calculation:** Weighted sum of feature scores (0.0-1.0)
- **Example:**
  - Bank: -$1,000, Oct 15, "Acme Corp"
  - Invoice: $1,000, Oct 14, "Acme Corporation"
  - Amount: 1.0 (exact match) × 0.4 = 0.40
  - Date: 0.86 (1 day diff) × 0.3 = 0.26
  - Counterparty: 0.95 (fuzzy match) × 0.2 = 0.19
  - Description: 0.0 (no match) × 0.1 = 0.00
  - **Total confidence: 0.85** (auto-suggest)

**ThresholdManager Implementation:**
- **Decision thresholds:**
  - `auto_link`: ≥ 0.95 (create match automatically, optional, disabled by default)
  - `auto_suggest`: ≥ 0.70 (show to user for review)
  - `manual`: ≥ 0.50 (low confidence, user decides)
  - `no_match`: < 0.50 (ignore)
- **Configurable per source pair:** Different thresholds for Bank↔Invoice vs Card↔Bank
- **Database:** SQLite table `reconciliation_configs` with JSON config

**ReconciliationStore Implementation:**
- **Database:** SQLite
  - Table: `reconciliation_results`
  - Columns: `result_id`, `source_a_id`, `source_b_id`, `item_a_id`, `item_b_id`, `confidence`, `decision`, `method`, `matched_by`, `created_at`, `deleted_at`
- **Cardinality support:**
  - One-to-one: Single item_a_id, single item_b_id
  - One-to-many: Single item_a_id, JSON array `item_b_ids`
  - Many-to-one: JSON array `item_a_ids`, single item_b_id
- **Soft delete:** Set `deleted_at` timestamp (preserve audit trail)
- **Indexing:**
  - `(item_a_id)`, `(item_b_id)` for lookups
  - `(source_a_id, source_b_id, decision)` for dashboard queries
- **Storage:** ~600 bytes/match × 50 matches/year = 30KB/year

### Frontend

**ReconciliationDashboard (IL Component):**
- **Framework:** React + TypeScript
- **UI Library:** shadcn/ui (Card, Table, Badge)
- **Features:**
  - Summary stats: Auto-linked, Suggested, Unmatched counts
  - Filter by source pair (Bank→Invoice, Card→Bank)
  - Filter by decision (auto-linked, suggested, manual)
  - List match suggestions with confidence scores
  - "Review" button → Opens MatchReviewDialog
- **State:** TanStack Query for server state, optimistic updates

**MatchReviewDialog (IL Component):**
- **Framework:** React + TypeScript
- **UI Library:** shadcn/ui (Dialog, Card, Badge, Button)
- **Features:**
  - Side-by-side comparison: Source A vs Source B
  - Show feature scores breakdown (amount, date, counterparty, description)
  - Confidence badge with color coding (green ≥0.95, yellow ≥0.70, red <0.70)
  - Actions: Accept Match, Reject, Skip
  - Keyboard shortcuts: A (accept), R (reject), S (skip), → (next)
- **Validation:** Prevent accepting low-confidence matches without confirmation

**ManualMatchDialog (IL Component):**
- **Framework:** React + TypeScript
- **UI Library:** shadcn/ui (Dialog, Select, Input)
- **Features:**
  - Dropdown selectors for Source A item + Source B item
  - Auto-calculate confidence score on selection
  - Support one-to-many: Select multiple Source B items, validate sum matches Source A amount
  - Support many-to-one: Select multiple Source A items
  - Notes field for manual overrides
  - Preview total amounts before confirming

### API Endpoints

**POST /api/reconciliation/find-candidates**
- **Purpose:** Find match candidates for single item
- **Auth:** User session
- **Body:** `{ source_a_id, source_b_id, item_id, config }`
- **Response:** `{ candidates: [...], total_count }`
- **Latency:** <200ms for 50 candidates with blocking (p95)

**POST /api/reconciliation/bulk-reconcile**
- **Purpose:** Reconcile all unmatched items from source pair
- **Auth:** User session
- **Body:** `{ source_a_id, source_b_id, config, auto_accept: false }`
- **Response:** `{ job_id, auto_linked, auto_suggested, manual_review, no_match }`
- **Processing:** Async job (5-10s for 50 items)
- **Polling:** GET /api/jobs/:job_id

**POST /api/reconciliation/matches**
- **Purpose:** Manually create match
- **Auth:** User session
- **Body:** `{ item_a_id, item_b_id, source_a_id, source_b_id, notes }`
- **Response:** `{ result_id, confidence, decision }`
- **Validation:** Prevent matching already-matched items
- **Latency:** <100ms (calculate confidence + INSERT)

**DELETE /api/reconciliation/matches/:result_id**
- **Purpose:** Unlink match (soft-delete)
- **Auth:** User session (only owner)
- **Response:** `{ success: true }`
- **Side effect:** Set `deleted_at`, mark items as unmatched
- **Latency:** <50ms (single UPDATE)

**GET /api/reconciliation/stats**
- **Purpose:** Get reconciliation dashboard statistics
- **Auth:** User session
- **Query params:** `?source_a=bank_chase&source_b=invoices_qb`
- **Response:**
  ```json
  {
    "source_a_total": 195,
    "source_a_unmatched": 50,
    "source_b_total": 48,
    "source_b_unmatched": 10,
    "matches_auto_linked": 30,
    "matches_suggested": 5,
    "matches_manual": 3
  }
  ```
- **Latency:** <100ms (indexed aggregation queries)

### Database Schema

```sql
-- ReconciliationResult (match records)
CREATE TABLE reconciliation_results (
    result_id TEXT PRIMARY KEY,  -- match_xxxxx
    source_a_id TEXT NOT NULL,  -- "bank_chase"
    source_b_id TEXT NOT NULL,  -- "invoices_qb"
    item_a_id TEXT NOT NULL,  -- Transaction canonical_id
    item_b_id TEXT,  -- Invoice ID (NULL for many-to-one)
    item_b_ids TEXT,  -- JSON array for one-to-many
    item_a_ids TEXT,  -- JSON array for many-to-one
    confidence REAL NOT NULL,  -- 0.0-1.0
    decision TEXT NOT NULL,  -- auto_link | auto_suggest | manual_review | no_match
    method TEXT NOT NULL,  -- auto | manual_create | manual_accept
    matched_by TEXT NOT NULL,  -- user_id or "system"
    notes TEXT,  -- User notes for manual matches
    created_at TEXT NOT NULL,
    deleted_at TEXT,  -- Soft delete (unlink)
    version INTEGER NOT NULL DEFAULT 1
);

CREATE INDEX idx_reconciliation_item_a ON reconciliation_results(item_a_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_reconciliation_item_b ON reconciliation_results(item_b_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_reconciliation_source_pair ON reconciliation_results(source_a_id, source_b_id, decision) WHERE deleted_at IS NULL;

-- ReconciliationConfig (per source pair)
CREATE TABLE reconciliation_configs (
    config_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    source_a_id TEXT NOT NULL,
    source_b_id TEXT NOT NULL,
    amount_tolerance_pct TEXT NOT NULL,  -- Decimal "0.05" (5%)
    date_tolerance_days INTEGER NOT NULL,  -- 7 days
    weights TEXT NOT NULL,  -- JSON: {"amount": 0.4, "date": 0.3, ...}
    thresholds TEXT NOT NULL,  -- JSON: {"auto_link": 0.95, "auto_suggest": 0.70, ...}
    blocking_enabled INTEGER NOT NULL DEFAULT 1,
    blocking_date_range_days INTEGER NOT NULL DEFAULT 30,
    blocking_amount_range_pct TEXT NOT NULL DEFAULT '0.20',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE UNIQUE INDEX idx_reconciliation_config_pair ON reconciliation_configs(user_id, source_a_id, source_b_id);

-- ReconciliationAudit (audit trail)
CREATE TABLE reconciliation_audit (
    audit_id TEXT PRIMARY KEY,
    result_id TEXT NOT NULL REFERENCES reconciliation_results(result_id),
    event TEXT NOT NULL,  -- match_created | match_accepted | match_rejected | match_unlinked
    user_id TEXT NOT NULL,
    details TEXT,  -- JSON (confidence, decision, notes, etc.)
    created_at TEXT NOT NULL
);

CREATE INDEX idx_reconciliation_audit_result ON reconciliation_audit(result_id, created_at);
```

### Testing

**Unit Tests:**
- MatchScorer weighted feature calculation
- ThresholdManager decision logic (confidence → decision)
- ReconciliationEngine blocking filter (date + amount ranges)
- ReconciliationStore cardinality (one-to-one, one-to-many, many-to-one)
- Field matcher registration and execution (P1 fix validation)

**Integration Tests:**
- Bulk reconcile → Auto-link high confidence → Suggest medium confidence
- Manual create match → Calculate confidence → Store result
- Unlink match → Soft delete → Items become unmatched
- Block same-item rematch (validation error)

**Golden Data Tests:**
- `tests/fixtures/bank_transactions.json` + `invoices.json` → Expected 30 matches
- Compare matched pairs vs expected (confidence, decision, features)

### Performance Characteristics

**Latency Targets:**
- Find candidates (with blocking): <200ms for 50 candidates (p95)
- Calculate confidence: <10ms per candidate pair
- Bulk reconcile: <10s for 50 items (p95)
- Manual match creation: <100ms (p95)

**Scalability:**
- Current: 195 bank tx/month, 50 invoices/year → ~650 reconciliation opportunities/year
- Storage: ~600 bytes/match × 100 matches/year = 60KB/year
- 5-year projection: 500 matches = 300KB total (trivial)

**Blocking Effectiveness:**
- Without blocking: 10K × 10K = 100M comparisons (~10s)
- With blocking: 10K × 500 = 5M comparisons (~0.5s)
- Speed improvement: 20x faster for large datasets

---

## 🎯 Summary

Vertical 3.9 delivers a **multi-source reconciliation system** with:

✅ **4 OL Primitives** (ReconciliationEngine, MatchScorer, ThresholdManager, ReconciliationStore)
✅ **3 IL Components** (ReconciliationDashboard, MatchReviewDialog, ManualMatchDialog)
✅ **3 Schemas** (reconciliation-result, match-candidate, reconciliation-config)
✅ **20 Complete Sections** (Product, Machinery, Cross-Cutting)
✅ **Multi-Domain Pattern** (Finance → Bank-Invoice, Healthcare → Claim-Payment, Legal → Court Filing Reconciliation, Research → Citation Deduplication, E-commerce → Order-Shipment-Payment)

**Finance Instantiation:**
- Bank-to-Invoice: Match payments with invoices by amount + date + vendor
- Credit-Card-to-Bank: Match credit card charges with bank payments
- Multi-Payment: One invoice → multiple installment payments (one-to-many)
- Split Payment: One payment → multiple invoices (many-to-one)
- Fuzzy matching: Amount ±5%, date ±7 days, counterparty name similarity

**Universal Pattern: Multi-Source Entity Matching**
- Fuzzy matching with configurable tolerances
- Multi-feature confidence scoring (weighted)
- Threshold-based decision automation (auto-link, suggest, manual)
- Blocking strategies for performance (O(n²) → O(n×m))
- Cardinality support (one-to-one, one-to-many, many-to-one)
- Full audit trail for explainability

**Next:** 4.x Series (Forecast, Budget, Tax Engine, Accounting)
