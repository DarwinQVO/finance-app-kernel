# Vertical 3.7: Parser Registry

> **Type:** Service Discovery System
> **Pattern:** Registry Pattern + Service Discovery + Capability-Based Selection
> **Last Updated:** 2025-10-24

---

## ğŸ“‹ Overview

The **Parser Registry** vertical provides a **service discovery and capability matching system** for registering document parsers, tracking their capabilities, managing versions, and auto-selecting the best parser for uploaded files. While demonstrated in finance domain (bank statement parsers for PDFs/CSVs), the underlying primitives are domain-agnostic and apply to ANY pluggable service architecture.

**Key Characteristics:**
- **Service Registration:** Parsers register with metadata (name, version, file types, capabilities)
- **Capability Discovery:** Track what fields each parser can extract (date, amount, merchant, etc.)
- **Version Management:** Semantic versioning with deprecation support (v1 â†’ v2 â†’ v3)
- **Auto-Selection:** Automatically select best parser based on file metadata and capabilities
- **Confidence Scoring:** Rank parsers by confidence (0.0-1.0) for user override
- **Backward Compatibility:** Track breaking changes and migration paths between versions

**Finance Domain Examples:**
- PDF Parsers: Bank of America (v2.1.0), Chase (v1.5.3), Scotia (v3.0.0)
- CSV Parsers: Apple Card (v1.2.0), Mint (v2.0.1), Plaid (v1.0.0)
- Capabilities: Extract date, amount, merchant, account number, balance, memo
- Auto-detection: Filename pattern matching ("BofA_Statement_Nov2024.pdf" â†’ BofA parser v2.1.0)

**Multi-Domain Applicability:**
- Healthcare: HL7 v2/v3 parsers, FHIR JSON parsers, DICOM parsers, CCD/CDA parsers
- Legal: PDF parsers (court documents), DOCX parsers (contracts), OCR parsers (scanned filings)
- Research: LaTeX parsers, BibTeX parsers, citation parsers, dataset format parsers (CSV, Parquet, HDF5)
- E-commerce: EDI parsers (X12, EDIFACT), XML invoice parsers, JSON order parsers

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Parser registration with metadata (name, version, file types, capabilities)
- Capability tracking (what fields each parser extracts)
- Semantic versioning (major.minor.patch) with deprecation support
- Auto-selection of best parser based on file metadata
- Confidence scoring for parser selection (0.0-1.0)
- Filename pattern matching (regex-based)
- Parser capability matrix (which parsers support which fields)
- Version compatibility tracking (schema version compatibility)
- Parser discovery (list all parsers for a file type)
- Deprecation warnings and sunset dates

**Out of Scope:**
- Actual parsing logic (covered in domain-specific parsers)
- File upload/storage (covered in 1.1 Document Ingestion)
- Schema validation of parsed output (covered in 1.2 Schema Validation)
- Error handling during parsing (covered in parser implementation)
- Parser execution/orchestration (covered in pipeline orchestrator)

**Boundaries:**
- Registry is read-mostly (parsers registered at deployment, not runtime)
- One file can match multiple parsers (ranked by confidence)
- User can override auto-selected parser (manual selection)
- Parsers can support multiple file types (e.g., BofA supports PDF + CSV)
- Capabilities are self-declared (not validated at registration time)

---

### 2. User Flow (Real Usage)

**Scenario 1: System auto-selects parser for uploaded file**

User: "Upload my Bank of America statement (PDF)"

System:
1. User drags "BofA_Statement_Nov2024.pdf" to upload zone
2. System analyzes file metadata:
   - File type: PDF
   - Filename: "BofA_Statement_Nov2024.pdf"
   - Size: 245 KB
3. ParserSelector.select_parser() runs:
   - Queries ParserRegistry for parsers supporting PDF
   - Matches: BofA PDF parser v2.1.0, Chase PDF parser v1.5.3, Generic PDF parser v1.0.0
   - Filename pattern match: "BofA_Statement_Nov2024.pdf" matches `.*BofA.*\.pdf` (BofA parser)
   - Confidence scores:
     - BofA PDF parser v2.1.0: 0.98 (filename match + file type match)
     - Generic PDF parser v1.0.0: 0.40 (file type match only)
4. System auto-selects BofA PDF parser v2.1.0
5. User sees: "âœ… Auto-detected: Bank of America PDF Parser v2.1.0"
6. File queued for parsing with parser_id="parser_bofa_pdf"

**Scenario 2: User manually overrides auto-selected parser**

User: "The auto-detected parser is wrong - this is a Chase statement, not BofA"

System:
1. System auto-selected BofA parser (confidence: 0.72, filename ambiguous)
2. User sees notification: "ğŸ’¡ Detected: Bank of America PDF Parser (72% confidence)"
3. User clicks "Change Parser" link
4. ParserSelectorDialog opens with:
   - Current: BofA PDF parser v2.1.0 (72% confidence)
   - Alternative parsers:
     - Chase PDF parser v1.5.3 (55% confidence)
     - Scotia PDF parser v3.0.0 (40% confidence)
     - Generic PDF parser v1.0.0 (30% confidence)
5. User clicks "Chase PDF parser v1.5.3"
6. System:
   - Updates file_metadata.parser_id = "parser_chase_pdf"
   - Logs override: user_selected=True, original_confidence=0.72
7. File re-queued for parsing with correct parser

**Scenario 3: View parser capabilities before upload**

User: "What fields can the BofA parser extract from my statement?"

System:
1. User hovers over "Bank of America PDF Parser v2.1.0" in parser dropdown
2. ParserCapabilitiesCard appears (tooltip):
   ```
   Bank of America PDF Parser v2.1.0
   âœ… Date (98% confidence)
   âœ… Amount (98% confidence)
   âœ… Merchant (95% confidence)
   âœ… Account Number (98% confidence)
   âœ… Balance (95% confidence)
   âš ï¸ Memo (70% confidence)
   âŒ Category (not supported)

   Supported formats: PDF
   Last updated: 2024-11-01
   ```
3. User sees exactly what fields will be extracted
4. User can compare capabilities across parsers before selecting

**Scenario 4: Handle deprecated parser version**

Background: BofA parser v1.x deprecated, v2.x is current

System:
1. User uploads file that previously used v1.5.0 parser
2. System checks parser version:
   - v1.5.0 is deprecated (sunset_date: 2024-12-31)
   - v2.1.0 is latest version
3. ParserVersionDropdown shows warning:
   ```
   âš ï¸ Deprecated Version
   Current: v1.5.0 (deprecated - sunset Dec 31, 2024)
   Latest: v2.1.0

   Breaking changes in v2.0.0:
   - Merchant field renamed to counterparty
   - Balance field now required

   [View Migration Guide] [Upgrade to v2.1.0]
   ```
4. User clicks "Upgrade to v2.1.0"
5. System:
   - Updates parser_id to v2.1.0
   - Applies field mapping (merchant â†’ counterparty)
   - Re-parses file with new version
6. User sees: "âœ… Upgraded to v2.1.0 successfully"

**Scenario 5: Admin registers new parser**

Admin: "We built a new Scotia Bank CSV parser - need to register it"

System:
1. Admin opens Parser Management UI
2. Clicks "Register New Parser"
3. Fills registration form:
   - Name: "Scotia Bank CSV Parser"
   - Version: "1.0.0"
   - File Types: CSV
   - Capabilities: date, amount, merchant, account
   - Filename Patterns: `.*Scotia.*\.csv`, `.*Scotiabank.*\.csv`
4. System validates:
   - parser_id unique? âœ… (generates: "parser_scotia_csv")
   - Version format valid? âœ… (1.0.0 matches semver)
   - Capabilities exist? âœ… (all are known fields)
5. Creates ParserRegistration:
   ```json
   {
     "parser_id": "parser_scotia_csv",
     "name": "Scotia Bank CSV Parser",
     "version": "1.0.0",
     "file_types": ["csv"],
     "capabilities": ["date", "amount", "merchant", "account"],
     "filename_patterns": [".*Scotia.*\\.csv", ".*Scotiabank.*\\.csv"],
     "deprecated": false,
     "registered_at": "2024-11-01T10:00:00Z"
   }
   ```
6. Parser immediately available for auto-selection
7. System logs: "parser_registered" event

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `ParserRegistry` - CRUD for parser registrations (NEW - this vertical)
- `ParserCapabilityStore` - Track what fields each parser extracts (NEW - this vertical)
- `ParserVersionManager` - Manage parser versions with deprecation (NEW - this vertical)
- `ParserSelector` - Auto-select best parser for file (NEW - this vertical)
- `FileStore` - Reference uploaded files for parser selection (from 1.1)
- `SchemaRegistry` - Validate parser output schemas (from 1.2)

**Interaction Layer (IL):**
- `ParserSelectorDialog` - Modal for selecting parser (NEW - this vertical)
- `ParserCapabilitiesCard` - Display parser capabilities (NEW - this vertical)
- `ParserVersionDropdown` - Select parser version (NEW - this vertical)
- `FileUploadZone` - Shows auto-detected parser (from 1.1)
- `DocumentList` - View files with assigned parser (from 2.1)

**Schemas:**
- `parser-registration.schema.json` - Parser registration record (NEW - this vertical)
- `parser-capability.schema.json` - Capability definition (NEW - this vertical)
- `parser-version.schema.json` - Version record with deprecation (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# List All Parsers for File Type
GET /api/parsers?file_type=pdf
Authorization: Bearer {token}

Response 200:
{
  "parsers": [
    {
      "parser_id": "parser_bofa_pdf",
      "name": "Bank of America PDF Parser",
      "version": "2.1.0",
      "file_types": ["pdf"],
      "capabilities": ["date", "amount", "merchant", "account", "balance"],
      "filename_patterns": [".*BofA.*\\.pdf", ".*Bank of America.*\\.pdf"],
      "deprecated": false,
      "registered_at": "2024-11-01T10:00:00Z"
    },
    {
      "parser_id": "parser_chase_pdf",
      "name": "Chase PDF Parser",
      "version": "1.5.3",
      "file_types": ["pdf"],
      "capabilities": ["date", "amount", "merchant", "account"],
      "filename_patterns": [".*Chase.*\\.pdf"],
      "deprecated": false,
      "registered_at": "2024-10-15T09:30:00Z"
    }
  ],
  "total": 2
}
```

```http
# Get Parser Details
GET /api/parsers/{parser_id}
Authorization: Bearer {token}

Response 200:
{
  "parser_id": "parser_bofa_pdf",
  "name": "Bank of America PDF Parser",
  "version": "2.1.0",
  "file_types": ["pdf"],
  "capabilities": [
    {
      "capability_name": "date",
      "field_type": "date",
      "extraction_confidence": 0.98,
      "required_for_success": true
    },
    {
      "capability_name": "amount",
      "field_type": "number",
      "extraction_confidence": 0.98,
      "required_for_success": true
    },
    {
      "capability_name": "merchant",
      "field_type": "string",
      "extraction_confidence": 0.95,
      "required_for_success": false
    }
  ],
  "filename_patterns": [".*BofA.*\\.pdf", ".*Bank of America.*\\.pdf"],
  "versions": [
    {"version": "2.1.0", "released_at": "2024-11-01T10:00:00Z", "deprecated": false},
    {"version": "2.0.0", "released_at": "2024-09-01T08:00:00Z", "deprecated": false},
    {"version": "1.5.0", "released_at": "2024-06-01T08:00:00Z", "deprecated": true, "sunset_date": "2024-12-31"}
  ]
}
```

```http
# Auto-Select Parser for File
POST /api/parsers/auto-select
Authorization: Bearer {token}
Content-Type: application/json

{
  "file_name": "BofA_Statement_Nov2024.pdf",
  "file_type": "pdf",
  "file_size": 245120,
  "user_preferences": {
    "preferred_parser_ids": ["parser_bofa_pdf"],
    "min_confidence": 0.7
  }
}

Response 200:
{
  "selected_parser": {
    "parser_id": "parser_bofa_pdf",
    "version": "2.1.0",
    "confidence": 0.98,
    "reason": "Filename matches pattern '.*BofA.*\\.pdf' and file type matches"
  },
  "alternative_parsers": [
    {
      "parser_id": "parser_generic_pdf",
      "version": "1.0.0",
      "confidence": 0.40,
      "reason": "File type matches but no filename pattern match"
    }
  ]
}

Response 200 (No match):
{
  "selected_parser": null,
  "alternative_parsers": [],
  "message": "No parser found with confidence >= 0.7"
}
```

```http
# Register New Parser (Admin only)
POST /api/parsers
Authorization: Bearer {admin_token}
Content-Type: application/json

{
  "name": "Scotia Bank CSV Parser",
  "version": "1.0.0",
  "file_types": ["csv"],
  "capabilities": ["date", "amount", "merchant", "account"],
  "filename_patterns": [".*Scotia.*\\.csv", ".*Scotiabank.*\\.csv"]
}

Response 201:
{
  "parser_id": "parser_scotia_csv",
  "name": "Scotia Bank CSV Parser",
  "version": "1.0.0",
  "file_types": ["csv"],
  "capabilities": ["date", "amount", "merchant", "account"],
  "filename_patterns": [".*Scotia.*\\.csv", ".*Scotiabank.*\\.csv"],
  "deprecated": false,
  "registered_at": "2024-11-01T10:00:00Z"
}

Response 400 (Validation error):
{
  "error": "PARSER_VALIDATION_FAILED",
  "message": "Parser validation failed",
  "validation_errors": [
    "Version '1.0' does not match semver format (major.minor.patch)",
    "Capability 'invalid_field' is not a known field type"
  ]
}
```

```http
# Deprecate Parser Version
PATCH /api/parsers/{parser_id}/versions/{version}/deprecate
Authorization: Bearer {admin_token}
Content-Type: application/json

{
  "sunset_date": "2024-12-31",
  "migration_guide_url": "https://docs.example.com/parsers/bofa/v2-migration",
  "breaking_changes": [
    "Merchant field renamed to counterparty",
    "Balance field now required"
  ]
}

Response 200:
{
  "parser_id": "parser_bofa_pdf",
  "version": "1.5.0",
  "deprecated": true,
  "sunset_date": "2024-12-31",
  "migration_guide_url": "https://docs.example.com/parsers/bofa/v2-migration",
  "breaking_changes": [
    "Merchant field renamed to counterparty",
    "Balance field now required"
  ]
}
```

**Internal OL API:**

```python
class ParserRegistry:
    def register(self, name: str, version: str, file_types: List[str],
                 capabilities: List[str], filename_patterns: List[str]) -> ParserRegistration:
        """
        Registers new parser in registry.

        Raises:
            DuplicateParserError: If parser_id already exists
            InvalidVersionError: If version doesn't match semver
            InvalidFileTypeError: If file_type not supported
            InvalidCapabilityError: If capability doesn't exist
        """

    def find_by_file_type(self, file_type: str) -> List[ParserRegistration]:
        """Returns all parsers supporting given file type (non-deprecated)."""

    def get_latest_version(self, parser_id: str) -> str:
        """Returns latest non-deprecated version for parser."""

    def search(self, query: str) -> List[ParserRegistration]:
        """Full-text search across parser names and descriptions."""

class ParserCapabilityStore:
    def set_capabilities(self, parser_id: str, capabilities: List[ParserCapability]) -> None:
        """
        Stores capability definitions for parser.

        Raises:
            ParserNotFoundError: If parser_id doesn't exist
            InvalidCapabilityError: If capability fields invalid
        """

    def get_capabilities(self, parser_id: str) -> List[ParserCapability]:
        """Returns all capabilities for parser with confidence scores."""

    def find_parsers_with_capability(self, capability_name: str,
                                     min_confidence: float = 0.7) -> List[str]:
        """Returns parser_ids that support given capability with confidence >= min."""

class ParserVersionManager:
    def create_version(self, parser_id: str, version: str,
                       breaking_changes: List[str]) -> ParserVersion:
        """
        Creates new version record for parser.

        Raises:
            InvalidVersionError: If version format invalid or duplicate
            ParserNotFoundError: If parser_id doesn't exist
        """

    def mark_deprecated(self, parser_id: str, version: str,
                        sunset_date: date, migration_guide_url: str) -> None:
        """Marks version as deprecated with sunset date."""

    def get_compatibility_matrix(self, parser_id: str) -> Dict[str, List[str]]:
        """Returns which schema versions each parser version is compatible with."""

class ParserSelector:
    def select_parser(self, file_metadata: FileMetadata,
                      user_preferences: Optional[UserPreferences] = None) -> Optional[ParserSelection]:
        """
        Auto-selects best parser based on file metadata.

        Selection criteria (weighted):
        1. Filename pattern match (weight: 0.6)
        2. File type match (weight: 0.3)
        3. Required capabilities match (weight: 0.1)
        4. User preference (boost: +0.1)

        Returns:
            ParserSelection with confidence score [0.0, 1.0]
            None if no match with confidence >= min_confidence (default: 0.7)
        """

    def rank_parsers(self, file_metadata: FileMetadata) -> List[RankedParser]:
        """Returns all matching parsers sorted by confidence (descending)."""

    def suggest_parsers(self, file_metadata: FileMetadata,
                        min_confidence: float = 0.5) -> List[ParserSuggestion]:
        """Returns parser suggestions for user to choose from (confidence >= min)."""
```

---

### 5. Schemas / Tipos (Persistencia)

**ParserRegistration Schema:**

```json
{
  "parser_id": "parser_bofa_pdf",
  "name": "Bank of America PDF Parser",
  "version": "2.1.0",
  "file_types": ["pdf"],
  "capabilities": ["date", "amount", "merchant", "account", "balance"],
  "filename_patterns": [".*BofA.*\\.pdf", ".*Bank of America.*\\.pdf"],
  "deprecated": false,
  "sunset_date": null,
  "registered_at": "2024-11-01T10:00:00Z",
  "description": "Extracts transactions from Bank of America PDF statements"
}
```

**ParserCapability Schema:**

```json
{
  "parser_id": "parser_bofa_pdf",
  "capability_name": "date",
  "field_type": "date",
  "extraction_confidence": 0.98,
  "required_for_success": true,
  "notes": "Extracts transaction date in MM/DD/YYYY format"
}
```

**ParserVersion Schema:**

```json
{
  "parser_id": "parser_bofa_pdf",
  "version": "2.1.0",
  "released_at": "2024-11-01T10:00:00Z",
  "deprecated": false,
  "sunset_date": null,
  "breaking_changes": [],
  "migration_guide_url": null,
  "compatible_with": ["observation-transaction-v1", "observation-transaction-v2"]
}
```

**ParserSelection Schema (output):**

```json
{
  "selected_parser": {
    "parser_id": "parser_bofa_pdf",
    "version": "2.1.0",
    "confidence": 0.98,
    "reason": "Filename matches pattern '.*BofA.*\\.pdf' and file type matches",
    "capabilities": ["date", "amount", "merchant", "account", "balance"]
  },
  "alternative_parsers": [
    {
      "parser_id": "parser_generic_pdf",
      "version": "1.0.0",
      "confidence": 0.40,
      "reason": "File type matches but no filename pattern match"
    }
  ],
  "selected_at": "2024-11-01T10:30:00Z"
}
```

---

### 6. Validaciones & Estados

**Register Parser Validations:**
- Name: 1-100 chars, unique globally
- Version: Must match semver pattern `^[0-9]+\.[0-9]+\.[0-9]+$`
- File types: Must be in allowed list (pdf, csv, xlsx, json, xml)
- Capabilities: Must reference known field types (date, amount, merchant, etc.)
- Filename patterns: Valid regex (test compilation before save)
- parser_id: Auto-generated, format `parser_{snake_case_name}`

**Capability Validations:**
- capability_name: Must be known field (date, amount, merchant, account, balance, memo, category)
- field_type: Must be in (string, number, date, boolean, array)
- extraction_confidence: [0.0, 1.0]
- required_for_success: Boolean (if true, parser fails if field not extracted)

**Version Validations:**
- Version: Must be greater than existing versions (no downgrades)
- Breaking changes: Array of strings (max 500 chars each)
- Sunset date: Must be future date (cannot deprecate with past date)
- Compatible_with: Must reference existing schema versions

**Auto-Selection Validations:**
- File metadata: file_name (required), file_type (required), file_size (optional)
- User preferences: preferred_parser_ids (optional), min_confidence [0.0, 1.0] (default: 0.7)
- Confidence threshold: [0.0, 1.0]

**State Machine (Parser Version):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ active   â”‚â”€â”€deprecateâ”€â”€â–¶â”‚ deprecated â”‚â”€â”€sunsetâ”€â”€â–¶â”‚ sunset   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ new version released
     â”‚
     â–¼
â”‚ superseded â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 7. Edge Cases

**EC1: Multiple parsers match with same confidence**
- Problem: "Statement_Nov2024.pdf" matches BofA parser (0.85) and Generic PDF parser (0.85)
- **Solution:** Use tiebreaker:
  1. User preference (if set)
  2. Most recent version (newer preferred)
  3. Most specific parser (BofA preferred over Generic)
  4. Alphabetical order (stable sort)

**EC2: Filename pattern matches wrong parser**
- Problem: "Chase_statement_BofA_client.pdf" incorrectly matches BofA parser
- **Solution:** Allow user override with feedback loop:
  - User selects correct parser (Chase)
  - System logs override (file_name pattern mismatch)
  - Admin can refine filename_patterns to avoid false positives

**EC3: Parser version deprecated mid-processing**
- Problem: File uploaded with v1.5.0, but version deprecated before parsing completes
- **Solution:** Honor version at upload time (immutable file_metadata.parser_version)
- Show warning after processing: "âš ï¸ This file used deprecated parser v1.5.0 - upgrade available"

**EC4: New capability added to existing parser**
- Problem: BofA parser v2.2.0 adds "category" capability (not in v2.1.0)
- **Solution:** Capabilities are version-specific
- ParserCapabilityStore stores (parser_id, version, capability)
- Users on v2.1.0 don't see "category" capability

**EC5: Parser registration without actual implementation**
- Problem: Admin registers parser but implementation not deployed yet
- **Solution:** Add status field (registered | deployed | active)
- Only "active" parsers shown in auto-selection
- Status transitions: registered â†’ deployed â†’ active

**EC6: File type ambiguous (e.g., .txt can be CSV)**
- Problem: "transactions.txt" is actually CSV but has .txt extension
- **Solution:** ParserSelector tries multiple parsers in parallel:
  1. Check magic bytes / file header (CSV signature)
  2. Try CSV parser first (confidence boost for actual format)
  3. Fall back to .txt parser if CSV fails
- Log file type mismatch for admin review

**EC7: Parser deleted but files still reference it**
- Problem: Admin deletes parser, but 1000 files reference parser_id="parser_old_bofa"
- **Solution:** Soft delete only (is_active=false)
- Parser hidden from UI but preserved in historical records
- Files keep parser_id reference (immutable provenance)

---

### 8. Acceptance Criteria (Definition of Done)

**Parser Registration:**
- [ ] Admin can register new parser with name, version, file types, capabilities
- [ ] System validates version format (semver)
- [ ] System validates filename patterns (regex compilation)
- [ ] System auto-generates unique parser_id
- [ ] System prevents duplicate parser names
- [ ] Parser immediately available after registration (no restart required)

**Capability Management:**
- [ ] Admin can define capabilities for parser with confidence scores
- [ ] User can view capability matrix (which parsers support which fields)
- [ ] System validates capability names against known field types
- [ ] System validates extraction_confidence [0.0, 1.0]
- [ ] User can filter parsers by required capability (e.g., "show parsers that extract category")

**Version Management:**
- [ ] System tracks all versions for each parser (history preserved)
- [ ] Admin can mark version as deprecated with sunset date
- [ ] System prevents new files from using deprecated versions (warning shown)
- [ ] User can view breaking changes between versions
- [ ] System provides migration guide URL for upgrades
- [ ] User can manually select older version if needed (with warning)

**Auto-Selection:**
- [ ] System auto-selects parser based on filename pattern + file type
- [ ] System returns confidence score [0.0, 1.0] for selection
- [ ] User sees auto-detected parser with confidence badge
- [ ] User can override auto-selection (manual picker)
- [ ] System logs all auto-selections with reason (provenance)
- [ ] System suggests alternative parsers if confidence < 0.7

**Multi-Domain:**
- [ ] Pattern applies to Healthcare (HL7/FHIR parser registry)
- [ ] Pattern applies to Legal (document parser registry)
- [ ] Pattern applies to Research (citation parser registry)
- [ ] Pattern applies to E-commerce (EDI parser registry)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "parser_registered",
  "parser_id": "parser_scotia_csv",
  "name": "Scotia Bank CSV Parser",
  "version": "1.0.0",
  "file_types": ["csv"],
  "capabilities": ["date", "amount", "merchant", "account"],
  "admin_id": "admin_123",
  "timestamp": "2024-11-01T10:00:00Z"
}
```

```json
{
  "event": "parser_auto_selected",
  "file_id": "file_67890",
  "file_name": "BofA_Statement_Nov2024.pdf",
  "file_type": "pdf",
  "selected_parser_id": "parser_bofa_pdf",
  "version": "2.1.0",
  "confidence": 0.98,
  "reason": "Filename matches pattern '.*BofA.*\\.pdf' and file type matches",
  "alternative_parsers": ["parser_generic_pdf"],
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:30:00Z"
}
```

```json
{
  "event": "parser_manually_selected",
  "file_id": "file_67891",
  "original_parser_id": "parser_bofa_pdf",
  "original_confidence": 0.72,
  "selected_parser_id": "parser_chase_pdf",
  "user_id": "user_123",
  "timestamp": "2024-11-01T10:35:00Z"
}
```

```json
{
  "event": "parser_version_deprecated",
  "parser_id": "parser_bofa_pdf",
  "version": "1.5.0",
  "sunset_date": "2024-12-31",
  "breaking_changes": ["Merchant field renamed to counterparty", "Balance field now required"],
  "admin_id": "admin_123",
  "timestamp": "2024-11-01T09:00:00Z"
}
```

**Provenance Chain:**
```
File Uploaded (1.1)
  â†“
ParserSelector.select_parser() (3.7)
  â†“
Parser Selection Logged (provenance)
  â†“
File Queued for Parsing (1.1)
  â†“
Parser Executes (domain-specific)
  â†“
Parsed Output Validated (1.2)
```

---

### 10. Risks & Deferred

**Risks:**
- **R1: Parser registration complexity** - Too many fields to configure
  - **Mitigation:** Provide sensible defaults, make most fields optional
- **R2: Filename pattern conflicts** - Multiple parsers match same pattern
  - **Mitigation:** Confidence scoring + user override + admin notification
- **R3: Version explosion** - Too many versions to maintain
  - **Mitigation:** Enforce sunset dates, auto-archive versions older than 1 year
- **R4: Capability drift** - Parser capabilities change without version bump
  - **Mitigation:** Capabilities are immutable per version, require new version for changes

**Deferred:**
- **D1: Parser health checks** - Automatic testing of parser availability (v2)
- **D2: Parser performance metrics** - Track parse time, success rate per parser (v2)
- **D3: A/B testing parsers** - Compare parser accuracy side-by-side (v3)
- **D4: Parser marketplace** - Community-contributed parsers (v3)
- **D5: Parser execution** - Actual parsing orchestration (separate vertical)

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 4 new primitives:**

1. **ParserRegistry** - CRUD for parser registrations
   - File: `docs/primitives/ol/ParserRegistry.md` (~1,100 lines)
   - Methods: register, get, find_by_file_type, get_latest_version, deprecate_version, search
   - Responsibilities: Parser persistence, version tracking, uniqueness validation

2. **ParserCapabilityStore** - Track what fields each parser extracts
   - File: `docs/primitives/ol/ParserCapabilityStore.md` (~950 lines)
   - Methods: set_capabilities, get_capabilities, find_parsers_with_capability
   - Responsibilities: Capability persistence, capability matrix queries

3. **ParserVersionManager** - Manage parser versions with deprecation
   - File: `docs/primitives/ol/ParserVersionManager.md` (~900 lines)
   - Methods: create_version, mark_deprecated, get_compatibility_matrix
   - Responsibilities: Semantic versioning, deprecation tracking, migration guides

4. **ParserSelector** - Auto-select best parser for file
   - File: `docs/primitives/ol/ParserSelector.md` (~1,000 lines)
   - Methods: select_parser, rank_parsers, suggest_parsers
   - Responsibilities: Confidence scoring, pattern matching, parser ranking

**Interaction Layer (IL) - 3 new components:**

5. **ParserSelectorDialog** - Modal dialog for selecting parser
   - File: `docs/primitives/il/ParserSelectorDialog.md` (~1,100 lines)
   - Features: Parser list with capabilities, confidence badges, version selector
   - Responsibilities: Manual parser selection, alternative parser display

6. **ParserCapabilitiesCard** - Display parser capabilities card
   - File: `docs/primitives/il/ParserCapabilitiesCard.md` (~950 lines)
   - Features: Capability list with confidence badges, version info, supported formats
   - Responsibilities: Capability visualization, tooltip/card display

7. **ParserVersionDropdown** - Dropdown for selecting parser version
   - File: `docs/primitives/il/ParserVersionDropdown.md` (~850 lines)
   - Features: Version list with deprecation warnings, breaking changes, migration guide link
   - Responsibilities: Version selection, deprecation warning display

**Schemas - 3 new:**

8. **parser-registration.schema.json** - Parser registration record
9. **parser-capability.schema.json** - Capability definition
10. **parser-version.schema.json** - Version record with deprecation

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **1.1 Document Ingestion** - Files must be uploaded before parser selection
- **1.2 Schema Validation** - Parser output schemas must be registered
- **3.1 Unit System** - Parser capabilities may reference unit types (e.g., amount with currency)

**Used By:**
- **1.3 Normalization** - Parsing uses selected parser to extract fields
- **2.1 Transaction List** - Shows which parser was used for each file
- **2.3 Finance Dashboard** - Parser success rate metrics

**Data Flow:**
```
File Uploaded (1.1)
  â†“
ParserSelector queries ParserRegistry (3.7)
  â†“
ParserSelector matches filename pattern (3.7)
  â†“
Parser selected with confidence score (3.7)
  â†“
File queued for parsing with parser_id (1.1)
  â†“
Parser executes (domain-specific)
  â†“
Parsed output validated against schema (1.2)
  â†“
Normalized records created (1.3)
```

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Service Registry + Capability Discovery + Version Management**

This pattern applies to **any domain with pluggable services**:

**Finance:**
- Service: Document parsers (PDF, CSV, XLSX)
- Capabilities: Extractable fields (date, amount, merchant, account)
- Versioning: Parser versions with breaking changes (v1 â†’ v2 â†’ v3)
- Use Case: Auto-select parser for bank statement upload

**Healthcare:**
- Service: Protocol handlers (HL7 v2, HL7 v3, FHIR, DICOM)
- Capabilities: Message types (ADT, ORU, ORM), FHIR resources (Patient, Observation)
- Versioning: Protocol versions (HL7 v2.3 â†’ v2.5 â†’ v2.8, FHIR R4 â†’ R5)
- Use Case: Auto-select protocol handler for incoming HL7 message

**Legal:**
- Service: Document parsers (court filings, contracts, briefs)
- Capabilities: Extractable fields (case number, jurisdiction, filing date, parties)
- Versioning: Parser versions for different court jurisdictions
- Use Case: Auto-select parser for uploaded legal document

**Research:**
- Service: Citation parsers (BibTeX, RIS, EndNote, CSL JSON)
- Capabilities: Citation fields (author, title, year, journal, DOI)
- Versioning: Citation format versions (BibTeX 0.99 â†’ 1.0, CSL 1.0 â†’ 1.1)
- Use Case: Auto-select citation parser for imported bibliography

**E-commerce:**
- Service: EDI parsers (X12, EDIFACT, XML, JSON)
- Capabilities: Document types (Invoice, Purchase Order, Shipment Notice)
- Versioning: EDI standard versions (X12 4010 â†’ 5010 â†’ 6020)
- Use Case: Auto-select EDI parser for incoming B2B transaction

**Microservices:**
- Service: API endpoints (REST, GraphQL, gRPC)
- Capabilities: Operations (CRUD, search, aggregate), data formats (JSON, Protobuf)
- Versioning: API versions (v1 â†’ v2 â†’ v3) with deprecation
- Use Case: Service discovery and routing based on client requirements

**Key Abstraction:**
```python
class ServiceRegistry[TService, TCapability]:
    """
    Universal pattern for service registration and discovery.

    Generic enough to apply across:
    - Finance: Parser registry (PDF â†’ BofA parser v2)
    - Healthcare: Protocol handler registry (HL7 â†’ parser v3)
    - Legal: Document parser registry (court filing â†’ parser v1)
    - Research: Citation parser registry (BibTeX â†’ parser v2)
    - E-commerce: EDI parser registry (X12 â†’ parser v4010)
    - Microservices: Service discovery (API â†’ endpoint v1.2)
    """
    services: List[TService]  # Registered services with metadata
    capability_store: CapabilityStore[TCapability]  # Service capabilities
    version_manager: VersionManager[TService]  # Version tracking
    selector: ServiceSelector[TService]  # Auto-selection logic
```

---

### 14. Pattern Abstraction

**Pattern Name:** Service Registry + Capability Discovery + Version Management

**Problem Statement:**
Systems need to discover and select the most appropriate service (parser, handler, API endpoint) based on input characteristics (file type, protocol, data format) and required capabilities, while managing service versions and deprecation over time.

**Solution Architecture:**

1. **Service Registration** - Services register with metadata (name, version, supported inputs, capabilities)
2. **Capability Tracking** - Track what each service can do (fields extracted, operations supported)
3. **Version Management** - Semantic versioning with deprecation warnings and migration guides
4. **Auto-Selection** - Automatically select best service based on input metadata and confidence scoring
5. **Manual Override** - Allow users to override auto-selection with ranked alternatives

**Components:**
- **ServiceRegistry<TService>** - Register and query services
- **CapabilityStore<TCapability>** - Track service capabilities
- **VersionManager<TService>** - Manage versions with deprecation
- **ServiceSelector<TService>** - Auto-select service with confidence scoring

**When to Use:**
- âœ… Multiple services that handle similar inputs (parsers, handlers, APIs)
- âœ… Services have different capabilities (not all services do the same thing)
- âœ… Services evolve over time (versioning required)
- âœ… Need automatic service discovery (avoid hardcoding service selection)
- âœ… User override required (auto-selection isn't always perfect)
- âŒ Single service (no need for registry)
- âŒ Services don't evolve (versioning unnecessary)
- âŒ No capability differences (all services equivalent)

**Generic Implementation:**

```python
class ServiceRegistry[TService]:
    def register(self, service: TService, metadata: ServiceMetadata) -> None:
        """Register service with metadata (name, version, capabilities)."""

    def find_by_criteria(self, criteria: ServiceCriteria) -> List[TService]:
        """Find services matching criteria (input type, required capabilities)."""

class CapabilityMatcher[TRequirement, TCapability]:
    def match(self, requirements: List[TRequirement],
              service_capabilities: List[TCapability]) -> float:
        """Return confidence score [0.0, 1.0] for how well service matches requirements."""

class VersionManager[TService]:
    def get_latest(self, service_id: str) -> str:
        """Get latest non-deprecated version."""

    def check_deprecation(self, service_id: str, version: str) -> DeprecationInfo:
        """Check if version deprecated and return sunset date, breaking changes."""

class ServiceSelector[TService]:
    def select(self, input_metadata: InputMetadata,
               preferences: Optional[UserPreferences] = None) -> ServiceSelection:
        """Auto-select best service with confidence score and alternatives."""
```

**Universal Applicability Examples:**

| Domain | Service Type | Selection Criteria | Capabilities |
|--------|--------------|-------------------|--------------|
| Finance | PDF Parser | Filename pattern, file type | date, amount, merchant, account |
| Healthcare | HL7 Handler | Message type (ADT/ORU), version | parse ADT, validate ORU, transform to FHIR |
| Legal | Document Parser | Document type, jurisdiction | extract case #, parties, filing date |
| Research | Citation Parser | File extension (.bib/.ris) | author, title, year, DOI, journal |
| E-commerce | EDI Parser | EDI standard (X12/EDIFACT) | invoice, PO, shipment notice |
| Microservices | API Endpoint | Operation required, data format | CRUD, search, aggregate |
| Plugins | Plugin | File extension, MIME type | edit, view, export, convert |

---

### 15. MÃ©tricas de Madurez

**Coverage Metrics:**
- Number of registered parsers per file type (target: â‰¥2 per supported type)
- % of uploaded files with auto-selected parser (target: >85%)
- % of files with parser confidence â‰¥ 0.7 (target: >80%)

**Quality Metrics:**
- Auto-selection accuracy (% where user doesn't override, target: >90%)
- Parser version adoption rate (% using latest version, target: >70%)
- Deprecated version usage (% using deprecated versions, target: <10%)

**Performance Metrics:**
- Parser registry query latency (target: <50ms p95)
- Auto-select latency (target: <100ms p95)
- Capability matrix query latency (target: <80ms p95)

**User Engagement:**
- % users who manually override auto-selection (target: <15%)
- % admins who register custom parsers (target: >5%)
- Avg parser selections per user per month (target: >20)

**Version Health:**
- Number of active versions per parser (target: 2-3, not >5)
- Avg time between version releases (target: 60-90 days)
- % parsers with sunset dates defined (target: >90% for deprecated versions)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All operations require valid bearer token
- Parser registration requires admin role (RBAC: `parser:admin`)
- Parser queries are public (all authenticated users)
- Version deprecation requires admin role

**Input Validation:**
- Parser name: Pattern validation, length limits (prevent XSS)
- Version: Semver regex validation `^[0-9]+\.[0-9]+\.[0-9]+$`
- Filename patterns: Regex validation (prevent ReDoS attacks - limit complexity)
- Capabilities: Enum validation (only known field types allowed)
- File metadata: Sanitize filename (prevent path traversal)

**Regex Injection Prevention:**
- Filename patterns: Validate regex complexity before compilation
- Maximum regex length: 500 characters
- Forbidden patterns: `.*.*.*` (catastrophic backtracking), `(.+)*` (exponential time)
- Test regex on empty string, short string, long string (10KB) before registration

**SQL Injection Prevention:**
- Use parameterized queries for all database operations
- Example: `SELECT * FROM parser_registrations WHERE parser_id = ? AND file_type = ?`

**Trust Construction Elements:**
- **Version immutability:** Once registered, parser version cannot be changed (only deprecated)
- **Audit trail:** All parser registrations, deprecations logged with admin_id + timestamp
- **Confidence transparency:** All auto-selections logged with reason and confidence score
- **User override tracking:** All manual selections logged for accuracy measurement
- **Rate limiting:** Register parser: 10 per hour, Query registry: 1000 per minute

**Data Privacy:**
- Filename patterns may contain sensitive patterns (e.g., specific client names)
- Do not log actual filenames in external systems (log file_id only)
- Redact PII in error messages

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `GET /api/parsers?file_type=pdf` (list): <50ms
- `GET /api/parsers/{parser_id}` (get): <30ms
- `POST /api/parsers/auto-select` (select): <100ms
- `POST /api/parsers` (register): <200ms
- `PATCH /api/parsers/{id}/versions/{v}/deprecate` (deprecate): <150ms

**Scalability:**
- Parsers per file type: 100 (typical), 500 (max)
- Versions per parser: 10 (typical), 50 (max)
- Capabilities per parser: 20 (typical), 100 (max)
- Concurrent auto-select requests: 1000/sec (target)

**Database Indexes:**
```sql
-- Parser registrations
CREATE INDEX idx_parsers_file_type ON parser_registrations(file_type, deprecated);
CREATE INDEX idx_parsers_version ON parser_registrations(parser_id, version);
CREATE INDEX idx_parsers_name ON parser_registrations(LOWER(name));

-- Parser capabilities
CREATE INDEX idx_capabilities_parser ON parser_capabilities(parser_id, capability_name);
CREATE INDEX idx_capabilities_name ON parser_capabilities(capability_name, extraction_confidence);

-- Parser versions
CREATE INDEX idx_versions_parser ON parser_versions(parser_id, version, deprecated);
CREATE INDEX idx_versions_sunset ON parser_versions(deprecated, sunset_date);
```

**Caching Strategy:**
- Cache parser list per file type (TTL: 1 hour, invalidate on register)
- Cache parser capabilities (TTL: 1 hour, invalidate on capability update)
- Cache version compatibility matrix (TTL: 4 hours, rarely changes)
- Cache compiled regex patterns (TTL: 24 hours, memory limit: 100 patterns)

**Background Jobs:**
- **Daily:** Check for parsers reaching sunset date, send deprecation warnings
- **Weekly:** Analyze parser selection accuracy (user override rate)
- **Monthly:** Archive parser versions older than 1 year (soft delete)

---

### 18. Observability

**Metrics:**
```
parsers.registered.count (counter, labels: file_type)
parsers.auto_selected.count (counter, labels: parser_id, confidence_bucket)
parsers.manually_selected.count (counter, labels: parser_id, reason)
parsers.version_deprecated.count (counter, labels: parser_id, version)
parser_selection.latency (histogram, labels: file_type)
parser_selection.confidence (histogram, labels: parser_id)
auto_selection.accuracy (gauge) # % where user doesn't override
```

**Structured Logs:**
- All parser registrations (create, update, deprecate)
- All auto-selection decisions (confidence, reason, alternatives)
- All manual overrides (original parser, selected parser, user_id)
- All deprecation warnings shown to users

**Dashboards:**
- Parser selection distribution (top 10 parsers by usage)
- Auto-selection confidence distribution (histogram)
- Manual override rate (trend over time)
- Deprecated version usage (count by parser, version)
- Parser capability coverage matrix (heatmap)

**Alerts:**
- Auto-selection accuracy drops below 80% (investigate pattern conflicts)
- Parser registration fails >5 times in 1 hour (investigate validation issues)
- Deprecated version usage >20% (users not upgrading, send reminders)
- Parser selection latency >200ms (investigate regex complexity or DB performance)

**Tracing:**
- Trace auto-selection flow: file upload â†’ parser query â†’ pattern match â†’ confidence scoring â†’ selection
- Include file_id, file_name, parser_id, confidence, reason in trace

---

### 19. Testing Strategy

**Unit Tests:**

```python
# ParserRegistry tests
def test_register_parser():
    parser = registry.register(
        name="Scotia Bank CSV Parser",
        version="1.0.0",
        file_types=["csv"],
        capabilities=["date", "amount", "merchant", "account"],
        filename_patterns=[".*Scotia.*\\.csv"]
    )
    assert parser.parser_id == "parser_scotia_bank_csv_parser"
    assert parser.deprecated == False

def test_duplicate_parser_name():
    registry.register(name="BofA PDF Parser", version="1.0.0", ...)
    with pytest.raises(DuplicateParserError):
        registry.register(name="BofA PDF Parser", version="2.0.0", ...)

def test_invalid_version_format():
    with pytest.raises(InvalidVersionError):
        registry.register(name="Test Parser", version="1.0", ...)  # Missing patch

# ParserSelector tests
def test_auto_select_by_filename_pattern():
    file_metadata = FileMetadata(
        file_name="BofA_Statement_Nov2024.pdf",
        file_type="pdf"
    )
    selection = selector.select_parser(file_metadata)
    assert selection.selected_parser.parser_id == "parser_bofa_pdf"
    assert selection.confidence >= 0.95

def test_auto_select_no_match():
    file_metadata = FileMetadata(
        file_name="unknown_bank.pdf",
        file_type="pdf"
    )
    selection = selector.select_parser(file_metadata)
    assert selection.selected_parser.parser_id == "parser_generic_pdf"
    assert selection.confidence < 0.5

def test_auto_select_with_user_preference():
    file_metadata = FileMetadata(file_name="statement.pdf", file_type="pdf")
    preferences = UserPreferences(preferred_parser_ids=["parser_chase_pdf"])
    selection = selector.select_parser(file_metadata, preferences)
    assert selection.selected_parser.parser_id == "parser_chase_pdf"
    assert selection.confidence > 0.6  # Boosted by preference

# ParserCapabilityStore tests
def test_set_capabilities():
    capabilities = [
        ParserCapability(capability_name="date", field_type="date", extraction_confidence=0.98),
        ParserCapability(capability_name="amount", field_type="number", extraction_confidence=0.98)
    ]
    store.set_capabilities("parser_bofa_pdf", capabilities)
    retrieved = store.get_capabilities("parser_bofa_pdf")
    assert len(retrieved) == 2
    assert retrieved[0].capability_name == "date"

def test_find_parsers_with_capability():
    parsers = store.find_parsers_with_capability("category", min_confidence=0.8)
    assert "parser_advanced_ml" in parsers
    assert "parser_basic" not in parsers  # Doesn't support category

# ParserVersionManager tests
def test_mark_deprecated():
    manager.mark_deprecated(
        parser_id="parser_bofa_pdf",
        version="1.5.0",
        sunset_date=date(2024, 12, 31),
        migration_guide_url="https://docs.example.com/migration"
    )
    version = manager.get_version("parser_bofa_pdf", "1.5.0")
    assert version.deprecated == True
    assert version.sunset_date == date(2024, 12, 31)

def test_get_latest_version():
    # Versions: 1.5.0 (deprecated), 2.0.0, 2.1.0
    latest = manager.get_latest_version("parser_bofa_pdf")
    assert latest == "2.1.0"
```

**Integration Tests:**

```python
def test_end_to_end_auto_selection():
    # 1. Register parser
    response = client.post("/api/parsers", json={
        "name": "Test Bank PDF Parser",
        "version": "1.0.0",
        "file_types": ["pdf"],
        "capabilities": ["date", "amount", "merchant"],
        "filename_patterns": [".*TestBank.*\\.pdf"]
    }, headers={"Authorization": f"Bearer {admin_token}"})
    assert response.status_code == 201
    parser_id = response.json()["parser_id"]

    # 2. Upload file with matching filename
    file_metadata = {
        "file_name": "TestBank_Statement_Nov2024.pdf",
        "file_type": "pdf",
        "file_size": 100000
    }

    # 3. Auto-select parser
    response = client.post("/api/parsers/auto-select", json=file_metadata)
    assert response.status_code == 200
    selection = response.json()
    assert selection["selected_parser"]["parser_id"] == parser_id
    assert selection["selected_parser"]["confidence"] >= 0.9

def test_manual_override():
    # 1. Auto-select returns wrong parser
    file_metadata = {"file_name": "ambiguous.pdf", "file_type": "pdf"}
    response = client.post("/api/parsers/auto-select", json=file_metadata)
    auto_selected = response.json()["selected_parser"]["parser_id"]

    # 2. User manually selects different parser
    correct_parser_id = "parser_chase_pdf"

    # 3. Verify override logged
    # (Would check logs in real implementation)
```

**Multi-Domain Tests:**
- Finance: Register BofA PDF parser, auto-select for "BofA_Statement.pdf"
- Healthcare: Register HL7 v2.5 parser, auto-select for ADT message type
- Legal: Register court filing parser, auto-select for "CA_court_filing.pdf"
- Research: Register BibTeX parser, auto-select for "references.bib"

---

### 20. Operations Runbook

**Deployment:**

1. **Database Migrations:**
```sql
-- Create parser_registrations table
CREATE TABLE parser_registrations (
    parser_id VARCHAR(100) PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    version VARCHAR(20) NOT NULL,
    file_types JSONB NOT NULL,  -- ["pdf", "csv"]
    capabilities JSONB NOT NULL,  -- ["date", "amount", "merchant"]
    filename_patterns JSONB NOT NULL,  -- [".*BofA.*\\.pdf"]
    deprecated BOOLEAN DEFAULT FALSE,
    sunset_date DATE,
    description TEXT,
    registered_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(parser_id, version)
);

-- Create parser_capabilities table
CREATE TABLE parser_capabilities (
    capability_id SERIAL PRIMARY KEY,
    parser_id VARCHAR(100) NOT NULL,
    capability_name VARCHAR(50) NOT NULL,
    field_type VARCHAR(20) NOT NULL,  -- string, number, date, boolean, array
    extraction_confidence DECIMAL(3,2) NOT NULL CHECK (extraction_confidence >= 0 AND extraction_confidence <= 1),
    required_for_success BOOLEAN DEFAULT FALSE,
    notes TEXT,
    FOREIGN KEY (parser_id) REFERENCES parser_registrations(parser_id),
    UNIQUE(parser_id, capability_name)
);

-- Create parser_versions table
CREATE TABLE parser_versions (
    version_id SERIAL PRIMARY KEY,
    parser_id VARCHAR(100) NOT NULL,
    version VARCHAR(20) NOT NULL,
    released_at TIMESTAMP DEFAULT NOW(),
    deprecated BOOLEAN DEFAULT FALSE,
    sunset_date DATE,
    breaking_changes JSONB,  -- ["Merchant field renamed to counterparty"]
    migration_guide_url TEXT,
    compatible_with JSONB,  -- ["observation-transaction-v1", "observation-transaction-v2"]
    FOREIGN KEY (parser_id) REFERENCES parser_registrations(parser_id),
    UNIQUE(parser_id, version)
);
```

2. **Seed System Parsers:**
```bash
# Register default parsers
python /app/scripts/seed_parsers.py --file=default_parsers.json

# Example default_parsers.json:
{
  "parsers": [
    {
      "name": "Bank of America PDF Parser",
      "version": "2.1.0",
      "file_types": ["pdf"],
      "capabilities": ["date", "amount", "merchant", "account", "balance"],
      "filename_patterns": [".*BofA.*\\.pdf", ".*Bank of America.*\\.pdf"]
    },
    {
      "name": "Generic CSV Parser",
      "version": "1.0.0",
      "file_types": ["csv"],
      "capabilities": ["date", "amount", "merchant"],
      "filename_patterns": [".*\\.csv"]
    }
  ]
}
```

**Monitoring:**

- **Health Check:** `GET /api/health/parsers` - Returns OK if ParserRegistry can query
- **Metric Alerts:**
  - Auto-selection accuracy < 80% â†’ investigate pattern conflicts
  - Parser registration failures > 5 per hour â†’ validation issues
  - Deprecated version usage > 20% â†’ send upgrade reminders
  - Parser selection latency > 200ms â†’ DB performance or regex complexity issue

**Common Issues:**

**Issue 1: Auto-selection not working**
- **Symptom:** All files get generic parser instead of specific parser
- **Debug:**
  1. Check if filename matches any registered patterns
  2. Verify parser not deprecated
  3. Check confidence threshold (default: 0.7)
  4. Test regex pattern manually: `python -c "import re; print(re.match(r'.*BofA.*\.pdf', 'BofA_Statement.pdf'))"`
- **Fix:** Adjust filename_patterns or lower confidence threshold

**Issue 2: Parser registration fails with regex error**
- **Symptom:** `POST /api/parsers` returns 400 "Invalid filename pattern"
- **Debug:**
  1. Check regex complexity (avoid catastrophic backtracking: `.*.*.*`)
  2. Verify regex compiles: `python -c "import re; re.compile(r'pattern')"`
  3. Check pattern length (<500 chars)
- **Fix:** Simplify regex pattern, avoid nested quantifiers

**Issue 3: Users not upgrading from deprecated version**
- **Symptom:** >30% of files use deprecated parser version
- **Debug:**
  1. Check if deprecation warning shown in UI
  2. Verify sunset_date is set and in future
  3. Check if migration guide URL accessible
- **Fix:** Send email notification, show banner in UI, enforce upgrade after sunset date

**Issue 4: Parser capability matrix out of sync**
- **Symptom:** Parser shows wrong capabilities in UI
- **Debug:**
  1. Check parser_capabilities table for parser_id
  2. Verify capability_name matches known fields
  3. Check cache expiration (TTL: 1 hour)
- **Fix:** Clear cache: `redis-cli DEL parser_capabilities:{parser_id}`

**Incident Response:**

```bash
# Query all parsers for file type
curl -X GET /api/parsers?file_type=pdf \
  -H "Authorization: Bearer TOKEN"

# Force select parser for file
curl -X POST /api/files/{file_id}/assign-parser \
  -H "Authorization: Bearer TOKEN" \
  -d '{"parser_id": "parser_bofa_pdf", "version": "2.1.0"}'

# Deprecate parser version immediately
curl -X PATCH /api/parsers/{parser_id}/versions/{version}/deprecate \
  -H "Authorization: Bearer ADMIN_TOKEN" \
  -d '{"sunset_date": "2024-12-31", "migration_guide_url": "https://docs.example.com/migration"}'

# Check parser selection accuracy
psql -d finance_db -c "
SELECT parser_id,
       COUNT(*) as total_selections,
       SUM(CASE WHEN user_overridden = false THEN 1 ELSE 0 END) as auto_accepted,
       ROUND(100.0 * SUM(CASE WHEN user_overridden = false THEN 1 ELSE 0 END) / COUNT(*), 2) as accuracy_pct
FROM file_parser_selections
WHERE selected_at >= NOW() - INTERVAL '30 days'
GROUP BY parser_id
ORDER BY total_selections DESC;
"
```

---

## ğŸ¯ Summary

Vertical 3.7 delivers a **service discovery and capability matching system** with:

âœ… **4 OL Primitives** (ParserRegistry, ParserCapabilityStore, ParserVersionManager, ParserSelector)
âœ… **3 IL Components** (ParserSelectorDialog, ParserCapabilitiesCard, ParserVersionDropdown)
âœ… **3 Schemas** (parser-registration, parser-capability, parser-version)
âœ… **20 Complete Sections** (Product, Machinery, Cross-Cutting)
âœ… **Multi-Domain Pattern** (Finance â†’ PDF/CSV parsers, Healthcare â†’ HL7/FHIR parsers, Legal â†’ Document parsers, Research â†’ Citation parsers, E-commerce â†’ EDI parsers, Microservices â†’ Service discovery)

**Finance Instantiation:**
- Parsers: BofA PDF v2.1.0, Chase PDF v1.5.3, Apple Card CSV v1.2.0
- Capabilities: date, amount, merchant, account, balance, memo
- Auto-selection: Filename pattern + file type matching
- Versioning: Semantic versioning with deprecation warnings

**Universal Pattern: Service Registry + Capability Discovery + Version Management**
- Service registration with metadata (name, version, supported inputs, capabilities)
- Capability tracking (what each service can do)
- Version management (semantic versioning, deprecation, migration guides)
- Auto-selection (confidence-based ranking with manual override)

**Next:** 3.8 [Next vertical in sequence]
