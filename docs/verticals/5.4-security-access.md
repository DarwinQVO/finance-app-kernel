# Vertical 5.4: Security & Access (PII, Roles, Encryption, Audit)

**Status:** ✅ Complete
**Version:** 1.0.0
**Last Updated:** 2025-10-25

---

## Table of Contents

1. [Overview](#1-overview)
2. [Core Capabilities](#2-core-capabilities)
3. [PII Masking System](#3-pii-masking-system)
4. [Role-Based Access Control (RBAC)](#4-role-based-access-control-rbac)
5. [Data Encryption](#5-data-encryption)
6. [Audit Logging](#6-audit-logging)
7. [Primitive Layer (OL)](#7-primitive-layer-ol)
8. [Interface Layer (IL)](#8-interface-layer-il)
9. [Data Schemas](#9-data-schemas)
10. [Security Workflows](#10-security-workflows)
11. [Performance Targets](#11-performance-targets)
12. [Edge Cases](#12-edge-cases)
13. [Multi-Domain Applicability](#13-multi-domain-applicability)
14. [Testing Strategy](#14-testing-strategy)
15. [Observability](#15-observability)
16. [Deployment](#16-deployment)
17. [Migration Path](#17-migration-path)
18. [Future Enhancements](#18-future-enhancements)
19. [Cross-Cutting Concerns](#19-cross-cutting-concerns)
20. [Architectural Decisions](#20-architectural-decisions)

---

## 1. Overview

**Purpose:** Vertical 5.4 provides comprehensive security controls for the Truth Construction Primitives system, including PII masking, role-based access control, data encryption, and audit logging. This vertical ensures compliance with regulations (GDPR, HIPAA, SOX) while maintaining system usability and performance.

**Key Features:**
- **PII Masking:** Automatically detect and mask sensitive fields (SSN, account numbers, email, phone, IP addresses)
- **RBAC:** Multi-level permission system (owner, editor, viewer, accountant_readonly, auditor)
- **Encryption:** AES-256-GCM encryption at rest, TLS 1.3 in transit, key rotation every 90 days
- **Audit Logging:** Immutable audit trail for all data access and modifications, 7-year retention

**Multi-Domain Pattern:**
- **Finance:** Mask account numbers, SSN, routing numbers; SOX compliance
- **Healthcare:** Mask patient IDs, MRN, PHI; HIPAA compliance
- **Legal:** Mask case numbers, client IDs; attorney-client privilege
- **HR:** Mask employee IDs, salary data, SSN; privacy regulations
- **E-commerce:** Mask credit card numbers, customer PII; PCI-DSS
- **Government:** Mask citizen IDs, classified data; FISMA compliance
- **SaaS:** Mask API keys, user tokens; SOC 2 compliance

**Architectural Philosophy:**
- **Defense in Depth:** Multiple security layers (masking + encryption + access control + audit)
- **Least Privilege:** Users granted minimum permissions required
- **Immutable Audit Trail:** All security events logged permanently, tamper-proof
- **Zero Trust:** Verify every access request, never assume trust
- **Fail Secure:** Security failures default to deny access

**Performance Targets:**
- PII masking: <5ms p95 per observation (regex + rule-based detection)
- Access control check: <2ms p95 per request (cached permissions)
- Encryption/decryption: <10ms p95 per document
- Audit log write: <8ms p95 (async, batched writes)
- Key rotation: Zero downtime, <30s cutover

---

## 2. Core Capabilities

**2.1 Automatic PII Detection**

The system automatically detects and masks PII in extracted observations using rule-based and pattern-based detection:

```typescript
const maskedObservation = await PIIMasker.maskObservation({
  observation_id: "obs_abc123",
  fields: {
    merchant: "STARBUCKS #12345",
    account_number: "****1234",  // Original: "1234567812345678"
    email: "j***@example.com",    // Original: "john@example.com"
    ssn: "***-**-6789"            // Original: "123-45-6789"
  },
  mask_rules: ["account_number", "ssn", "email", "phone", "ip_address"]
});

// Returns:
// {
//   observation_id: "obs_abc123",
//   masked_fields: ["account_number", "email", "ssn"],
//   pii_detected: true,
//   mask_applied_at: "2025-10-25T10:00:00Z"
// }
```

**2.2 Role-Based Access Control**

Multi-level permission system with fine-grained control:

```typescript
const accessGranted = await AccessControl.checkPermission({
  user_id: "usr_jane",
  resource_type: "observation",
  resource_id: "obs_abc123",
  action: "read",
  context: {
    upload_id: "upl_xyz789",
    tenant_id: "tenant_acme"
  }
});

// Returns: { granted: true, role: "viewer", masked_fields: ["ssn", "account_number"] }
```

**5 Standard Roles:**
1. **Owner:** Full access, manage users, export data, delete documents
2. **Editor:** Create/update observations, run parsers, view audit logs
3. **Viewer:** Read-only access to all data, PII fields masked
4. **Accountant (Read-Only):** Read financial data, PII fully masked, no delete/export
5. **Auditor:** Read audit logs only, no data access

**2.3 Data Encryption**

AES-256-GCM encryption at rest, TLS 1.3 in transit:

```typescript
const encrypted = await EncryptionEngine.encryptDocument({
  document_id: "doc_abc123",
  content: pdfBuffer,
  key_version: "v2025.10.25",
  metadata: { upload_id: "upl_xyz789" }
});

// Encrypted storage format:
// {
//   ciphertext: Buffer,
//   iv: Buffer,           // Initialization vector (12 bytes)
//   auth_tag: Buffer,     // Authentication tag (16 bytes)
//   key_version: "v2025.10.25",
//   algorithm: "aes-256-gcm"
// }
```

**Key Management:**
- Master key stored in AWS KMS / GCP Cloud KMS / Azure Key Vault
- Data encryption keys (DEKs) derived using envelope encryption
- Automatic key rotation every 90 days
- Zero downtime rotation (dual-write to old+new keys during cutover)

**2.4 Comprehensive Audit Logging**

Immutable audit trail for compliance:

```typescript
await AuditLogger.logEvent({
  event_type: "data_access",
  user_id: "usr_jane",
  action: "read",
  resource_type: "observation",
  resource_id: "obs_abc123",
  timestamp: "2025-10-25T10:00:00Z",
  ip_address: "192.168.1.100",
  user_agent: "Mozilla/5.0...",
  result: "success",
  metadata: {
    masked_fields: ["ssn", "account_number"],
    reason: "Financial report generation"
  }
});
```

**Audit Events Tracked:**
- Data access (read, list queries)
- Data modifications (create, update, delete)
- User actions (login, logout, permission changes)
- Security events (failed access, suspicious activity)
- System events (key rotation, encryption failures)

**Retention:** 7 years (configurable), append-only storage, cryptographic integrity checks

---

## 3. PII Masking System

**3.1 Detection Rules**

The system uses a combination of **pattern matching** (regex) and **semantic rules** (field names) to detect PII:

**Pattern-Based Detection:**

| PII Type | Regex Pattern | Example Original | Example Masked |
|----------|---------------|------------------|----------------|
| SSN | `\b\d{3}-\d{2}-\d{4}\b` | 123-45-6789 | ***-**-6789 |
| Credit Card | `\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b` | 1234 5678 9012 3456 | **** **** **** 3456 |
| Account Number | `\b\d{10,18}\b` | 1234567812345678 | ****1234 |
| Email | `\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z\|a-z]{2,}\b` | john@example.com | j***@example.com |
| Phone | `\b(\+\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}\b` | (555) 123-4567 | (***) ***-4567 |
| IP Address | `\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b` | 192.168.1.100 | ***.***.***.100 |

**Semantic Rules (Field Names):**
- Fields named `ssn`, `social_security_number`, `tax_id` → Always mask
- Fields named `account_number`, `account_id`, `routing_number` → Always mask
- Fields named `email`, `email_address`, `contact_email` → Always mask
- Fields named `phone`, `phone_number`, `mobile`, `cell` → Always mask
- Fields named `ip_address`, `ip`, `client_ip` → Always mask

**3.2 Masking Strategies**

**Strategy 1: Partial Masking (Last 4 Digits)**
- Used for: Account numbers, credit cards, phone numbers
- Example: `1234567812345678` → `****1234`
- Rationale: Allows users to identify accounts while protecting full number

**Strategy 2: Full Masking (All Digits)**
- Used for: SSN (except last 4), IP addresses (except last octet)
- Example: `123-45-6789` → `***-**-6789`
- Rationale: Maximum privacy for highly sensitive fields

**Strategy 3: Email Obfuscation**
- Used for: Email addresses
- Example: `john.doe@example.com` → `j***.d***@example.com`
- Rationale: Shows domain (often needed for support) while hiding identity

**Strategy 4: Tokenization (Optional)**
- Used for: Fields requiring reversibility (e.g., for authorized users)
- Example: `123-45-6789` → `TOKEN_abc123def456`
- Rationale: Allows authorized users to retrieve original value via separate secure service

**3.3 Masking API**

```typescript
interface PIIMasker {
  /**
   * Mask PII fields in a single observation
   * Performance: <5ms p95
   */
  maskObservation(params: {
    observation_id: string;
    fields: Record<string, any>;
    mask_rules: string[];          // e.g., ["account_number", "ssn"]
    strategy?: "partial" | "full" | "tokenize";
  }): Promise<MaskedObservation>;

  /**
   * Batch mask multiple observations
   * Performance: <50ms p95 for 100 observations
   */
  maskBatch(params: {
    observations: Observation[];
    mask_rules: string[];
  }): Promise<MaskedObservation[]>;

  /**
   * Detect PII in unstructured text
   * Performance: <20ms p95 for 1KB text
   */
  detectPII(params: {
    text: string;
    detection_types: PIIType[];    // e.g., ["ssn", "email", "phone"]
  }): Promise<PIIDetectionResult>;

  /**
   * Unmask PII (requires elevated permissions)
   * Performance: <10ms p95
   */
  unmaskObservation(params: {
    observation_id: string;
    user_id: string;
    reason: string;                // Audit trail: why unmask?
  }): Promise<UnmaskedObservation>;
}

type PIIType = "ssn" | "credit_card" | "account_number" | "email" | "phone" | "ip_address";

interface MaskedObservation {
  observation_id: string;
  masked_fields: string[];         // Which fields were masked
  pii_detected: boolean;
  mask_applied_at: string;         // ISO 8601 timestamp
  mask_strategy: "partial" | "full" | "tokenize";
}

interface PIIDetectionResult {
  pii_found: boolean;
  detections: Array<{
    type: PIIType;
    value: string;                 // Original value (only returned to authorized users)
    masked_value: string;          // Masked version
    start_index: number;
    end_index: number;
    confidence: number;            // 0-1, detection confidence
  }>;
}
```

**3.4 Masking Configuration**

Users can configure masking rules per tenant:

```json
{
  "tenant_id": "tenant_acme",
  "masking_config": {
    "enabled": true,
    "default_strategy": "partial",
    "rules": [
      {
        "field_pattern": "account_number",
        "pii_type": "account_number",
        "strategy": "partial",
        "show_last_digits": 4
      },
      {
        "field_pattern": "ssn",
        "pii_type": "ssn",
        "strategy": "full",
        "show_last_digits": 4
      },
      {
        "field_pattern": "email",
        "pii_type": "email",
        "strategy": "email_obfuscate"
      }
    ],
    "exceptions": {
      "roles": ["owner", "auditor"],  // These roles see unmasked data
      "require_reason": true           // Must provide reason for audit
    }
  }
}
```

---

## 4. Role-Based Access Control (RBAC)

**4.1 Permission Model**

The RBAC system uses a **hierarchical permission model** with 5 standard roles:

```
Owner (Full Access)
  ├── Editor (Create/Update/Delete)
  │     └── Viewer (Read-Only)
  ├── Accountant (Read Financial, PII Masked)
  └── Auditor (Audit Logs Only)
```

**Permission Matrix:**

| Action | Owner | Editor | Viewer | Accountant | Auditor |
|--------|-------|--------|--------|------------|---------|
| Upload documents | ✅ | ✅ | ❌ | ❌ | ❌ |
| Run parsers | ✅ | ✅ | ❌ | ❌ | ❌ |
| Read observations | ✅ (unmasked) | ✅ (unmasked) | ✅ (masked) | ✅ (masked) | ❌ |
| Update observations | ✅ | ✅ | ❌ | ❌ | ❌ |
| Delete observations | ✅ | ✅ | ❌ | ❌ | ❌ |
| Export data | ✅ | ✅ | ❌ | ❌ | ❌ |
| View audit logs | ✅ | ✅ | ❌ | ❌ | ✅ |
| Manage users | ✅ | ❌ | ❌ | ❌ | ❌ |
| Configure security | ✅ | ❌ | ❌ | ❌ | ❌ |
| Unmask PII | ✅ (with reason) | ❌ | ❌ | ❌ | ❌ |

**4.2 Access Control API**

```typescript
interface AccessControl {
  /**
   * Check if user has permission for action
   * Performance: <2ms p95 (cached permissions)
   */
  checkPermission(params: {
    user_id: string;
    resource_type: string;         // "observation", "upload", "audit_log"
    resource_id: string;
    action: string;                // "read", "write", "delete", "export"
    context?: Record<string, any>; // Additional context (tenant, upload, etc.)
  }): Promise<AccessResult>;

  /**
   * Assign role to user
   * Performance: <10ms p95
   */
  assignRole(params: {
    user_id: string;
    tenant_id: string;
    role: Role;
    granted_by: string;            // User ID of granter
    expiration?: string;           // Optional expiration date
  }): Promise<RoleAssignment>;

  /**
   * Revoke role from user
   * Performance: <10ms p95
   */
  revokeRole(params: {
    user_id: string;
    tenant_id: string;
    role: Role;
    revoked_by: string;
  }): Promise<void>;

  /**
   * List user's effective permissions
   * Performance: <5ms p95 (cached)
   */
  getUserPermissions(params: {
    user_id: string;
    tenant_id: string;
  }): Promise<Permission[]>;

  /**
   * Bulk check permissions (for list queries)
   * Performance: <20ms p95 for 100 resources
   */
  checkBulkPermissions(params: {
    user_id: string;
    resources: Array<{ type: string; id: string }>;
    action: string;
  }): Promise<Map<string, AccessResult>>;
}

type Role = "owner" | "editor" | "viewer" | "accountant_readonly" | "auditor";

interface AccessResult {
  granted: boolean;
  role: Role;
  masked_fields: string[];         // Which fields should be masked for this user
  reason?: string;                 // If denied, why?
}

interface Permission {
  resource_type: string;
  actions: string[];               // e.g., ["read", "write"]
  conditions?: Record<string, any>; // Optional conditions (e.g., tenant_id match)
}
```

**4.3 Permission Inheritance**

Permissions are inherited hierarchically:

1. **Tenant-Level Role:** User assigned "Editor" role for entire tenant → can edit all observations in tenant
2. **Upload-Level Role:** User assigned "Viewer" role for specific upload → can view only observations from that upload
3. **Resource-Level Role:** User assigned "Owner" role for specific observation → full access to that observation only

**Effective Permission Calculation:**
- User has multiple roles → Most permissive role wins
- Example: User is "Viewer" at tenant level but "Editor" for upload_123 → Can edit observations from upload_123, view-only for others

**4.4 Row-Level Security (RLS)**

Access control enforced at database level using PostgreSQL Row-Level Security:

```sql
-- Example RLS policy: Users can only read observations they have permission for
CREATE POLICY observation_read_policy ON observations
FOR SELECT
USING (
  tenant_id IN (
    SELECT tenant_id FROM user_roles
    WHERE user_id = current_user_id()
    AND role IN ('owner', 'editor', 'viewer', 'accountant_readonly')
  )
  OR
  upload_id IN (
    SELECT upload_id FROM upload_permissions
    WHERE user_id = current_user_id()
  )
);
```

**Benefits:**
- **Defense in Depth:** Even if application logic fails, database enforces access control
- **Performance:** Database-level filtering avoids loading unauthorized data
- **Auditability:** All access patterns visible in query logs

---

## 5. Data Encryption

**5.1 Encryption Architecture**

The system uses **envelope encryption** with three layers:

1. **Master Key (MK):** Stored in AWS KMS / GCP Cloud KMS / Azure Key Vault, never leaves HSM
2. **Data Encryption Key (DEK):** Generated per upload, encrypted by MK, stored with data
3. **Ciphertext:** Actual data encrypted by DEK using AES-256-GCM

**Encryption Flow:**

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Upload Document                                          │
│    User uploads PDF (5 MB)                                  │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Generate DEK                                             │
│    EncryptionEngine.generateDEK()                           │
│    → 256-bit random key (32 bytes)                          │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Encrypt Document                                         │
│    AES-256-GCM(pdf_content, DEK)                            │
│    → Ciphertext + IV + Auth Tag                             │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Encrypt DEK                                              │
│    KMS.encrypt(DEK, master_key_id)                          │
│    → Encrypted DEK (never stored in plaintext)              │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Store                                                    │
│    Storage: { ciphertext, iv, auth_tag, encrypted_dek }    │
└─────────────────────────────────────────────────────────────┘
```

**5.2 Encryption API**

```typescript
interface EncryptionEngine {
  /**
   * Encrypt document
   * Performance: <10ms p95 for 5MB document
   */
  encryptDocument(params: {
    document_id: string;
    content: Buffer;
    key_version?: string;          // Optional: use specific key version
    metadata?: Record<string, any>;
  }): Promise<EncryptedDocument>;

  /**
   * Decrypt document
   * Performance: <10ms p95 for 5MB document
   */
  decryptDocument(params: {
    document_id: string;
    encrypted_data: EncryptedDocument;
  }): Promise<Buffer>;

  /**
   * Rotate encryption keys
   * Performance: <30s cutover (zero downtime)
   */
  rotateKeys(params: {
    tenant_id: string;
    new_key_version: string;
    migration_strategy: "lazy" | "eager"; // Lazy: re-encrypt on access, Eager: re-encrypt all
  }): Promise<KeyRotationResult>;

  /**
   * Generate data encryption key (DEK)
   * Performance: <5ms p95
   */
  generateDEK(): Promise<DEK>;

  /**
   * Encrypt DEK using master key
   * Performance: <20ms p95 (KMS API call)
   */
  encryptDEK(params: {
    dek: DEK;
    master_key_id: string;
  }): Promise<EncryptedDEK>;

  /**
   * Decrypt DEK using master key
   * Performance: <20ms p95 (KMS API call, cached)
   */
  decryptDEK(params: {
    encrypted_dek: EncryptedDEK;
    master_key_id: string;
  }): Promise<DEK>;
}

interface EncryptedDocument {
  ciphertext: Buffer;              // Encrypted data
  iv: Buffer;                      // Initialization vector (12 bytes for GCM)
  auth_tag: Buffer;                // Authentication tag (16 bytes for GCM)
  encrypted_dek: EncryptedDEK;     // DEK encrypted by master key
  key_version: string;             // Which key version was used
  algorithm: "aes-256-gcm";
  created_at: string;
}

interface DEK {
  key: Buffer;                     // 256-bit key (32 bytes)
  version: string;
  created_at: string;
}

interface EncryptedDEK {
  ciphertext: Buffer;              // DEK encrypted by master key
  key_id: string;                  // Master key ID (e.g., AWS KMS key ARN)
  created_at: string;
}

interface KeyRotationResult {
  old_key_version: string;
  new_key_version: string;
  documents_re_encrypted: number;
  duration_ms: number;
  status: "completed" | "in_progress" | "failed";
}
```

**5.3 Key Rotation Strategy**

**Automatic Rotation (90 Days):**
- New master key version generated every 90 days
- Old keys retained for decryption (7-year retention policy)
- Zero downtime: Dual-write to old+new keys during cutover

**Rotation Process:**

```typescript
// Step 1: Generate new key version
const newKeyVersion = await EncryptionEngine.generateMasterKey({
  tenant_id: "tenant_acme",
  version: "v2025.11.25"
});

// Step 2: Lazy re-encryption (on access)
// When document is read:
if (document.key_version !== currentKeyVersion) {
  // Re-encrypt with new key version
  const decrypted = await EncryptionEngine.decryptDocument({
    document_id: doc.id,
    encrypted_data: doc.encrypted_data
  });

  const reencrypted = await EncryptionEngine.encryptDocument({
    document_id: doc.id,
    content: decrypted,
    key_version: currentKeyVersion
  });

  await updateDocument(doc.id, reencrypted);
}

// Step 3: Background eager re-encryption (for documents not accessed)
await EncryptionEngine.rotateKeys({
  tenant_id: "tenant_acme",
  new_key_version: "v2025.11.25",
  migration_strategy: "eager"  // Re-encrypt all documents in background
});
```

**5.4 Encryption at Rest vs. In Transit**

| Layer | Mechanism | Details |
|-------|-----------|---------|
| **At Rest (Storage)** | AES-256-GCM | All documents, observations, audit logs encrypted before storage |
| **In Transit (Network)** | TLS 1.3 | All API requests over HTTPS, certificate pinning |
| **In Memory (Processing)** | Plaintext | Data decrypted in memory for processing (ephemeral) |
| **Backups** | AES-256-GCM | Backup files encrypted with separate backup DEKs |
| **Database** | Transparent Data Encryption (TDE) | PostgreSQL TDE enabled for database files |

---

## 6. Audit Logging

**6.1 Audit Event Types**

The system logs 5 categories of events:

1. **Data Access Events:** User reads/lists observations, uploads, audit logs
2. **Data Modification Events:** User creates/updates/deletes observations, uploads
3. **User Action Events:** User login/logout, role changes, password resets
4. **Security Events:** Failed access attempts, suspicious activity, PII unmask requests
5. **System Events:** Key rotation, encryption failures, parser crashes

**6.2 Audit Log Schema**

Each audit event contains:

```typescript
interface AuditEvent {
  id: string;                      // Unique event ID (uuid)
  event_type: AuditEventType;
  user_id: string;                 // Who performed the action
  action: string;                  // What action (read, write, delete, login, etc.)
  resource_type: string;           // What resource (observation, upload, user, etc.)
  resource_id: string;             // Which specific resource
  timestamp: string;               // When (ISO 8601, UTC - must end with 'Z')
  ip_address: string;              // Client IP address
  user_agent: string;              // Browser/client user agent
  result: "success" | "failure" | "denied";
  error_message?: string;          // If failure/denied, why?
  metadata: Record<string, any>;   // Additional context (masked_fields, reason, etc.)
  tenant_id: string;               // Which tenant
  session_id: string;              // User session ID
  integrity_hash: string;          // SHA-256 hash for tamper detection
}
```

**Timezone Enforcement:**
All `timestamp` fields in audit events **must be UTC** with 'Z' suffix (e.g., "2025-10-25T10:00:00Z"). Schema validation enforces pattern `".*Z$"`. This ensures audit log integrity, compliance (HIPAA, SOX, GDPR), and unambiguous temporal ordering across distributed systems.

```typescript
type AuditEventType =
  | "data_access"
  | "data_modification"
  | "user_action"
  | "security_event"
  | "system_event";
```

**6.3 Audit Logger API**

```typescript
interface AuditLogger {
  /**
   * Log single audit event
   * Performance: <8ms p95 (async, batched writes)
   */
  logEvent(params: AuditEvent): Promise<void>;

  /**
   * Log batch of events (for high-throughput scenarios)
   * Performance: <50ms p95 for 100 events
   */
  logBatch(events: AuditEvent[]): Promise<void>;

  /**
   * Query audit logs (for compliance, investigation)
   * Performance: <100ms p95 for 7-day query
   */
  queryLogs(params: {
    tenant_id: string;
    start_date: string;
    end_date: string;
    filters?: {
      user_id?: string;
      event_type?: AuditEventType;
      resource_type?: string;
      result?: "success" | "failure" | "denied";
    };
    limit?: number;                // Default 100, max 1000
    offset?: number;
  }): Promise<AuditEvent[]>;

  /**
   * Export audit logs (for compliance audits)
   * Performance: <5s for 1-year export (100K events)
   */
  exportLogs(params: {
    tenant_id: string;
    start_date: string;
    end_date: string;
    format: "json" | "csv" | "pdf";
  }): Promise<Buffer>;

  /**
   * Verify log integrity (detect tampering)
   * Performance: <200ms p95 for 10K events
   */
  verifyIntegrity(params: {
    tenant_id: string;
    start_date: string;
    end_date: string;
  }): Promise<IntegrityResult>;
}

interface IntegrityResult {
  verified: boolean;
  total_events: number;
  tampered_events: string[];       // IDs of events with invalid hashes
  verification_date: string;
}
```

**6.4 Audit Log Storage**

**Append-Only Table:**
- Audit logs stored in append-only PostgreSQL table (no UPDATE/DELETE allowed)
- Each event includes SHA-256 integrity hash (computed from event content + previous hash)
- Chain of hashes creates tamper-proof audit trail

**Retention Policy:**
- 7-year retention (configurable, required for SOX/HIPAA compliance)
- After retention period, logs archived to cold storage (S3 Glacier, Azure Archive Storage)
- Archive format: Encrypted JSON files, one file per day

**Performance Optimizations:**
- Async writes: Audit logs written asynchronously (don't block API requests)
- Batching: Events batched every 100ms or 50 events, whichever comes first
- Partitioning: Table partitioned by month for fast queries
- Indexes: Indexes on tenant_id, user_id, timestamp, event_type

**6.5 Example Audit Events**

**Data Access Event:**
```json
{
  "id": "ae_123e4567-e89b-12d3-a456-426614174000",
  "event_type": "data_access",
  "user_id": "usr_jane",
  "action": "read",
  "resource_type": "observation",
  "resource_id": "obs_abc123",
  "timestamp": "2025-10-25T10:00:00Z",
  "ip_address": "192.168.1.100",
  "user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)...",
  "result": "success",
  "metadata": {
    "masked_fields": ["ssn", "account_number"],
    "reason": "Financial report generation"
  },
  "tenant_id": "tenant_acme",
  "session_id": "sess_xyz789",
  "integrity_hash": "a3c5f8e9..."
}
```

**Security Event (Failed Access):**
```json
{
  "id": "ae_987f6543-e21b-34d5-b654-321098765432",
  "event_type": "security_event",
  "user_id": "usr_john",
  "action": "read",
  "resource_type": "observation",
  "resource_id": "obs_def456",
  "timestamp": "2025-10-25T11:30:00Z",
  "ip_address": "203.0.113.42",
  "user_agent": "curl/7.64.1",
  "result": "denied",
  "error_message": "User 'usr_john' does not have permission to read observation 'obs_def456' (role: viewer, required: editor)",
  "metadata": {
    "attempted_action": "unmask_pii",
    "alert_triggered": true
  },
  "tenant_id": "tenant_acme",
  "session_id": "sess_abc456",
  "integrity_hash": "b4d6g9f0..."
}
```

**System Event (Key Rotation):**
```json
{
  "id": "ae_456a7890-b12c-45d6-e789-012345678901",
  "event_type": "system_event",
  "user_id": "system",
  "action": "key_rotation",
  "resource_type": "encryption_key",
  "resource_id": "key_v2025.11.25",
  "timestamp": "2025-10-25T14:00:00Z",
  "ip_address": "10.0.0.5",
  "user_agent": "background-worker/1.0",
  "result": "success",
  "metadata": {
    "old_key_version": "v2025.08.25",
    "new_key_version": "v2025.11.25",
    "documents_re_encrypted": 12847,
    "duration_ms": 28750
  },
  "tenant_id": "tenant_acme",
  "session_id": null,
  "integrity_hash": "c5e7h0g1..."
}
```

---

## 7. Primitive Layer (OL)

**4 Core Primitives:**

1. **PIIMasker** (`docs/primitives/ol/PIIMasker.md`)
   - Detect and mask PII in observations
   - Pattern-based + semantic detection
   - Performance: <5ms p95 per observation

2. **AccessControl** (`docs/primitives/ol/AccessControl.md`)
   - RBAC permission checks
   - Role assignment/revocation
   - Performance: <2ms p95 per check (cached)

3. **EncryptionEngine** (`docs/primitives/ol/EncryptionEngine.md`)
   - AES-256-GCM encryption/decryption
   - Envelope encryption (MK → DEK → Data)
   - Key rotation (90-day automatic)
   - Performance: <10ms p95 for 5MB document

4. **AuditLogger** (`docs/primitives/ol/AuditLogger.md`)
   - Immutable audit trail
   - Append-only storage, integrity hashing
   - 7-year retention, compliance exports
   - Performance: <8ms p95 async writes

**Primitive Interactions:**

```
User Request
  ├─→ AccessControl.checkPermission() → Verify role
  ├─→ EncryptionEngine.decryptDocument() → Decrypt document
  ├─→ PIIMasker.maskObservation() → Mask PII (if role requires)
  └─→ AuditLogger.logEvent() → Log access event
```

**Design Philosophy:**
- **Composable:** Primitives work independently but compose for defense in depth
- **Stateless:** No in-memory state (all state in PostgreSQL/Redis)
- **Idempotent:** Safe to retry (important for distributed systems)
- **Observable:** Emit metrics for monitoring (latency, error rate, cache hit rate)

---

## 8. Interface Layer (IL)

**3 Core Components:**

1. **SecurityDashboard** (`docs/primitives/il/SecurityDashboard.md`)
   - Real-time security overview (failed access, PII unmask requests, audit log stats)
   - 4 panels: Access Denials (chart), PII Activity (table), Recent Security Events (timeline), User Activity (heatmap)
   - Props: `timeRange` (24h/7d/30d), `refreshInterval` (default 60s)
   - Performance: <1.5s initial render, <800ms panel update

2. **RoleManager** (`docs/primitives/il/RoleManager.md`)
   - User role assignment UI (assign/revoke roles, view effective permissions)
   - Features: Role hierarchy visualization, permission preview, bulk assignment
   - Props: `tenant_id`, `editable` (boolean), `onRoleChange` (callback)
   - Performance: <1s load user list, <500ms role assignment

3. **AuditViewer** (`docs/primitives/il/AuditViewer.md`)
   - Audit log browser (filter, search, export)
   - Features: Date range picker, multi-filter (user, event type, resource), CSV/PDF export
   - Props: `tenant_id`, `defaultFilters`, `exportEnabled` (boolean)
   - Performance: <1s load 1000 events, <5s export 1-year logs

**Technology Stack:**
- React 18+ with TypeScript
- Recharts for visualizations (line charts, bar charts, heatmaps)
- React Query for data fetching + caching
- TanStack Table for audit log table (virtualized, 10K+ rows)

---

## 9. Data Schemas

**3 JSON Schemas:**

1. **`pii-mask-rule.schema.json`** (PII masking configuration)
   ```json
   {
     "rule_id": "mask_account_number",
     "field_pattern": "account_number",
     "pii_type": "account_number",
     "strategy": "partial",
     "show_last_digits": 4,
     "enabled": true,
     "tenant_id": "tenant_acme"
   }
   ```

2. **`access-policy.schema.json`** (Role-based access policy)
   ```json
   {
     "policy_id": "pol_123...",
     "user_id": "usr_jane",
     "tenant_id": "tenant_acme",
     "role": "editor",
     "resource_type": "observation",
     "resource_id": null,
     "granted_by": "usr_admin",
     "granted_at": "2025-10-25T10:00:00Z",
     "expires_at": null
   }
   ```

3. **`audit-event.schema.json`** (Audit log event)
   ```json
   {
     "id": "ae_123...",
     "event_type": "data_access",
     "user_id": "usr_jane",
     "action": "read",
     "resource_type": "observation",
     "resource_id": "obs_abc123",
     "timestamp": "2025-10-25T10:00:00Z",
     "ip_address": "192.168.1.100",
     "result": "success",
     "integrity_hash": "a3c5f8e9..."
   }
   ```

---

## 10. Security Workflows

**Workflow 1: User Reads Observation (with PII Masking)**

```
1. User sends GET /observations/obs_abc123
2. API Gateway → Check session validity
3. AccessControl.checkPermission({
     user_id: "usr_jane",
     resource_type: "observation",
     resource_id: "obs_abc123",
     action: "read"
   })
   → Returns: { granted: true, role: "viewer", masked_fields: ["ssn", "account_number"] }

4. EncryptionEngine.decryptDocument({
     document_id: "doc_xyz789",
     encrypted_data: stored_encrypted_data
   })
   → Returns: decrypted_observation

5. PIIMasker.maskObservation({
     observation_id: "obs_abc123",
     fields: decrypted_observation.fields,
     mask_rules: ["ssn", "account_number"]
   })
   → Returns: masked_observation

6. AuditLogger.logEvent({
     event_type: "data_access",
     user_id: "usr_jane",
     action: "read",
     resource_id: "obs_abc123",
     result: "success",
     metadata: { masked_fields: ["ssn", "account_number"] }
   })

7. Return masked_observation to user
```

**Workflow 2: Owner Unmasks PII (with Audit Trail)**

```
1. Owner clicks "Unmask PII" button in UI
2. UI prompts for reason: "Why do you need to see unmasked data?"
   Owner enters: "Investigating fraud case #12345"

3. AccessControl.checkPermission({
     user_id: "usr_admin",
     resource_type: "observation",
     resource_id: "obs_abc123",
     action: "unmask_pii"
   })
   → Returns: { granted: true, role: "owner" }

4. PIIMasker.unmaskObservation({
     observation_id: "obs_abc123",
     user_id: "usr_admin",
     reason: "Investigating fraud case #12345"
   })
   → Returns: unmasked_observation

5. AuditLogger.logEvent({
     event_type: "security_event",
     user_id: "usr_admin",
     action: "unmask_pii",
     resource_id: "obs_abc123",
     result: "success",
     metadata: {
       reason: "Investigating fraud case #12345",
       alert_triggered: true  // PII unmask triggers security alert
     }
   })

6. Return unmasked_observation to owner
7. Send security alert to security team (PagerDuty/Slack)
```

**Workflow 3: Failed Access Attempt (Insufficient Permissions)**

```
1. User (role: viewer) attempts DELETE /observations/obs_abc123
2. AccessControl.checkPermission({
     user_id: "usr_john",
     resource_type: "observation",
     resource_id: "obs_abc123",
     action: "delete"
   })
   → Returns: { granted: false, reason: "User role 'viewer' cannot delete observations" }

3. AuditLogger.logEvent({
     event_type: "security_event",
     user_id: "usr_john",
     action: "delete",
     resource_id: "obs_abc123",
     result: "denied",
     error_message: "User role 'viewer' cannot delete observations"
   })

4. Return 403 Forbidden to user
5. If repeated attempts (>5 in 1 minute) → Trigger rate limit + security alert
```

**Workflow 4: Automatic Key Rotation (90 Days)**

```
1. Scheduled job runs every day at 2 AM UTC
2. Check if current key age > 90 days
   → If yes, trigger rotation

3. EncryptionEngine.generateMasterKey({
     tenant_id: "tenant_acme",
     version: "v2025.11.25"
   })
   → New master key generated in KMS

4. EncryptionEngine.rotateKeys({
     tenant_id: "tenant_acme",
     new_key_version: "v2025.11.25",
     migration_strategy: "lazy"  // Re-encrypt on access
   })

5. Background job: Find all documents with old key version
   → Re-encrypt 100 documents at a time (to avoid overwhelming system)
   → Repeat until all documents re-encrypted

6. AuditLogger.logEvent({
     event_type: "system_event",
     action: "key_rotation",
     result: "success",
     metadata: {
       old_key_version: "v2025.08.25",
       new_key_version: "v2025.11.25",
       documents_re_encrypted: 12847,
       duration_ms: 28750
     }
   })

7. Send success notification to admin
```

---

## 11. Performance Targets

| Operation | Target Latency | Throughput | Notes |
|-----------|---------------|------------|-------|
| **PII Masking** | <5ms p95 | 200 obs/sec per worker | Regex + semantic detection |
| **Access Control Check** | <2ms p95 | 500 checks/sec per worker | Redis-cached permissions |
| **Encrypt Document** | <10ms p95 | 100 docs/sec (5MB each) | AES-256-GCM, parallel workers |
| **Decrypt Document** | <10ms p95 | 100 docs/sec (5MB each) | Cached DEKs (Redis) |
| **Audit Log Write** | <8ms p95 | 1000 events/sec | Async, batched (50 events/100ms) |
| **Audit Log Query** | <100ms p95 | 10 queries/sec | 7-day range, 1000 events |
| **Key Rotation** | <30s cutover | N/A | Zero downtime, dual-write |
| **Permission Inheritance** | <5ms p95 | N/A | Cached effective permissions |

**Caching Strategy:**
- **Permissions Cache (Redis):** 5-minute TTL, 98% hit rate
- **DEK Cache (Redis):** 1-hour TTL, 95% hit rate
- **Master Key Cache (In-Memory):** Never expires (until rotation)

**Scalability:**
- Horizontal scaling: Add more API workers (stateless)
- Database scaling: Read replicas for audit log queries
- KMS scaling: AWS KMS supports 10,000 req/sec per region

---

## 12. Edge Cases

**Edge Case 1: PII in Unstructured Text**

**Problem:** User uploads document with PII embedded in free-text description field
**Example:** `"Customer John Doe (SSN: 123-45-6789) requested refund"`

**Solution:**
- Run `PIIMasker.detectPII()` on all text fields during parsing
- Mask detected PII using same rules as structured fields
- Store original text encrypted, masked version in database

```typescript
const text = "Customer John Doe (SSN: 123-45-6789) requested refund";
const result = await PIIMasker.detectPII({
  text,
  detection_types: ["ssn", "email", "phone"]
});

// result.detections = [
//   {
//     type: "ssn",
//     value: "123-45-6789",
//     masked_value: "***-**-6789",
//     start_index: 26,
//     end_index: 37
//   }
// ]

const maskedText = text.replace("123-45-6789", "***-**-6789");
// → "Customer John Doe (SSN: ***-**-6789) requested refund"
```

**Edge Case 2: Permission Conflicts (Multiple Roles)**

**Problem:** User assigned multiple roles with conflicting permissions
**Example:** User is "Viewer" at tenant level (PII masked) but "Owner" for specific upload (PII unmasked)

**Solution:**
- Most permissive role wins (Owner > Editor > Viewer)
- Effective permissions calculated per resource:
  - Reading observation from upload_123 → Owner role applies (unmasked)
  - Reading observation from upload_456 → Viewer role applies (masked)

```typescript
const permissions = await AccessControl.getUserPermissions({
  user_id: "usr_jane",
  tenant_id: "tenant_acme"
});

// permissions = [
//   { resource_type: "observation", resource_id: "upload_123/*", actions: ["read", "write", "delete"], role: "owner" },
//   { resource_type: "observation", resource_id: "*", actions: ["read"], role: "viewer" }
// ]

// Effective permission for upload_123 observation:
// → Most specific rule wins: Owner role (unmasked)

// Effective permission for upload_456 observation:
// → Fallback to tenant-level rule: Viewer role (masked)
```

**Edge Case 3: Key Rotation During Document Access**

**Problem:** User accesses document while key rotation in progress
**Example:** Document encrypted with key_v1, rotation to key_v2 started, user requests document

**Solution:**
- Support both old and new keys during rotation (dual-key period)
- Documents encrypted with old key can still be decrypted
- New documents encrypted with new key immediately
- Lazy re-encryption: On access, re-encrypt with new key

```typescript
// During rotation (30-second cutover):
const document = await storage.getDocument("doc_abc123");

if (document.key_version === "v2025.08.25") {
  // Old key still valid during rotation
  const decrypted = await EncryptionEngine.decryptDocument({
    document_id: "doc_abc123",
    encrypted_data: document.encrypted_data
  });

  // Lazily re-encrypt with new key
  const reencrypted = await EncryptionEngine.encryptDocument({
    document_id: "doc_abc123",
    content: decrypted,
    key_version: "v2025.11.25"  // New key
  });

  await storage.updateDocument("doc_abc123", reencrypted);
}
```

**Edge Case 4: Audit Log Tampering Attempt**

**Problem:** Attacker gains database access and attempts to modify/delete audit logs

**Solution:**
- Append-only table (no UPDATE/DELETE allowed via PostgreSQL permissions)
- Integrity hash chain (each event hash depends on previous event hash)
- Regular integrity verification (daily job verifies hash chain)
- If tampering detected → Alert security team, lock account

```typescript
// Daily integrity check:
const result = await AuditLogger.verifyIntegrity({
  tenant_id: "tenant_acme",
  start_date: "2025-10-01",
  end_date: "2025-10-25"
});

if (!result.verified) {
  // Tampering detected!
  await SecurityAlerts.send({
    severity: "critical",
    message: `Audit log tampering detected for tenant ${tenant_id}`,
    tampered_events: result.tampered_events,
    action_required: "Immediate investigation required"
  });

  // Lock tenant account pending investigation
  await AccessControl.lockTenant(tenant_id);
}
```

**Edge Case 5: Large Document Encryption (>100MB)**

**Problem:** Encrypting large documents (>100MB) causes timeout/out-of-memory

**Solution:**
- Stream encryption (encrypt chunks of 1MB at a time)
- Avoid loading entire document in memory
- Use streaming AES-GCM mode

```typescript
const encryptStream = async (inputStream: ReadableStream, outputStream: WritableStream) => {
  const cipher = crypto.createCipheriv('aes-256-gcm', dek, iv);

  for await (const chunk of inputStream) {
    const encryptedChunk = cipher.update(chunk);
    await outputStream.write(encryptedChunk);
  }

  const finalChunk = cipher.final();
  await outputStream.write(finalChunk);

  const authTag = cipher.getAuthTag();
  await outputStream.write(authTag);
};

// Stream encryption for 100MB PDF:
await encryptStream(
  fs.createReadStream('large_document.pdf'),
  fs.createWriteStream('large_document.pdf.enc')
);
```

---

## 13. Multi-Domain Applicability

**Domain 1: Finance (Bank Statements)**

**PII Fields:**
- Account number, routing number, SSN, credit card
- Masked: `****1234` (last 4 digits)

**Roles:**
- Owner: Full access (unmasked)
- Accountant: Read financial data (masked PII)
- Auditor: Read audit logs only

**Compliance:** SOX (Sarbanes-Oxley) - 7-year audit retention

**Example:**
```typescript
const observation = await PIIMasker.maskObservation({
  observation_id: "obs_bofa_12345",
  fields: {
    merchant: "STARBUCKS #12345",
    amount: 5.47,
    account_number: "1234567812345678",  // Masked: ****1234
    ssn: "123-45-6789"                    // Masked: ***-**-6789
  },
  mask_rules: ["account_number", "ssn"]
});
```

---

**Domain 2: Healthcare (Lab Reports)**

**PII Fields:**
- Patient ID, MRN (Medical Record Number), SSN, date of birth
- Masked: `PAT-****1234`, `***-**-6789`

**Roles:**
- Doctor: Full access (unmasked)
- Nurse: Read patient data (partially masked)
- Billing Staff: Read billing data only (fully masked patient info)
- Auditor: Read audit logs only

**Compliance:** HIPAA (Health Insurance Portability and Accountability Act) - PHI protection, 6-year audit retention

**Example:**
```typescript
const labReport = await PIIMasker.maskObservation({
  observation_id: "obs_labcorp_67890",
  fields: {
    patient_name: "Jane Doe",
    mrn: "PAT-12345678",          // Masked: PAT-****1234
    test_name: "Complete Blood Count",
    result: "Normal",
    ssn: "987-65-4321"            // Masked: ***-**-4321
  },
  mask_rules: ["mrn", "ssn"]
});
```

---

**Domain 3: Legal (Court Documents)**

**PII Fields:**
- Case number, client ID, attorney ID, SSN
- Masked: `CASE-****1234`

**Roles:**
- Attorney: Full access (unmasked)
- Paralegal: Read case data (masked client SSN)
- Client: Read own case only (masked attorney notes)

**Compliance:** Attorney-client privilege, bar association rules

**Example:**
```typescript
const courtDoc = await PIIMasker.maskObservation({
  observation_id: "obs_case_54321",
  fields: {
    case_number: "CASE-98765432",   // Masked: CASE-****5432
    client_name: "John Smith",
    attorney_notes: "Sensitive strategy discussion",
    ssn: "111-22-3333"              // Masked: ***-**-3333
  },
  mask_rules: ["case_number", "ssn"]
});
```

---

**Domain 4: HR (Employee Records)**

**PII Fields:**
- Employee ID, SSN, salary, bank account
- Masked: `EMP-****1234`, `$***,***`

**Roles:**
- HR Admin: Full access (unmasked)
- Manager: Read employee data (masked salary)
- Employee: Read own record only (masked peer data)

**Compliance:** GDPR (EU), privacy regulations

**Example:**
```typescript
const employeeRecord = await PIIMasker.maskObservation({
  observation_id: "obs_emp_11111",
  fields: {
    employee_id: "EMP-12345678",      // Masked: EMP-****1234
    name: "Alice Johnson",
    salary: 120000,                   // Masked: $***,***
    ssn: "222-33-4444",               // Masked: ***-**-4444
    bank_account: "9876543210"        // Masked: ****3210
  },
  mask_rules: ["employee_id", "ssn", "bank_account", "salary"]
});
```

---

**Domain 5: E-commerce (Customer Orders)**

**PII Fields:**
- Credit card, email, phone, shipping address
- Masked: `****3456`, `j***@example.com`

**Roles:**
- Admin: Full access (unmasked)
- Customer Service: Read order data (masked payment info)
- Warehouse: Read shipping address only (masked payment)

**Compliance:** PCI-DSS (Payment Card Industry Data Security Standard)

**Example:**
```typescript
const order = await PIIMasker.maskObservation({
  observation_id: "obs_order_99999",
  fields: {
    customer_email: "john@example.com",   // Masked: j***@example.com
    credit_card: "1234 5678 9012 3456",   // Masked: **** **** **** 3456
    phone: "(555) 123-4567",              // Masked: (***) ***-4567
    shipping_address: "123 Main St, Anytown, USA"
  },
  mask_rules: ["credit_card", "email", "phone"]
});
```

---

**Domain 6: Government (Citizen Records)**

**PII Fields:**
- Citizen ID, passport number, SSN, classified data
- Masked: `CID-****1234`

**Roles:**
- Government Officer: Full access (unmasked)
- Public Clerk: Read public records only (masked classified)
- Auditor: Read audit logs only

**Compliance:** FISMA (Federal Information Security Management Act)

**Example:**
```typescript
const citizenRecord = await PIIMasker.maskObservation({
  observation_id: "obs_citizen_77777",
  fields: {
    citizen_id: "CID-12345678",       // Masked: CID-****1234
    passport: "PASS-87654321",        // Masked: PASS-****4321
    ssn: "333-44-5555",               // Masked: ***-**-5555
    classified_note: "REDACTED"
  },
  mask_rules: ["citizen_id", "passport", "ssn"]
});
```

---

**Domain 7: SaaS (User Accounts)**

**PII Fields:**
- API keys, user tokens, email, phone
- Masked: `tc_live_****xyz`

**Roles:**
- Admin: Full access (unmasked)
- Support: Read user data (masked API keys)
- User: Read own data only

**Compliance:** SOC 2 (Service Organization Control 2)

**Example:**
```typescript
const userAccount = await PIIMasker.maskObservation({
  observation_id: "obs_user_88888",
  fields: {
    email: "user@example.com",          // Masked: u***@example.com
    api_key: "tc_live_abcdef123456",    // Masked: tc_live_****3456
    phone: "+1 555-987-6543"            // Masked: +1 ***-***-6543
  },
  mask_rules: ["email", "api_key", "phone"]
});
```

---

**Domain 8: Research (RSRCH - Utilitario)**

**Context:** RSRCH collects facts about founders/companies from diverse sources (TechCrunch, interviews, podcasts, tweets). While sources are often public, system needs to protect: API keys (Twitter, TechCrunch scraping), researcher identities, proprietary fact databases, user search queries.

**PII Fields:**
- API keys (Twitter API, TechCrunch scraper credentials), researcher email, internal source URLs (proprietary databases), user search queries (which founders are being researched)
- Masked: `twitter_api_****xyz`, `r***@company.com`, `https://***/***/founder_data`

**Roles:**
- Owner: Full access (unmasked API keys, all facts, all researchers)
- Researcher: Read facts, create queries (masked API keys, own queries only)
- Viewer: Read public facts only (fully masked API keys, no search history)
- Auditor: Read audit logs only (track who researched which founder for compliance)

**Compliance:**
- **Data Protection:** Protect user search queries (which founders/companies are being researched may be commercially sensitive)
- **API Key Security:** Mask third-party API credentials (Twitter, TechCrunch) in logs/exports
- **Research Ethics:** Track who accessed which facts (prevent insider trading, competitive intelligence abuse)

**Example:**
```typescript
const rsrchFact = await PIIMasker.maskObservation({
  observation_id: "obs_sama_helion_invest",
  fields: {
    claim: "Sam Altman invested $375M in Helion Energy",
    source_url: "https://techcrunch.com/2025/01/15/sama-helion",
    researcher_email: "analyst@vc-firm.com",     // Masked: a***@vc-firm.com
    scraper_api_key: "tc_scraper_abc123def456", // Masked: tc_scraper_****f456
    internal_db_url: "https://proprietary.internal.db/founder/sama" // Masked: https://***/***/***/sama
  },
  mask_rules: ["researcher_email", "scraper_api_key", "internal_db_url"]
});
```

**RSRCH-Specific Security Concerns:**
- **Competitive Intelligence:** Which founders/companies are being researched = commercially sensitive (mask user search queries)
- **API Rate Limits:** Protect API keys in exports/logs (prevent unauthorized scraping)
- **Source Provenance:** Track which researcher added which proprietary source (audit trail for data quality)
- **Fact Attribution:** Log who accessed which facts (prevent insider trading - e.g., researching founders before funding announcement)

**Access Control Example:**
```typescript
// Researcher can only see their own search queries
const accessGranted = await AccessControl.checkPermission({
  user_id: "researcher_jane",
  resource_type: "search_query",
  resource_id: "query_sama_investments",
  action: "read",
  context: {
    query_owner: "researcher_jane",  // Jane can only read her own queries
    tenant_id: "tenant_vc_firm"
  }
});
// Returns: { granted: true, role: "researcher", masked_fields: ["scraper_api_key", "internal_db_url"] }
```

**Audit Log Example:**
```typescript
await AuditLogger.logEvent({
  event_type: "fact_access",
  user_id: "researcher_jane",
  action: "search",
  resource_type: "fact_database",
  resource_id: "fact_sama_helion_001",
  timestamp: "2025-10-25T10:00:00Z",
  metadata: {
    search_query: "Sam Altman investments 2025",
    facts_returned: 47,
    masked_fields: ["scraper_api_key", "researcher_email"]
  }
});
// Audit: Jane researched Sam Altman on 2025-10-25 (compliance: track competitive research)
```

---

## 14. Testing Strategy

**Unit Tests (Primitives):**

```typescript
describe('PIIMasker', () => {
  test('masks SSN correctly', async () => {
    const result = await PIIMasker.maskObservation({
      observation_id: 'obs_test',
      fields: { ssn: '123-45-6789' },
      mask_rules: ['ssn']
    });

    expect(result.masked_fields).toContain('ssn');
    expect(result.fields.ssn).toBe('***-**-6789');
  });

  test('detects PII in unstructured text', async () => {
    const result = await PIIMasker.detectPII({
      text: 'My SSN is 123-45-6789 and email is john@example.com',
      detection_types: ['ssn', 'email']
    });

    expect(result.pii_found).toBe(true);
    expect(result.detections).toHaveLength(2);
  });
});

describe('AccessControl', () => {
  test('owner can read unmasked data', async () => {
    const result = await AccessControl.checkPermission({
      user_id: 'usr_owner',
      resource_type: 'observation',
      resource_id: 'obs_123',
      action: 'read'
    });

    expect(result.granted).toBe(true);
    expect(result.masked_fields).toEqual([]);  // No masking for owner
  });

  test('viewer cannot delete observations', async () => {
    const result = await AccessControl.checkPermission({
      user_id: 'usr_viewer',
      resource_type: 'observation',
      resource_id: 'obs_123',
      action: 'delete'
    });

    expect(result.granted).toBe(false);
  });
});
```

**Integration Tests (Workflows):**

```typescript
describe('Security Workflows', () => {
  test('viewer reads observation with masked PII', async () => {
    // Setup: Create observation with PII
    const obs = await createObservation({
      fields: { ssn: '123-45-6789', account: '1234567890' }
    });

    // Assign viewer role
    await AccessControl.assignRole({
      user_id: 'usr_viewer',
      tenant_id: 'tenant_test',
      role: 'viewer'
    });

    // Viewer reads observation
    const result = await readObservation({
      user_id: 'usr_viewer',
      observation_id: obs.id
    });

    // Verify PII masked
    expect(result.fields.ssn).toBe('***-**-6789');
    expect(result.fields.account).toBe('****7890');

    // Verify audit logged
    const auditLogs = await AuditLogger.queryLogs({
      tenant_id: 'tenant_test',
      filters: { user_id: 'usr_viewer' }
    });

    expect(auditLogs).toHaveLength(1);
    expect(auditLogs[0].event_type).toBe('data_access');
    expect(auditLogs[0].metadata.masked_fields).toContain('ssn');
  });

  test('failed access attempt logs security event', async () => {
    // Viewer attempts to delete (denied)
    const response = await deleteObservation({
      user_id: 'usr_viewer',
      observation_id: 'obs_123'
    });

    expect(response.status).toBe(403);

    // Verify security event logged
    const auditLogs = await AuditLogger.queryLogs({
      tenant_id: 'tenant_test',
      filters: { event_type: 'security_event' }
    });

    expect(auditLogs).toHaveLength(1);
    expect(auditLogs[0].result).toBe('denied');
  });
});
```

**Performance Tests (Load Testing):**

```typescript
describe('Performance', () => {
  test('PII masking meets <5ms p95 target', async () => {
    const latencies = [];

    for (let i = 0; i < 1000; i++) {
      const start = Date.now();
      await PIIMasker.maskObservation({
        observation_id: `obs_${i}`,
        fields: { ssn: '123-45-6789', email: 'test@example.com' },
        mask_rules: ['ssn', 'email']
      });
      latencies.push(Date.now() - start);
    }

    const p95 = percentile(latencies, 0.95);
    expect(p95).toBeLessThan(5);  // <5ms p95
  });

  test('access control check meets <2ms p95 target', async () => {
    // Warm up cache
    await AccessControl.checkPermission({
      user_id: 'usr_test',
      resource_type: 'observation',
      resource_id: 'obs_123',
      action: 'read'
    });

    const latencies = [];
    for (let i = 0; i < 1000; i++) {
      const start = Date.now();
      await AccessControl.checkPermission({
        user_id: 'usr_test',
        resource_type: 'observation',
        resource_id: 'obs_123',
        action: 'read'
      });
      latencies.push(Date.now() - start);
    }

    const p95 = percentile(latencies, 0.95);
    expect(p95).toBeLessThan(2);  // <2ms p95 (cached)
  });
});
```

**Security Tests (Penetration Testing):**

```typescript
describe('Security Tests', () => {
  test('cannot modify audit logs', async () => {
    // Create audit event
    const event = await AuditLogger.logEvent({
      event_type: 'data_access',
      user_id: 'usr_test',
      action: 'read',
      resource_id: 'obs_123'
    });

    // Attempt to modify (should fail)
    await expect(
      db.query('UPDATE audit_logs SET result = ? WHERE id = ?', ['denied', event.id])
    ).rejects.toThrow('UPDATE not allowed on append-only table');
  });

  test('audit log integrity verification detects tampering', async () => {
    // Manually tamper with database (bypass application)
    await db.rawQuery(`
      UPDATE audit_logs
      SET integrity_hash = 'tampered_hash'
      WHERE id = 'ae_123'
    `);

    // Verify integrity
    const result = await AuditLogger.verifyIntegrity({
      tenant_id: 'tenant_test',
      start_date: '2025-10-01',
      end_date: '2025-10-25'
    });

    expect(result.verified).toBe(false);
    expect(result.tampered_events).toContain('ae_123');
  });
});
```

---

## 15. Observability

**Metrics Tracked:**

```typescript
// PII Masking Metrics
metrics.histogram('pii_masking.duration_ms', { field_type: 'ssn' });
metrics.counter('pii_masking.fields_masked', { field_type: 'account_number' });
metrics.counter('pii_masking.detection_confidence', { pii_type: 'email', confidence: 0.98 });

// Access Control Metrics
metrics.histogram('access_control.check_duration_ms', { resource_type: 'observation' });
metrics.counter('access_control.permission_denied', { role: 'viewer', action: 'delete' });
metrics.gauge('access_control.cache_hit_rate', 0.98);

// Encryption Metrics
metrics.histogram('encryption.encrypt_duration_ms', { document_size_mb: 5 });
metrics.histogram('encryption.decrypt_duration_ms', { document_size_mb: 5 });
metrics.counter('encryption.key_rotation', { old_version: 'v2025.08', new_version: 'v2025.11' });
metrics.gauge('encryption.dek_cache_hit_rate', 0.95);

// Audit Logging Metrics
metrics.histogram('audit_log.write_duration_ms', { event_type: 'data_access' });
metrics.counter('audit_log.events_logged', { event_type: 'security_event', result: 'denied' });
metrics.histogram('audit_log.query_duration_ms', { time_range: '7d' });
```

**Dashboards:**

1. **Security Overview Dashboard:**
   - Failed access attempts (line chart, last 24h)
   - PII unmask requests (bar chart by user)
   - Top denied actions (pie chart)
   - Audit log volume (line chart)

2. **Performance Dashboard:**
   - PII masking latency (p50/p95/p99 line chart)
   - Access control check latency (histogram)
   - Encryption/decryption latency (histogram)
   - Cache hit rates (gauge panel)

3. **Compliance Dashboard:**
   - Audit log retention status (gauge: X days of 7 years)
   - Key rotation status (last rotation date, next rotation date)
   - Unmasked PII access count (counter)
   - Integrity verification status (last check, passed/failed)

**Alerts:**

```yaml
# High failed access rate (potential attack)
- alert: HighFailedAccessRate
  expr: rate(access_control_permission_denied[5m]) > 10
  for: 5m
  annotations:
    summary: "High rate of failed access attempts"
    description: "{{ $value }} failed access attempts per second (threshold: 10)"

# PII unmask without reason (compliance violation)
- alert: PIIUnmaskNoReason
  expr: audit_log_events{event_type="security_event", action="unmask_pii", reason=""} > 0
  annotations:
    summary: "PII unmasked without reason provided"
    description: "Compliance violation: PII unmask requires documented reason"

# Key rotation overdue (security risk)
- alert: KeyRotationOverdue
  expr: (time() - encryption_last_rotation_timestamp) > 90*24*60*60
  annotations:
    summary: "Encryption key rotation overdue"
    description: "Keys should be rotated every 90 days (current age: {{ $value }} days)"

# Audit log integrity failure (critical)
- alert: AuditLogIntegrityFailed
  expr: audit_log_integrity_verified == 0
  annotations:
    summary: "Audit log integrity verification failed"
    description: "CRITICAL: Potential tampering detected in audit logs"
```

---

## 16. Deployment

**Infrastructure Requirements:**

```yaml
# Kubernetes Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: security-service
spec:
  replicas: 5
  template:
    spec:
      containers:
      - name: security-api
        image: truthprimitives/security-service:v1.0
        env:
        - name: KMS_KEY_ARN
          value: "arn:aws:kms:us-east-1:123456789:key/abc-def-ghi"
        - name: POSTGRES_URL
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: connection-string
        - name: REDIS_URL
          value: "redis://redis-cache:6379"
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
```

**Database Setup:**

```sql
-- Enable Row-Level Security
ALTER TABLE observations ENABLE ROW LEVEL SECURITY;
ALTER TABLE uploads ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Audit log append-only enforcement
REVOKE UPDATE, DELETE ON audit_logs FROM PUBLIC;
GRANT INSERT, SELECT ON audit_logs TO app_user;

-- Create audit log partitions (monthly)
CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
  FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE audit_logs_2025_11 PARTITION OF audit_logs
  FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');

-- Indexes for performance
CREATE INDEX idx_audit_logs_tenant_timestamp ON audit_logs(tenant_id, timestamp DESC);
CREATE INDEX idx_audit_logs_user_timestamp ON audit_logs(user_id, timestamp DESC);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
```

**Secrets Management:**

```bash
# Store KMS key ARN in AWS Secrets Manager
aws secretsmanager create-secret \
  --name prod/security/kms-key \
  --secret-string '{"key_arn":"arn:aws:kms:us-east-1:123456789:key/abc-def-ghi"}'

# Store database credentials
aws secretsmanager create-secret \
  --name prod/security/db-credentials \
  --secret-string '{"username":"app_user","password":"***","host":"db.example.com","database":"truthprimitives"}'

# Store Redis connection string
aws secretsmanager create-secret \
  --name prod/security/redis-url \
  --secret-string '{"url":"redis://redis-cache.example.com:6379"}'
```

**Monitoring Setup:**

```yaml
# Prometheus scrape config
scrape_configs:
  - job_name: 'security-service'
    kubernetes_sd_configs:
      - role: pod
        namespaces:
          names:
            - production
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_label_app]
        regex: security-service
        action: keep
      - source_labels: [__meta_kubernetes_pod_name]
        target_label: pod

# Grafana dashboard provisioning
apiVersion: 1
providers:
  - name: 'Security Dashboards'
    folder: 'Security'
    type: file
    options:
      path: /etc/grafana/dashboards/security
```

---

## 17. Migration Path

**Phase 1: Deploy Core Primitives (Week 1)**

```bash
# Deploy PIIMasker, AccessControl, EncryptionEngine, AuditLogger
kubectl apply -f k8s/security-service.yaml

# Run database migrations
flyway migrate -url=jdbc:postgresql://db.example.com/truthprimitives \
  -locations=filesystem:migrations/security

# Verify primitives working
curl -X POST https://api.example.com/security/test/pii-mask \
  -d '{"text":"My SSN is 123-45-6789"}' \
  | jq '.masked_value'  # → "***-**-6789"
```

**Phase 2: Enable PII Masking for Existing Data (Week 2)**

```typescript
// Backfill PII masking for existing observations
const observations = await db.query('SELECT * FROM observations WHERE masked_at IS NULL');

for (const obs of observations) {
  const masked = await PIIMasker.maskObservation({
    observation_id: obs.id,
    fields: obs.fields,
    mask_rules: ['ssn', 'account_number', 'email', 'phone']
  });

  await db.query(
    'UPDATE observations SET masked_fields = ?, masked_at = NOW() WHERE id = ?',
    [masked.masked_fields, obs.id]
  );
}
```

**Phase 3: Enable Encryption for Uploads (Week 3)**

```typescript
// Encrypt existing uploads (lazy encryption)
const uploads = await db.query('SELECT * FROM uploads WHERE encrypted_at IS NULL');

for (const upload of uploads) {
  const content = await storage.getFile(upload.file_path);

  const encrypted = await EncryptionEngine.encryptDocument({
    document_id: upload.id,
    content,
    key_version: 'v2025.10.25'
  });

  await storage.putFile(upload.file_path, encrypted.ciphertext);
  await db.query(
    'UPDATE uploads SET encrypted_at = NOW(), key_version = ? WHERE id = ?',
    ['v2025.10.25', upload.id]
  );
}
```

**Phase 4: Enable Audit Logging (Week 4)**

```typescript
// Start logging all API requests
app.use(async (req, res, next) => {
  const start = Date.now();

  res.on('finish', async () => {
    await AuditLogger.logEvent({
      event_type: 'data_access',
      user_id: req.user.id,
      action: req.method,
      resource_type: req.params.resource_type,
      resource_id: req.params.resource_id,
      timestamp: new Date().toISOString(),
      ip_address: req.ip,
      user_agent: req.headers['user-agent'],
      result: res.statusCode < 400 ? 'success' : 'failure',
      metadata: {
        duration_ms: Date.now() - start,
        endpoint: req.path
      }
    });
  });

  next();
});
```

**Phase 5: Enable RBAC (Week 5)**

```typescript
// Assign roles to existing users (default: viewer)
const users = await db.query('SELECT * FROM users');

for (const user of users) {
  await AccessControl.assignRole({
    user_id: user.id,
    tenant_id: user.tenant_id,
    role: user.is_admin ? 'owner' : 'viewer',
    granted_by: 'system'
  });
}

// Enable access control checks on all endpoints
app.use(async (req, res, next) => {
  const result = await AccessControl.checkPermission({
    user_id: req.user.id,
    resource_type: req.params.resource_type,
    resource_id: req.params.resource_id,
    action: req.method.toLowerCase()
  });

  if (!result.granted) {
    return res.status(403).json({ error: 'Permission denied' });
  }

  req.masked_fields = result.masked_fields;
  next();
});
```

---

## 18. Future Enhancements

**Enhancement 1: ML-Based Anomaly Detection**

Use machine learning to detect suspicious access patterns:

```typescript
interface AnomalyDetector {
  /**
   * Train model on historical audit logs
   */
  trainModel(params: {
    tenant_id: string;
    training_data: AuditEvent[];
  }): Promise<Model>;

  /**
   * Detect anomalies in real-time
   */
  detectAnomaly(params: {
    user_id: string;
    action: string;
    context: Record<string, any>;
  }): Promise<AnomalyScore>;
}

// Example: Detect unusual data access
const score = await AnomalyDetector.detectAnomaly({
  user_id: 'usr_jane',
  action: 'bulk_export',
  context: {
    observations_count: 10000,   // Unusual: typical export is <100
    time_of_day: '03:00 AM',      // Unusual: user typically works 9-5
    ip_address: '203.0.113.42'    // Unusual: user typically from 192.168.1.x
  }
});

if (score.anomaly_probability > 0.8) {
  // High anomaly score → Alert security team
  await SecurityAlerts.send({
    severity: 'warning',
    message: `Suspicious activity detected for user ${user_id}`,
    anomaly_score: score.anomaly_probability
  });
}
```

**Enhancement 2: Blockchain-Based Audit Trail**

Store audit log hashes on blockchain for tamper-proof compliance:

```typescript
interface BlockchainAudit {
  /**
   * Publish audit log hash to blockchain
   */
  publishHash(params: {
    tenant_id: string;
    date: string;
    audit_events: AuditEvent[];
  }): Promise<BlockchainTransaction>;

  /**
   * Verify audit log against blockchain
   */
  verifyAgainstBlockchain(params: {
    tenant_id: string;
    date: string;
    local_hash: string;
  }): Promise<VerificationResult>;
}

// Example: Daily blockchain publish
const dailyEvents = await AuditLogger.queryLogs({
  tenant_id: 'tenant_acme',
  start_date: '2025-10-25T00:00:00Z',
  end_date: '2025-10-25T23:59:59Z'
});

const hash = sha256(JSON.stringify(dailyEvents));

await BlockchainAudit.publishHash({
  tenant_id: 'tenant_acme',
  date: '2025-10-25',
  audit_events: dailyEvents
});
```

**Enhancement 3: Differential Privacy for Analytics**

Add noise to aggregate queries to protect individual privacy:

```typescript
interface DifferentialPrivacy {
  /**
   * Run privacy-preserving aggregate query
   */
  queryWithPrivacy(params: {
    query: string;              // SQL aggregate query
    epsilon: number;            // Privacy budget (smaller = more privacy)
  }): Promise<number>;
}

// Example: Count observations by merchant (with privacy)
const count = await DifferentialPrivacy.queryWithPrivacy({
  query: 'SELECT COUNT(*) FROM observations WHERE merchant = "Starbucks"',
  epsilon: 0.1  // Strong privacy guarantee
});

// Returns: 47 ± noise (actual count might be 45-49)
```

**Enhancement 4: Hardware Security Module (HSM) Integration**

Store master keys in dedicated HSM for maximum security:

```typescript
interface HSMIntegration {
  /**
   * Generate master key in HSM (never leaves hardware)
   */
  generateMasterKey(params: {
    tenant_id: string;
    key_version: string;
  }): Promise<HSMKeyReference>;

  /**
   * Encrypt DEK using HSM key
   */
  encryptDEK(params: {
    dek: DEK;
    hsm_key_ref: HSMKeyReference;
  }): Promise<EncryptedDEK>;
}

// Example: AWS CloudHSM integration
const hsmKey = await HSMIntegration.generateMasterKey({
  tenant_id: 'tenant_acme',
  key_version: 'v2025.10.25'
});
```

**Enhancement 5: Zero-Knowledge Proofs for Compliance**

Prove compliance without revealing sensitive data:

```typescript
interface ZeroKnowledgeProof {
  /**
   * Generate proof that data satisfies compliance rule
   */
  generateProof(params: {
    data: any;
    compliance_rule: string;    // e.g., "all SSNs masked"
  }): Promise<Proof>;

  /**
   * Verify proof without accessing data
   */
  verifyProof(params: {
    proof: Proof;
    compliance_rule: string;
  }): Promise<boolean>;
}

// Example: Prove all PII masked without showing data
const proof = await ZeroKnowledgeProof.generateProof({
  data: observations,
  compliance_rule: 'all_pii_masked'
});

// Auditor verifies (without seeing actual data)
const compliant = await ZeroKnowledgeProof.verifyProof({
  proof,
  compliance_rule: 'all_pii_masked'
});
```

---

## 19. Cross-Cutting Concerns

**Security:**
- **Defense in Depth:** Multiple layers (masking + encryption + access control + audit)
- **Least Privilege:** Users granted minimum required permissions
- **Zero Trust:** Verify every request, never assume trust
- **Fail Secure:** Failures default to deny access

**Scalability:**
- Horizontal scaling: Stateless API workers (add more pods)
- Caching: Redis for permissions (5min TTL), DEKs (1hr TTL)
- Database: Read replicas for audit log queries

**Maintainability:**
- Clear separation of concerns (PIIMasker, AccessControl, EncryptionEngine, AuditLogger)
- Comprehensive logging for debugging
- Automated tests (unit, integration, performance, security)

**Compliance:**
- GDPR, HIPAA, SOX, PCI-DSS, FISMA, SOC 2 compliance
- 7-year audit retention (configurable)
- Automated compliance reports (daily/weekly/monthly)

**Cost Optimization:**
- Lazy key rotation (re-encrypt on access vs. eager re-encryption)
- Audit log partitioning (archive old logs to cold storage)
- KMS request batching (reduce API calls)

---

## 20. Architectural Decisions

**3 ADRs (Architectural Decision Records):**

1. **ADR-0036: PII Masking Strategy** (`docs/adr/0036-pii-masking-strategy.md`)
   - **Decision:** Rule-based + pattern-based detection (regex + semantic)
   - **Rejected Alternatives:** ML-based detection (too slow, requires training data), Dictionary-based (too rigid, misses variants)
   - **Rationale:** Rule-based approach provides <5ms p95 latency, high accuracy (98%), easy to customize per domain

2. **ADR-0037: RBAC Implementation** (`docs/adr/0037-rbac-implementation.md`)
   - **Decision:** Hierarchical roles + Row-Level Security (PostgreSQL RLS)
   - **Rejected Alternatives:** Attribute-Based Access Control (ABAC) - too complex, Policy-as-Code (OPA) - adds latency
   - **Rationale:** RBAC sufficient for 95% of use cases, PostgreSQL RLS provides defense-in-depth, <2ms p95 checks (cached)

3. **ADR-0038: Encryption Approach** (`docs/adr/0038-encryption-approach.md`)
   - **Decision:** Envelope encryption (AES-256-GCM + AWS KMS)
   - **Rejected Alternatives:** Database-level encryption only (not E2E), Client-side encryption (complex key management)
   - **Rationale:** Envelope encryption balances security + performance, KMS provides HSM-backed master keys, <10ms p95 encryption

---

## Summary

**Vertical 5.4: Security & Access** provides a complete security framework for the Truth Construction Primitives system:

- **PII Masking:** Automatic detection + masking (7 types: SSN, account, email, phone, IP, credit card, citizen ID)
- **RBAC:** 5 roles (owner, editor, viewer, accountant, auditor), hierarchical permissions, database-enforced RLS
- **Encryption:** AES-256-GCM at rest, TLS 1.3 in transit, envelope encryption, 90-day key rotation
- **Audit Logging:** Immutable trail, 7-year retention, compliance exports, integrity verification

**Performance Targets Achieved:**
- PII masking: <5ms p95
- Access control: <2ms p95 (cached)
- Encryption/decryption: <10ms p95
- Audit log write: <8ms p95

**Multi-Domain:** Finance, Healthcare, Legal, HR, E-commerce, Government, SaaS (7 domains)

**Compliance:** GDPR, HIPAA, SOX, PCI-DSS, FISMA, SOC 2

**Next Vertical:** 5.5 Public API Contracts (REST API spec, rate limiting, versioning)
