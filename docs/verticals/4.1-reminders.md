# Vertical 4.1: Reminders (Intelligent Alert & Notification System)

> **Type:** Event-Driven Notification System
> **Pattern:** Rule-Based Alerting + Multi-Channel Delivery + Snooze/Dismiss Management
> **Last Updated:** 2025-10-24

---

## 📋 Overview

The **Reminders** vertical provides an **intelligent alert and notification system** for proactive user engagement based on financial events, patterns, and thresholds. While demonstrated in finance domain (missing payments, low balances, large expenses, due dates), the underlying primitives are domain-agnostic and apply to ANY event-driven notification system across domains.

**Key Characteristics:**
- **Event-Driven Triggers:** Real-time detection of financial events (transaction posted, balance updated, payment missed)
- **Scheduled Checks:** Cron-based evaluation for time-based reminders (due dates, recurring payment expectations)
- **Multi-Channel Delivery:** In-app notifications, email, SMS, push notifications (with user preferences)
- **Rule-Based Configuration:** User-defined alert rules with conditions and thresholds
- **Snooze & Dismiss:** User can defer or dismiss reminders with persistence
- **Delivery Tracking:** Track notification delivery status (sent, read, snoozed, dismissed)
- **Audit Trail:** Full provenance of when/why/how reminders were triggered

**Finance Domain Examples:**
- **Missing Recurring Payment:** "Netflix subscription ($15.99) expected on Oct 15, not detected yet"
- **Low Balance Alert:** "Chase Checking balance below $500 threshold ($485 current)"
- **Large Expense Detected:** "Unusual expense: $2,500 at Apple Store (3x your average)"
- **Payment Due Date:** "Chase Credit Card payment ($1,234) due in 3 days (Oct 18)"
- **Budget Exceeded:** "Dining category budget exceeded: $450 spent of $400 budget this month"

**Multi-Domain Applicability:**
- **Healthcare:** Medication refill reminders, appointment notifications, insurance expiration, test result availability, vaccination due dates
- **Legal:** Court date reminders, filing deadlines, contract expiration, retainer low balance, discovery deadline, statute of limitations
- **Research:** Grant deadline reminders, ethics review expiration, publication milestones, conference submissions, IRB renewal, data retention deadlines
- **E-commerce:** Inventory low stock alerts, price drop notifications, abandoned cart reminders, order status updates, subscription renewal
- **Logistics:** Shipment delay alerts, delivery confirmation, customs clearance status, warehouse capacity warnings, carrier performance alerts

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Event-driven reminder triggers based on financial transactions and account state
- Scheduled reminder checks for time-based alerts (daily 8 AM, hourly, custom cron)
- Multi-condition alert rules (missing payment + amount threshold + account filter)
- Multi-channel notification delivery (in-app, email, SMS, push) with user preferences
- Snooze functionality (defer reminder for 1h, 1d, 1w, custom) with server-side persistence
- Dismiss functionality (mark as read, hide forever) with audit trail
- Reminder history and delivery tracking (sent, delivered, read, snoozed, dismissed)
- Alert rule CRUD operations (create, edit, enable/disable, delete)
- Template-based notifications with dynamic content (transaction details, balance amounts)
- Batch notification processing (combine multiple alerts into digest)

**Out of Scope:**
- Two-way communication (user replies to notifications) - covered in future vertical 4.x Messaging
- Advanced AI predictions (ML-based anomaly detection) - covered in 3.4 Insights (already complete)
- Payment execution from notifications (pay now button) - covered in future 4.x Payments
- Calendar integration (add due dates to Google Calendar) - v2 feature
- Voice notifications (phone calls) - v2 feature
- Real-time streaming for millisecond latency - batch processing acceptable (30s-5m delay)

**Boundaries:**
- Reminder rules reference existing entities (accounts, counterparties, series) from Group 3 registries
- Notification delivery uses external services (email: SendGrid, SMS: Twilio) via adapters
- User must explicitly enable notifications (GDPR compliance, opt-in model)
- Rate limiting prevents notification spam (max 20 notifications/day per user by default)
- Notifications are ephemeral (30-day retention, then archived to cold storage)

---

### 2. User Flow (Real Usage)

**Scenario 1: User receives missing recurring payment alert (auto-detected)**

User: "My Netflix subscription usually posts on the 15th, but I haven't seen it yet. I want to be notified if it's late."

System:
1. User has previously defined Series: "Netflix Subscription" with expected date = 15th of month, amount = $15.99
2. RecurrenceEngine in Vertical 3.3 calculates expected date: Oct 15, 2024
3. On Oct 16, 2024 at 8:00 AM, ReminderEngine runs scheduled check
4. AlertRuleEvaluator detects: No transaction found matching series_id + date range (Oct 15 ± 3 days)
5. ReminderEngine creates notification:
   ```json
   {
     "notification_id": "notif_abc123",
     "type": "missing_recurring_payment",
     "severity": "warning",
     "title": "Missing Payment: Netflix Subscription",
     "body": "Expected payment of $15.99 to Netflix on Oct 15, not detected yet. Last payment: Sep 15.",
     "action_url": "/series/series_netflix_123",
     "action_label": "View Series",
     "created_at": "2024-10-16T08:00:00Z",
     "channels": ["in_app", "email"],
     "metadata": {
       "series_id": "series_netflix_123",
       "expected_amount": 15.99,
       "expected_date": "2024-10-15",
       "days_late": 1
     }
   }
   ```
6. NotificationDispatcher sends:
   - In-app: Badge appears on bell icon (red dot + count)
   - Email: "Reminder: Missing Netflix payment ($15.99)" sent to user@example.com
7. User opens app, sees notification in NotificationPanel
8. User clicks "View Series" → navigates to Series detail (Vertical 3.3)
9. User confirms payment posted on Oct 17 (late but present)
10. User dismisses notification → status updated to "dismissed", removed from unread list

**Scenario 2: User sets up low balance alert (manual configuration)**

User: "I want to be notified if my checking account balance goes below $500"

System:
1. User navigates to Reminders settings
2. Clicks "Create New Alert"
3. ReminderConfigDialog opens:
   ```
   ┌────────────────────────────────────────────────┐
   │ Create New Alert                           [×] │
   ├────────────────────────────────────────────────┤
   │ Alert Type:                                    │
   │ ○ Missing Recurring Payment                    │
   │ ● Low Balance Threshold                        │
   │ ○ Large Expense Detected                       │
   │ ○ Payment Due Date                             │
   │ ○ Custom Condition                             │
   │                                                │
   │ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
   │                                                │
   │ Account:                                       │
   │ [Chase Checking ▼]                             │
   │                                                │
   │ Alert when balance is below:                   │
   │ [$___500.00___]                                │
   │                                                │
   │ Check frequency:                               │
   │ ○ Real-time (when transaction posts)           │
   │ ● Daily (8:00 AM)                              │
   │ ○ Hourly                                       │
   │                                                │
   │ Notification channels:                         │
   │ ☑ In-app notification                          │
   │ ☑ Email (user@example.com)                     │
   │ ☐ SMS (+1-555-0123)                            │
   │                                                │
   │ [Create Alert] [Cancel]                        │
   └────────────────────────────────────────────────┘
   ```
4. User fills form and clicks "Create Alert"
5. System creates reminder_config record:
   ```json
   {
     "config_id": "reminder_low_balance_456",
     "user_id": "user_123",
     "type": "low_balance",
     "enabled": true,
     "conditions": {
       "account_id": "acct_chase_checking",
       "threshold_amount": 500.00,
       "comparison": "less_than"
     },
     "schedule": {
       "type": "cron",
       "expression": "0 8 * * *",  // Daily at 8 AM
       "timezone": "America/Los_Angeles"
     },
     "channels": ["in_app", "email"],
     "created_at": "2024-10-16T09:00:00Z"
   }
   ```
6. Next day (Oct 17 at 8:00 AM), ReminderEngine runs scheduled check
7. AlertRuleEvaluator fetches current balance: $485.00
8. Condition evaluates: $485 < $500 → TRUE
9. NotificationDispatcher creates notification:
   ```
   Title: Low Balance Alert: Chase Checking
   Body: Your Chase Checking account balance is $485.00, below your $500 threshold.
   Action: View Account →
   ```
10. User receives email and in-app notification
11. User clicks "Snooze 1 day" → notification reappears Oct 18 if balance still low

**Scenario 3: User is alerted to large expense (anomaly detection)**

User: "I just made a $2,500 purchase at Apple Store. The system should alert me since this is unusual."

System:
1. User has alert rule: "Large Expense Detected" with threshold = 3× average transaction
2. User's average expense (last 30 days): $850 → threshold = $2,550
3. Transaction posts: -$2,500 to Apple Store (Oct 16, 2024 3:45 PM)
4. ReminderEngine receives real-time event: `transaction.created` webhook
5. AlertRuleEvaluator checks:
   - Is transaction an expense? YES (amount < 0)
   - Is absolute amount > threshold? YES ($2,500 > $850 × 3 = $2,550)? NO (close, but below)
   - Edge case: $2,500 is 2.94× average (just below 3×), no alert triggered
6. User manually lowers threshold to 2× average in settings
7. ReminderEngine re-evaluates historical transactions (last 24h)
8. Finds Apple Store transaction now exceeds 2× threshold
9. Creates notification:
   ```
   Title: Large Expense Detected
   Body: Unusual expense of $2,500 at Apple Store (2.9× your average). Is this expected?
   Actions: [Mark as Expected] [Report Fraud]
   ```
10. User clicks "Mark as Expected" → notification dismissed, transaction tagged `expected_large_expense: true`

**Scenario 4: User receives credit card payment due reminder**

User: "My Chase credit card payment is due on Oct 20. Remind me 3 days before."

System:
1. User has account: "Chase Freedom Credit Card" with `payment_due_date: 20` (field in Account schema)
2. User creates reminder rule:
   ```json
   {
     "type": "payment_due_date",
     "conditions": {
       "account_id": "acct_chase_freedom",
       "days_before_due": 3
     },
     "schedule": {
       "type": "cron",
       "expression": "0 9 * * *"  // Daily at 9 AM
     },
     "channels": ["in_app", "email", "sms"]
   }
   ```
3. On Oct 17, 2024 at 9:00 AM, ReminderEngine runs
4. AlertRuleEvaluator calculates:
   - Due date: Oct 20
   - Days until due: 3
   - Condition: days_until_due == 3 → TRUE
5. Fetches current statement balance: $1,234.56 (from account metadata or external API)
6. Creates notification:
   ```
   Title: Payment Due in 3 Days
   Body: Your Chase Freedom credit card payment of $1,234.56 is due on Oct 20.
   Actions: [Pay Now] [Snooze]
   ```
7. Notification sent via email + SMS (user preference)
8. User clicks "Pay Now" → redirected to payment flow (future vertical 4.x Payments)
9. After payment is made, ReminderEngine detects payment transaction
10. Automatically dismisses reminder (no longer relevant)

**Scenario 5: User snoozes reminder for later review**

User: "I see the low balance alert, but I'm depositing money tomorrow. Remind me again in 2 days."

System:
1. User opens NotificationPanel, sees low balance alert
2. Notification card shows:
   ```
   ┌────────────────────────────────────────────────┐
   │ ⚠️ Low Balance Alert: Chase Checking           │
   ├────────────────────────────────────────────────┤
   │ Your balance is $485.00, below $500 threshold. │
   │                                                │
   │ Oct 17, 2024 8:00 AM                          │
   │                                                │
   │ [View Account] [Snooze ▼] [Dismiss]           │
   └────────────────────────────────────────────────┘
   ```
3. User clicks "Snooze ▼" dropdown:
   ```
   ○ 1 hour
   ○ 4 hours
   ○ 1 day
   ● 2 days
   ○ 1 week
   ○ Custom...
   ```
4. User selects "2 days"
5. System updates notification:
   ```json
   {
     "notification_id": "notif_abc123",
     "status": "snoozed",
     "snoozed_until": "2024-10-19T08:00:00Z",
     "snoozed_by": "user_123",
     "snoozed_at": "2024-10-17T10:30:00Z"
   }
   ```
6. Notification removed from unread list, added to snoozed list
7. On Oct 19 at 8:00 AM, ReminderEngine re-evaluates condition
8. If balance still < $500, notification reappears in unread list
9. If balance >= $500 (deposit posted), notification auto-dismissed

**Scenario 6: User views notification history and delivery status**

User: "I want to see all the reminders I received this month."

System:
1. User navigates to Reminders → History
2. UI shows table:
   ```
   ┌─────────────────────────────────────────────────────────────────┐
   │ Notification History (October 2024)                             │
   ├──────────────┬──────────────────┬──────────┬────────┬──────────┤
   │ Date         │ Title            │ Type     │ Status │ Channels │
   ├──────────────┼──────────────────┼──────────┼────────┼──────────┤
   │ Oct 17 8:00  │ Low Balance      │ warning  │ Read   │ 📧 ✅    │
   │ Oct 16 8:00  │ Missing Netflix  │ warning  │ Dis... │ 📧 ✅    │
   │ Oct 15 9:00  │ Payment Due      │ info     │ Dis... │ 📧 ✅ 💬 │
   │ Oct 14 8:00  │ Large Expense    │ alert    │ Dis... │ 📧 ✅    │
   │ Oct 10 8:00  │ Budget Exceeded  │ warning  │ Dis... │ 📧 ✅    │
   └──────────────┴──────────────────┴──────────┴────────┴──────────┘
   ```
3. User clicks on "Low Balance" notification
4. Detail view shows:
   ```
   ┌────────────────────────────────────────────────┐
   │ Low Balance Alert: Chase Checking              │
   ├────────────────────────────────────────────────┤
   │ Created: Oct 17, 2024 8:00 AM                  │
   │ Status: Read                                   │
   │                                                │
   │ Delivery Log:                                  │
   │ ✅ In-app: Delivered at 8:00 AM, read 10:30 AM │
   │ ✅ Email: Sent 8:00 AM, opened 10:32 AM        │
   │                                                │
   │ Triggered by rule:                             │
   │ "Low Balance: Chase Checking < $500"           │
   │                                                │
   │ Condition evaluated:                           │
   │ Balance: $485.00 < Threshold: $500.00 ✓        │
   │                                                │
   │ [Dismiss] [View Account]                       │
   └────────────────────────────────────────────────┘
   ```
5. User sees full audit trail of notification lifecycle

---

### 3. States & Transitions

**ReminderConfig States:**
```
┌──────────┐
│  DRAFT   │ ← User creating new alert rule (not saved yet)
└────┬─────┘
     │ .save()
     ↓
┌──────────┐
│ ENABLED  │ ← Active alert rule, being evaluated
└────┬─────┘
     │ .disable()
     ↓
┌──────────┐
│ DISABLED │ ← Paused, not evaluated (user can re-enable)
└────┬─────┘
     │ .delete()
     ↓
┌──────────┐
│ DELETED  │ ← Soft-deleted (retention for 30 days)
└──────────┘
```

**Notification States:**
```
┌──────────┐
│ PENDING  │ ← Created, queued for delivery
└────┬─────┘
     │ NotificationDispatcher.send()
     ↓
┌──────────┐
│   SENT   │ ← Dispatched to channel (email sent, push queued)
└────┬─────┘
     │ User receives
     ↓
┌──────────┐     ┌──────────┐     ┌──────────┐
│ DELIVERED│ ──→ │   READ   │ ──→ │ DISMISSED│
└──────────┘     └────┬─────┘     └──────────┘
     │                │
     │ .snooze()      │ .snooze()
     ↓                ↓
┌──────────┐     ┌──────────┐
│ SNOOZED  │ ──→ │ DELIVERED│ (re-surface after snooze expires)
└──────────┘     └──────────┘
     │
     │ Auto-dismiss if condition no longer true
     ↓
┌──────────┐
│AUTO_DISM.│ ← System dismissed (e.g., payment posted)
└──────────┘
```

**State Transition Rules:**
- PENDING → SENT: Automatic, triggered by NotificationDispatcher
- SENT → DELIVERED: Confirmed by delivery service (email opened, push received)
- DELIVERED → READ: User opens notification in UI
- READ → DISMISSED: User clicks "Dismiss" or system auto-dismisses
- DELIVERED → SNOOZED: User clicks "Snooze" with duration
- SNOOZED → DELIVERED: Snooze duration expires + condition still true
- SNOOZED → AUTO_DISMISSED: Condition no longer true (e.g., balance above threshold)

**Edge Cases:**
- User snoozes notification, then deletes the reminder rule → Notification auto-dismissed on next check
- Notification sent via email, but email bounces → Status = FAILED, retry 3× with exponential backoff
- User disables reminder rule while notification is pending → Notification cancelled (not sent)
- Snooze duration expires, but user is in "Do Not Disturb" mode (11 PM - 7 AM) → Notification delayed until 7 AM

---

### 4. Edge Cases

**1. Duplicate Notification Prevention**

Problem: User has 2 alerts for low balance (one at $500, one at $400). Balance drops to $350. Should system send 2 notifications?

Solution:
- NotificationDispatcher deduplicates notifications with same `dedup_key` within 24h window
- `dedup_key = hash(type + account_id + date)` → "low_balance:acct_123:2024-10-17"
- If notification with same dedup_key exists and is SENT/DELIVERED/READ, skip new notification
- If user has 2 rules, send 1 notification with combined context:
  ```
  Title: Low Balance Alert: Chase Checking
  Body: Your balance ($350) is below your thresholds: $500 (Alert 1) and $400 (Alert 2).
  ```

**2. Timezone Handling for Scheduled Reminders**

Problem: User in Los Angeles (PST) wants daily reminder at 8 AM PST. System runs on UTC. What time should cron run?

Solution:
- Store user timezone in `reminder_config.schedule.timezone: "America/Los_Angeles"`
- Convert cron expression to UTC at schedule time (8 AM PST = 4 PM UTC)
- Handle DST transitions: Re-calculate UTC offset twice per year (spring forward, fall back)
- If DST changes during snooze period, adjust snooze_until timestamp accordingly

**3. Missing Data for Alert Evaluation**

Problem: User creates alert "Notify if Chase balance < $500", but account balance is not synced (external API failed). Should system alert?

Solution:
- AlertRuleEvaluator checks data freshness: `last_synced_at` timestamp
- If data older than 24h, skip evaluation + log warning: `Alert skipped: stale data`
- Send separate notification to user: "Unable to check balance alerts due to sync failure"
- Retry evaluation every hour until data is fresh

**4. Snooze Expiration During Condition Resolution**

Problem: User snoozes "low balance" alert for 2 days. Before snooze expires, user deposits $1,000 (balance now $1,485). Should notification reappear?

Solution:
- When snooze expires, ReminderEngine re-evaluates condition
- If condition is FALSE (balance >= $500), auto-dismiss notification with status `AUTO_DISMISSED`
- Log reason: `Condition resolved: balance increased to $1,485`
- Do NOT send notification (saves user from irrelevant alerts)

**5. Rapid Condition Oscillation**

Problem: User balance oscillates around $500 threshold: $510 → $490 → $505 → $495. System sends 4 alerts in 1 day?

Solution:
- Implement **cooldown period**: After sending notification, wait 24h before sending another for same condition
- Store `last_notified_at` timestamp in notification_event table
- AlertRuleEvaluator checks: `if now - last_notified_at < cooldown_period, skip`
- User can configure cooldown per rule (default: 24h, min: 1h, max: 7 days)

**6. User Deletes Alert Rule While Notification Pending**

Problem: User creates alert, notification queued (PENDING), then user deletes alert rule before notification is sent. Should system still send?

Solution:
- NotificationDispatcher checks `reminder_config.enabled` before sending
- If rule is DISABLED or DELETED, mark notification as CANCELLED
- Log: `Notification cancelled: rule deleted by user`
- Do NOT send notification (respect user intent)

**7. Email Bounces or SMS Delivery Fails**

Problem: User's email address is invalid, or SMS number is disconnected. Notification fails to deliver.

Solution:
- NotificationDispatcher receives delivery webhook from SendGrid/Twilio
- Update notification status: SENT → FAILED with error reason: `Email bounced: invalid address`
- Retry 3× with exponential backoff: 5 min, 30 min, 2h
- After 3 failures, mark as PERMANENTLY_FAILED
- Send in-app notification: "Unable to deliver email notification to user@example.com. Please update your email."
- User can update contact info, then manually retry failed notifications

**8. User in Multiple Timezones (Travel)**

Problem: User creates alert in Los Angeles (PST), then travels to New York (EST). Should alert fire at 8 AM PST or 8 AM EST?

Solution:
- Reminder config stores `timezone: "America/Los_Angeles"` (set at creation time)
- Alert ALWAYS fires at 8 AM in configured timezone, regardless of user's current location
- User can edit alert to change timezone if needed
- UI shows: "This alert fires at 8:00 AM Pacific Time (currently 11:00 AM Eastern Time)"

**9. High-Frequency Events Causing Alert Spam**

Problem: User has alert "Large expense > $100". User makes 20 transactions in 1 hour. System sends 20 notifications?

Solution:
- Implement **rate limiting**: Max 20 notifications per day per user (configurable)
- If limit reached, batch remaining alerts into digest: "You have 15 more large expense alerts. [View All]"
- Send digest once per day (configurable time, default: 6 PM)
- User can increase rate limit in settings (max: 100/day)

**10. Notification Preferences Override**

Problem: User enables email notifications for "Low Balance" alert, but later disables ALL email notifications globally. Which setting wins?

Solution:
- Global notification preferences ALWAYS override rule-specific preferences
- Precedence: User Global Preferences > Rule Preferences > System Defaults
- If user disables email globally, NO email notifications sent (regardless of rule settings)
- UI shows warning in rule editor: "⚠️ Email notifications are disabled in your global settings"

---

### 5. Performance Requirements

**Latency:**
- **Real-time alerts:** Notification created within 30 seconds of triggering event (transaction post)
- **Scheduled alerts:** Evaluation completes within 5 minutes of scheduled time
- **Notification delivery:** In-app notification delivered within 5 seconds, email within 2 minutes, SMS within 30 seconds
- **Snooze action:** UI update within 500ms, server persistence within 2 seconds
- **Dismiss action:** UI update within 500ms, server persistence within 2 seconds
- **Rule evaluation:** 1,000 rules evaluated in < 10 seconds (per-user rules, not global)

**Throughput:**
- **Bulk evaluation:** Support 10,000 users × 10 rules each = 100,000 rule evaluations per scheduled run
- **Notification delivery:** 10,000 notifications sent per minute across all channels
- **Webhook processing:** Handle 1,000 transaction.created events per second (real-time triggers)

**Scalability:**
- **User growth:** Support 100,000 users with average 5 reminder rules each = 500,000 active rules
- **Notification retention:** Store 30 days of notifications (estimated 10M records), archive older to S3

**Availability:**
- **Uptime:** 99.5% (acceptable: reminder is not mission-critical, brief outages tolerable)
- **Degraded mode:** If email service is down, queue notifications for retry (24h buffer)

**Performance Optimization Strategies:**
- **Indexing:** Database indexes on `reminder_config.user_id`, `notification_event.status`, `notification_event.created_at`
- **Caching:** Cache active reminder rules in Redis (invalidate on update)
- **Batch processing:** Evaluate scheduled rules in batches of 1,000 users (parallel workers)
- **Async delivery:** Use message queue (RabbitMQ) for notification dispatch (decouple evaluation from delivery)

---

### 6. Dependencies

**Internal Dependencies (Existing Verticals):**
- **1.3 Normalization:** Fetch canonical transactions for alert evaluation (missing payments, large expenses)
- **3.1 Account Registry:** Reference accounts in alert conditions (balance thresholds, payment due dates)
- **3.2 Counterparty Registry:** Filter alerts by merchant (e.g., "Alert when spending at Amazon > $500/month")
- **3.3 Series Registry:** Detect missing recurring payments (expected vs actual)
- **3.4 Tax Categorization:** Filter alerts by category (e.g., "Alert if Dining > $400/month")
- **3.6 Unit:** Handle multi-currency thresholds (convert to user's base currency)
- **2.1 Transaction List View:** Notification action links to filtered transaction view

**External Dependencies:**
- **Email Service:** SendGrid or AWS SES for email delivery with webhook callbacks
- **SMS Service:** Twilio or AWS SNS for SMS delivery with delivery receipts
- **Push Notification Service:** Firebase Cloud Messaging (FCM) or Apple Push Notification Service (APNS)
- **Scheduler:** Cron daemon or AWS EventBridge for scheduled rule evaluation
- **Message Queue:** RabbitMQ or AWS SQS for async notification dispatch

**Database Dependencies:**
- **PostgreSQL:** Primary database for reminder_config and notification_event tables
- **Redis:** Cache for active reminder rules and recent notification dedup keys

**API Dependencies:**
- **Account Balance API:** External banking API or plaid.com for real-time balance checks (if not using local sync)
- **Timezone Database:** IANA timezone database for DST-aware scheduling

---

### 7. Inputs & Outputs

**Inputs:**

1. **Reminder Configuration (User-Defined)**
   ```json
   {
     "config_id": "reminder_123",
     "user_id": "user_456",
     "type": "low_balance",
     "name": "Low Balance Alert: Chase Checking",
     "enabled": true,
     "conditions": {
       "account_id": "acct_chase_checking",
       "threshold_amount": 500.00,
       "comparison": "less_than"
     },
     "schedule": {
       "type": "cron",
       "expression": "0 8 * * *",
       "timezone": "America/Los_Angeles"
     },
     "channels": ["in_app", "email"],
     "preferences": {
       "cooldown_hours": 24,
       "rate_limit_per_day": 5
     }
   }
   ```

2. **Real-Time Event (Transaction Posted)**
   ```json
   {
     "event_type": "transaction.created",
     "event_id": "evt_abc123",
     "timestamp": "2024-10-17T15:30:00Z",
     "data": {
       "transaction_id": "txn_789",
       "account_id": "acct_chase_checking",
       "amount": -2500.00,
       "merchant": "Apple Store",
       "date": "2024-10-17"
     }
   }
   ```

3. **Scheduled Trigger (Cron Job)**
   ```json
   {
     "trigger_type": "scheduled",
     "schedule_time": "2024-10-17T08:00:00Z",
     "rules_to_evaluate": ["reminder_123", "reminder_456", "..."]
   }
   ```

4. **User Action (Snooze Request)**
   ```json
   {
     "action": "snooze",
     "notification_id": "notif_abc123",
     "user_id": "user_456",
     "snooze_duration_seconds": 172800,  // 2 days
     "requested_at": "2024-10-17T10:30:00Z"
   }
   ```

**Outputs:**

1. **Notification Event (Created)**
   ```json
   {
     "notification_id": "notif_abc123",
     "user_id": "user_456",
     "config_id": "reminder_123",
     "type": "low_balance",
     "severity": "warning",
     "title": "Low Balance Alert: Chase Checking",
     "body": "Your balance is $485.00, below your $500 threshold.",
     "action_url": "/accounts/acct_chase_checking",
     "action_label": "View Account",
     "status": "pending",
     "channels": ["in_app", "email"],
     "created_at": "2024-10-17T08:00:00Z",
     "metadata": {
       "account_id": "acct_chase_checking",
       "current_balance": 485.00,
       "threshold": 500.00
     }
   }
   ```

2. **Email Payload (SendGrid)**
   ```json
   {
     "to": "user@example.com",
     "from": "alerts@financeapp.com",
     "subject": "Low Balance Alert: Chase Checking",
     "template_id": "low_balance_alert_v1",
     "template_data": {
       "user_name": "John Doe",
       "account_name": "Chase Checking",
       "current_balance": "$485.00",
       "threshold": "$500.00",
       "action_url": "https://app.financeapp.com/accounts/acct_chase_checking"
     }
   }
   ```

3. **In-App Notification (WebSocket Push)**
   ```json
   {
     "channel": "user_456_notifications",
     "event": "notification.created",
     "payload": {
       "notification_id": "notif_abc123",
       "title": "Low Balance Alert",
       "body": "Your balance is $485.00",
       "icon": "warning",
       "timestamp": "2024-10-17T08:00:00Z",
       "unread_count": 3
     }
   }
   ```

4. **Delivery Receipt (Email Opened)**
   ```json
   {
     "notification_id": "notif_abc123",
     "channel": "email",
     "status": "delivered",
     "delivered_at": "2024-10-17T08:01:30Z",
     "opened_at": "2024-10-17T10:32:00Z",
     "provider_message_id": "sendgrid_msg_xyz"
   }
   ```

---

### 8. Validation Rules

**Reminder Configuration Validation:**
- `config_id`: Required, unique per user, format: `reminder_{random}`
- `user_id`: Required, must reference existing user
- `type`: Required, enum: ["low_balance", "missing_recurring_payment", "large_expense", "payment_due_date", "budget_exceeded", "custom"]
- `name`: Required, max 100 characters, user-friendly label
- `enabled`: Required, boolean (default: true)
- `conditions`: Required, object, validation depends on `type`:
  - `low_balance`: Requires `account_id`, `threshold_amount` (> 0), `comparison` (enum: ["less_than", "greater_than"])
  - `missing_recurring_payment`: Requires `series_id`, `days_late_threshold` (default: 3)
  - `large_expense`: Requires `threshold_amount` OR `threshold_multiplier` (e.g., 3× average)
  - `payment_due_date`: Requires `account_id`, `days_before_due` (1-30)
- `schedule`: Required for scheduled types, optional for real-time types
  - `type`: enum: ["cron", "real_time"]
  - `expression`: Required if type=cron, valid cron syntax (validated by croniter library)
  - `timezone`: Required if type=cron, valid IANA timezone (e.g., "America/Los_Angeles")
- `channels`: Required, non-empty array, values: ["in_app", "email", "sms", "push"]
  - Must respect user's global notification preferences (email disabled globally → remove "email" from channels)
- `preferences.cooldown_hours`: Optional, integer 1-168 (1 hour to 7 days), default: 24
- `preferences.rate_limit_per_day`: Optional, integer 1-100, default: 20

**Notification Event Validation:**
- `notification_id`: Required, unique globally, format: `notif_{random}`
- `user_id`: Required, must reference existing user
- `config_id`: Optional (can be null for system-generated notifications)
- `type`: Required, same enum as reminder config
- `severity`: Required, enum: ["info", "warning", "alert", "critical"]
- `title`: Required, max 200 characters
- `body`: Required, max 1000 characters
- `action_url`: Optional, valid URL path or external URL
- `action_label`: Optional, max 50 characters (default: "View")
- `status`: Required, enum: ["pending", "sent", "delivered", "read", "snoozed", "dismissed", "auto_dismissed", "failed", "cancelled"]
- `channels`: Required, non-empty array (subset of config.channels)
- `snoozed_until`: Required if status=snoozed, ISO 8601 datetime in future
- `metadata`: Optional, JSON object, max 10KB

**Snooze Action Validation:**
- `notification_id`: Required, must exist and status must be "delivered" or "read"
- `snooze_duration_seconds`: Required, integer 3600-604800 (1 hour to 7 days)
- `user_id`: Required, must own the notification

**Dismiss Action Validation:**
- `notification_id`: Required, must exist and status must be "delivered" or "read" or "snoozed"
- `user_id`: Required, must own the notification

---

### 9. Error Handling

**Evaluation Errors:**

1. **Condition Evaluation Failed (Stale Data)**
   ```
   Error: Cannot evaluate alert "Low Balance: Chase Checking" - account balance not synced (last sync: 3 days ago)
   Recovery: Skip evaluation, log warning, send user notification: "Unable to check balance alerts"
   Retry: Re-evaluate on next scheduled run (1 hour later)
   ```

2. **Missing Referenced Entity (Account Deleted)**
   ```
   Error: Alert rule references account_id="acct_123" which no longer exists (deleted by user)
   Recovery: Auto-disable alert rule, send user notification: "Alert disabled: referenced account was deleted"
   User Action: User must edit or delete the alert rule
   ```

3. **Invalid Cron Expression**
   ```
   Error: Cron expression "0 25 * * *" is invalid (hour must be 0-23)
   Recovery: Reject reminder config creation, return 400 Bad Request with error message
   UI Validation: Validate cron syntax client-side before submission
   ```

**Delivery Errors:**

4. **Email Delivery Failed (Bounced)**
   ```
   Error: Email to user@example.com bounced (reason: "Address does not exist")
   Recovery:
     1. Mark notification as FAILED
     2. Retry 3× with exponential backoff (5 min, 30 min, 2h)
     3. After 3 failures, mark as PERMANENTLY_FAILED
     4. Send in-app notification to user: "Update your email address"
   ```

5. **SMS Delivery Failed (Invalid Number)**
   ```
   Error: SMS to +1-555-0123 failed (reason: "Number is not reachable")
   Recovery: Same as email (retry 3×, then PERMANENTLY_FAILED)
   ```

6. **Push Notification Failed (Device Token Expired)**
   ```
   Error: Push notification failed (reason: "FCM token expired")
   Recovery:
     1. Remove expired token from user's device registry
     2. Send in-app notification instead (fallback channel)
     3. Log warning: User needs to re-login to refresh push token
   ```

**Rate Limiting Errors:**

7. **User Rate Limit Exceeded**
   ```
   Error: User user_123 has received 20 notifications today (limit reached)
   Recovery:
     1. Queue notification for digest (send at 6 PM daily)
     2. Log: "Notification queued for digest due to rate limit"
     3. Do NOT send individual notification
   ```

8. **Global Rate Limit Exceeded (System Overload)**
   ```
   Error: System is sending > 10,000 notifications/minute (circuit breaker triggered)
   Recovery:
     1. Queue notifications in RabbitMQ (buffer up to 1M messages)
     2. Process queue at reduced rate (5,000/minute)
     3. Send admin alert: "Notification system under heavy load"
   ```

**Idempotency Errors:**

9. **Duplicate Notification Detected**
   ```
   Error: Notification with dedup_key="low_balance:acct_123:2024-10-17" already sent 2 hours ago
   Recovery: Skip notification creation, log: "Duplicate notification suppressed"
   ```

10. **Concurrent Snooze/Dismiss Actions**
    ```
    Error: User clicked "Snooze" and "Dismiss" simultaneously (race condition)
    Recovery:
      1. Use database optimistic locking (UPDATE WHERE version = X)
      2. First action wins (e.g., Snooze), second returns 409 Conflict
      3. UI shows error: "Notification already snoozed, please refresh"
    ```

**Timezone Errors:**

11. **Invalid Timezone**
    ```
    Error: Timezone "America/LosAngeles" is invalid (typo: should be "America/Los_Angeles")
    Recovery: Reject reminder config creation, return 400 Bad Request
    UI: Use dropdown with valid IANA timezones (not free text)
    ```

12. **DST Transition Handling**
    ```
    Edge Case: User schedules alert at "2:30 AM" on DST transition day (2:00 AM → 3:00 AM, 2:30 AM doesn't exist)
    Recovery:
      1. Detect DST gap (2:30 AM missing)
      2. Adjust to 3:00 AM (next valid time after DST transition)
      3. Log: "Alert time adjusted for DST: 2:30 AM → 3:00 AM"
    ```

---

### 10. Example Scenarios

**Scenario 1: Multi-Account Low Balance Alert**

Context: User has 3 checking accounts, wants single alert if ANY balance < $500

Reminder Config:
```json
{
  "type": "low_balance",
  "name": "Multi-Account Low Balance",
  "conditions": {
    "account_ids": ["acct_chase", "acct_bofa", "acct_wells"],
    "threshold_amount": 500.00,
    "aggregation": "any"  // Alert if ANY account below threshold
  },
  "schedule": {
    "type": "cron",
    "expression": "0 8 * * *"
  }
}
```

Notification:
```
Title: Low Balance Alert
Body: 2 accounts are below $500 threshold:
  - Chase Checking: $485.00
  - Bank of America Checking: $320.00

Wells Fargo Checking is OK: $1,250.00

[View Accounts]
```

**Scenario 2: Category Budget Exceeded**

Context: User sets monthly budget for "Dining" category = $400. Alert when 90% spent.

Reminder Config:
```json
{
  "type": "budget_exceeded",
  "conditions": {
    "category": "Dining",
    "budget_amount": 400.00,
    "threshold_pct": 0.90,  // Alert at 90% = $360
    "period": "monthly"
  },
  "schedule": {
    "type": "real_time"  // Alert immediately when transaction posts
  }
}
```

Flow:
1. User spends $50 at restaurant (Oct 17, 3:00 PM)
2. Month-to-date Dining spending: $310 → $360
3. $360 / $400 = 90% → threshold met
4. Notification sent immediately:
   ```
   Title: Budget Alert: Dining
   Body: You've spent $360 of $400 budget this month (90%). $40 remaining.
   ```

**Scenario 3: Unusual Merchant Alert**

Context: User wants to be notified of ANY transaction at specific merchant (e.g., "Casino")

Reminder Config:
```json
{
  "type": "merchant_watchlist",
  "conditions": {
    "merchant_patterns": ["*Casino*", "*Gambling*", "*Poker*"],
    "amount_threshold": 0.01  // Any amount
  },
  "schedule": {
    "type": "real_time"
  },
  "channels": ["in_app", "email", "sms"]  // High priority
}
```

Notification:
```
Title: Watchlist Alert: Casino Transaction
Body: Transaction detected at "MGM Grand Casino" for $150.00 on Oct 17.
[View Transaction] [Report Fraud]
```

**Scenario 4: Subscription Renewal Reminder**

Context: User has 10 subscriptions (Netflix, Spotify, etc.), wants reminder 1 day before each renewal

Reminder Config:
```json
{
  "type": "series_upcoming",
  "conditions": {
    "series_tags": ["subscription"],  // All series tagged as subscription
    "days_before": 1
  },
  "schedule": {
    "type": "cron",
    "expression": "0 9 * * *"  // Daily at 9 AM
  }
}
```

Notification:
```
Title: Subscription Renewal Tomorrow
Body: Netflix subscription ($15.99) will renew tomorrow (Oct 18).
[View Series] [Cancel Subscription]
```

**Scenario 5: Income Deposit Confirmation**

Context: User expects paycheck deposit every 2 weeks (bi-weekly), wants confirmation when it posts

Reminder Config:
```json
{
  "type": "expected_income",
  "conditions": {
    "series_id": "series_paycheck",
    "notification_on": "posted"  // Alert when income POSTS (not missing)
  },
  "schedule": {
    "type": "real_time"
  }
}
```

Notification:
```
Title: Paycheck Deposited
Body: Your paycheck of $3,500.00 has been deposited to Chase Checking.
[View Transaction]
```

**Scenario 6: Multi-Domain Example: Healthcare Medication Refill**

Context: Patient has prescription that needs refill every 30 days

Reminder Config:
```json
{
  "type": "medication_refill",
  "conditions": {
    "medication_name": "Lisinopril 10mg",
    "refill_schedule": "every_30_days",
    "last_refill_date": "2024-09-17",
    "days_before_empty": 7  // Alert 7 days before running out
  },
  "schedule": {
    "type": "cron",
    "expression": "0 10 * * *"
  }
}
```

Notification:
```
Title: Medication Refill Reminder
Body: Your Lisinopril prescription will run out in 7 days (Oct 24). Request refill now.
[Request Refill] [Snooze]
```

**Scenario 7: Multi-Domain Example: Legal Filing Deadline**

Context: Attorney has court filing deadline, wants reminder 7 days before + 1 day before

Reminder Config (2 rules):
```json
[
  {
    "type": "legal_deadline",
    "conditions": {
      "case_id": "case_12345",
      "deadline_type": "motion_filing",
      "deadline_date": "2024-11-01",
      "days_before": 7
    }
  },
  {
    "type": "legal_deadline",
    "conditions": {
      "case_id": "case_12345",
      "deadline_type": "motion_filing",
      "deadline_date": "2024-11-01",
      "days_before": 1
    },
    "channels": ["in_app", "email", "sms"]  // High priority for 1-day reminder
  }
]
```

Notifications:
```
Oct 25: "Motion filing due in 7 days (Case #12345, Nov 1)"
Oct 31: "URGENT: Motion filing due TOMORROW (Case #12345, Nov 1)" [sent via email + SMS]
```

**Scenario 8: Multi-Domain Example: Research Grant Deadline**

Context: Researcher has grant application deadline, wants reminders at 30 days, 7 days, 1 day

Reminder Config:
```json
{
  "type": "grant_deadline",
  "conditions": {
    "grant_id": "NSF_2024_XYZ",
    "deadline_date": "2024-12-15",
    "reminder_days": [30, 7, 1]  // Multiple reminder points
  }
}
```

Notifications:
```
Nov 15: "Grant deadline in 30 days (NSF 2024-XYZ, Dec 15)"
Dec 8: "Grant deadline in 7 days (NSF 2024-XYZ, Dec 15)"
Dec 14: "URGENT: Grant deadline TOMORROW (NSF 2024-XYZ, Dec 15)"
```

---

## Machinery Layer (Sections 11-15)

### 11. Core Primitives (OL)

This vertical introduces **4 new OL primitives** for reminder management:

#### 11.1 ReminderEngine (Orchestrator)
**Purpose:** Core orchestrator for creating, scheduling, and triggering reminders

**Methods:**
- `create_reminder_config(user_id, type, conditions, schedule, channels) → ReminderConfig`
- `update_reminder_config(config_id, updates) → ReminderConfig`
- `delete_reminder_config(config_id) → void`
- `enable_reminder(config_id) → void`
- `disable_reminder(config_id) → void`
- `evaluate_scheduled_rules(schedule_time) → List[NotificationEvent]`
- `process_realtime_event(event_type, event_data) → List[NotificationEvent]`

**Multi-Domain Examples:** See [ReminderEngine.md](../primitives/ol/ReminderEngine.md)

#### 11.2 AlertRuleEvaluator (Condition Checker)
**Purpose:** Evaluate alert conditions against current system state (balances, transactions, dates)

**Methods:**
- `evaluate_condition(config_id, current_state) → bool`
- `check_missing_payment(series_id, date_range) → MissingPaymentResult`
- `check_balance_threshold(account_id, threshold, comparison) → BalanceCheckResult`
- `check_large_expense(transaction, threshold_multiplier) → bool`
- `check_payment_due(account_id, days_before) → DueDateCheckResult`

**Multi-Domain Examples:** See [AlertRuleEvaluator.md](../primitives/ol/AlertRuleEvaluator.md)

#### 11.3 NotificationDispatcher (Multi-Channel Delivery)
**Purpose:** Dispatch notifications to multiple channels (in-app, email, SMS, push) with delivery tracking

**Methods:**
- `send_notification(notification_id, channels) → DeliveryReceipt`
- `send_email(notification_id, template_id, recipient) → EmailReceipt`
- `send_sms(notification_id, message, phone_number) → SmsReceipt`
- `send_push(notification_id, device_tokens) → PushReceipt`
- `send_inapp(notification_id, user_id) → void`
- `process_delivery_webhook(provider, webhook_data) → void`

**Multi-Domain Examples:** See [NotificationDispatcher.md](../primitives/ol/NotificationDispatcher.md)

#### 11.4 ReminderStore (CRUD & State Management)
**Purpose:** CRUD operations for reminder configurations and notification events with snooze/dismiss tracking

**Methods:**
- `save_config(config_data) → ReminderConfig`
- `get_config(config_id) → ReminderConfig`
- `list_user_configs(user_id, filters) → List[ReminderConfig]`
- `create_notification(notification_data) → NotificationEvent`
- `update_notification_status(notification_id, status, metadata) → void`
- `snooze_notification(notification_id, snooze_until) → void`
- `dismiss_notification(notification_id, reason) → void`
- `get_unread_notifications(user_id) → List[NotificationEvent]`

**Multi-Domain Examples:** See [ReminderStore.md](../primitives/ol/ReminderStore.md)

---

### 12. Interface Components (IL)

This vertical introduces **3 new IL components** for reminder UI:

#### 12.1 ReminderBell (Header Icon)
**Purpose:** Header bell icon with unread count badge, opens NotificationPanel on click

**Props:**
```typescript
interface ReminderBellProps {
  userId: string;
  unreadCount: number;
  onOpen: () => void;
  maxDisplayCount?: number;  // Default: 99 (shows "99+" if exceeded)
}
```

**Multi-Domain Examples:** See [ReminderBell.md](../primitives/il/ReminderBell.md)

#### 12.2 NotificationPanel (Slide-In Panel)
**Purpose:** Slide-in panel showing active alerts with tabs (Unread, Snoozed, All)

**Props:**
```typescript
interface NotificationPanelProps {
  userId: string;
  isOpen: boolean;
  onClose: () => void;
  onNotificationClick: (notificationId: string) => void;
  onSnooze: (notificationId: string, duration: number) => void;
  onDismiss: (notificationId: string) => void;
}
```

**Multi-Domain Examples:** See [NotificationPanel.md](../primitives/il/NotificationPanel.md)

#### 12.3 ReminderConfigDialog (Modal)
**Purpose:** Modal dialog for creating and editing reminder rules

**Props:**
```typescript
interface ReminderConfigDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (config: ReminderConfig) => void;
  initialConfig?: ReminderConfig;  // For editing existing rule
  availableAccounts: Account[];
  availableSeries: Series[];
}
```

**Multi-Domain Examples:** See [ReminderConfigDialog.md](../primitives/il/ReminderConfigDialog.md)

---

### 13. Reusability (Multi-Domain Generalization)

**Core Insight:** The Reminders vertical is NOT finance-specific. It's a **generic event-driven notification system** that can alert users about ANY condition across ANY domain.

**Generic Pattern:**
```typescript
interface RemindableEvent<T> {
  event_type: string;                    // "balance_below_threshold", "medication_refill_due", "deadline_approaching"
  entity_type: string;                   // "account", "prescription", "grant_application"
  entity_id: string;                     // Domain-specific entity reference
  trigger_condition: Condition<T>;       // Generic condition evaluator
  notification_template: NotificationTemplate;
  delivery_channels: DeliveryChannel[];
  recurrence?: RecurrencePattern;
}

interface Condition<T> {
  evaluate(current_state: T) -> boolean;
  get_metadata() -> object;              // Context for notification body
}
```

**Multi-Domain Mapping:**

| Domain | Event Type | Entity | Condition Example | Notification |
|--------|-----------|--------|-------------------|--------------|
| **Finance** | `balance_below_threshold` | Account | `balance < $500` | "Chase Checking: $485 (below $500)" |
| **Healthcare** | `medication_refill_due` | Prescription | `days_until_empty < 7` | "Lisinopril refill needed in 7 days" |
| **Legal** | `deadline_approaching` | Case Filing | `days_until_deadline < 7` | "Motion due in 7 days (Case #12345)" |
| **Research** | `grant_deadline` | Grant App | `days_until_deadline < 30` | "NSF grant due in 30 days" |
| **E-commerce** | `inventory_low_stock` | Product SKU | `stock_quantity < reorder_point` | "Product ABC low stock: 5 units left" |
| **Logistics** | `shipment_delayed` | Shipment | `current_date > expected_delivery + 2` | "Shipment #789 delayed 2 days" |

**Configuration Abstraction:**

Finance Domain (Specific):
```json
{
  "type": "low_balance",
  "conditions": {
    "account_id": "acct_123",
    "threshold_amount": 500.00
  }
}
```

Generic Domain (Abstract):
```json
{
  "type": "threshold_alert",
  "entity_type": "account",
  "entity_id": "acct_123",
  "conditions": {
    "metric": "balance",
    "operator": "less_than",
    "threshold": 500.00
  }
}
```

Healthcare Domain (Reuse):
```json
{
  "type": "threshold_alert",
  "entity_type": "prescription",
  "entity_id": "rx_456",
  "conditions": {
    "metric": "days_until_refill",
    "operator": "less_than",
    "threshold": 7
  }
}
```

**Delivery Channel Abstraction:**

All domains use SAME delivery primitives:
- `NotificationDispatcher.send_email()` works for finance alerts, legal deadlines, research grants
- `NotificationDispatcher.send_sms()` works for medication reminders, shipment delays
- Template system allows domain-specific content while reusing delivery infrastructure

**Scheduler Abstraction:**

All domains use SAME scheduler:
- Finance: Daily 8 AM check for low balance
- Healthcare: Daily 10 AM check for medication refills
- Legal: Daily 9 AM check for approaching deadlines
- Research: Weekly check for grant deadlines

Implementation: Single `ReminderEngine.evaluate_scheduled_rules()` method handles ALL domains

---

### 14. Pattern Abstraction

**Generic Reminder Pattern:**

```typescript
// Domain-agnostic reminder configuration
interface GenericReminderConfig<TCondition, TEntity> {
  config_id: string;
  user_id: string;
  name: string;
  enabled: boolean;

  // Entity being monitored
  entity_type: string;
  entity_id: string;

  // Condition evaluator (domain-specific)
  condition: TCondition;

  // Trigger strategy
  trigger: {
    type: "scheduled" | "real_time" | "hybrid";
    schedule?: CronExpression;
    event_types?: string[];  // For real-time triggers
  };

  // Notification delivery
  notification_template: {
    title_template: string;
    body_template: string;
    severity: "info" | "warning" | "alert" | "critical";
    action_url_template: string;
  };

  channels: DeliveryChannel[];
  preferences: ReminderPreferences;
}

// Domain-specific condition implementations
interface FinanceCondition {
  type: "balance_threshold" | "missing_payment" | "large_expense";
  params: {
    account_id?: string;
    threshold_amount?: number;
    comparison?: "less_than" | "greater_than";
    series_id?: string;
    multiplier?: number;
  };
}

interface HealthcareCondition {
  type: "medication_refill" | "appointment_reminder" | "test_result";
  params: {
    prescription_id?: string;
    days_before_empty?: number;
    appointment_id?: string;
    days_before_appointment?: number;
  };
}

interface LegalCondition {
  type: "deadline" | "contract_expiration" | "retainer_low";
  params: {
    case_id?: string;
    deadline_date?: string;
    days_before?: number;
    contract_id?: string;
    retainer_threshold?: number;
  };
}

// Generic evaluator interface
interface ConditionEvaluator<TCondition, TState> {
  evaluate(condition: TCondition, current_state: TState): EvaluationResult;
}

interface EvaluationResult {
  is_triggered: boolean;
  metadata: Record<string, any>;  // For notification template context
  confidence?: number;             // Optional: confidence score for ML-based triggers
}

// Concrete implementations
class FinanceConditionEvaluator implements ConditionEvaluator<FinanceCondition, FinanceState> {
  evaluate(condition: FinanceCondition, state: FinanceState): EvaluationResult {
    switch (condition.type) {
      case "balance_threshold":
        const balance = state.accounts.get(condition.params.account_id).balance;
        const is_triggered = balance < condition.params.threshold_amount;
        return {
          is_triggered,
          metadata: {
            current_balance: balance,
            threshold: condition.params.threshold_amount,
            account_name: state.accounts.get(condition.params.account_id).name
          }
        };

      case "missing_payment":
        const series = state.series.get(condition.params.series_id);
        const expected_date = series.next_expected_date;
        const found = state.transactions.find(t =>
          t.series_id === series.id &&
          t.date >= expected_date - 3 &&
          t.date <= expected_date + 3
        );
        return {
          is_triggered: !found && (new Date() > expected_date),
          metadata: {
            series_name: series.name,
            expected_amount: series.expected_amount,
            expected_date: expected_date,
            days_late: Math.floor((new Date() - expected_date) / 86400000)
          }
        };

      default:
        throw new Error(`Unknown condition type: ${condition.type}`);
    }
  }
}

class HealthcareConditionEvaluator implements ConditionEvaluator<HealthcareCondition, HealthcareState> {
  evaluate(condition: HealthcareCondition, state: HealthcareState): EvaluationResult {
    switch (condition.type) {
      case "medication_refill":
        const rx = state.prescriptions.get(condition.params.prescription_id);
        const days_until_empty = rx.days_supply_remaining;
        const is_triggered = days_until_empty < condition.params.days_before_empty;
        return {
          is_triggered,
          metadata: {
            medication_name: rx.name,
            days_until_empty: days_until_empty,
            last_refill_date: rx.last_refill_date
          }
        };

      case "appointment_reminder":
        const appt = state.appointments.get(condition.params.appointment_id);
        const days_until_appt = Math.floor((appt.date - new Date()) / 86400000);
        const is_triggered = days_until_appt === condition.params.days_before_appointment;
        return {
          is_triggered,
          metadata: {
            provider_name: appt.provider_name,
            appointment_date: appt.date,
            appointment_type: appt.type
          }
        };

      default:
        throw new Error(`Unknown condition type: ${condition.type}`);
    }
  }
}

// Generic ReminderEngine (domain-agnostic)
class GenericReminderEngine<TCondition, TState> {
  constructor(
    private conditionEvaluator: ConditionEvaluator<TCondition, TState>,
    private notificationDispatcher: NotificationDispatcher,
    private reminderStore: ReminderStore
  ) {}

  async evaluate_and_notify(
    config: GenericReminderConfig<TCondition, any>,
    current_state: TState
  ): Promise<NotificationEvent | null> {
    // 1. Evaluate condition
    const result = this.conditionEvaluator.evaluate(config.condition, current_state);

    if (!result.is_triggered) {
      return null;  // Condition not met, no notification
    }

    // 2. Check deduplication and cooldown
    const recent_notification = await this.reminderStore.find_recent_notification(
      config.config_id,
      config.preferences.cooldown_hours
    );

    if (recent_notification) {
      return null;  // Already notified recently, skip
    }

    // 3. Render notification from template
    const notification = this.render_notification(config, result.metadata);

    // 4. Save notification
    await this.reminderStore.create_notification(notification);

    // 5. Dispatch to channels
    await this.notificationDispatcher.send_notification(
      notification.notification_id,
      config.channels
    );

    return notification;
  }

  private render_notification(
    config: GenericReminderConfig<TCondition, any>,
    metadata: Record<string, any>
  ): NotificationEvent {
    // Simple template rendering (Handlebars-style)
    const title = this.render_template(config.notification_template.title_template, metadata);
    const body = this.render_template(config.notification_template.body_template, metadata);
    const action_url = this.render_template(config.notification_template.action_url_template, metadata);

    return {
      notification_id: generate_id("notif"),
      user_id: config.user_id,
      config_id: config.config_id,
      type: config.entity_type,
      severity: config.notification_template.severity,
      title,
      body,
      action_url,
      status: "pending",
      channels: config.channels,
      created_at: new Date().toISOString(),
      metadata
    };
  }

  private render_template(template: string, data: Record<string, any>): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => data[key] || match);
  }
}

// Usage examples
const financeEngine = new GenericReminderEngine(
  new FinanceConditionEvaluator(),
  notificationDispatcher,
  reminderStore
);

const healthcareEngine = new GenericReminderEngine(
  new HealthcareConditionEvaluator(),
  notificationDispatcher,
  reminderStore
);

// Both use SAME core engine, different evaluators
```

**Key Abstraction Benefits:**
1. **Single Dispatcher:** `NotificationDispatcher` works across ALL domains (no finance-specific code)
2. **Single Store:** `ReminderStore` stores configs and notifications for ALL domains in same tables
3. **Single Scheduler:** Cron-based scheduler triggers ALL domain reminder checks
4. **Domain-Specific Logic Isolated:** Only `ConditionEvaluator` implementation changes per domain
5. **Reusable UI Components:** `ReminderBell`, `NotificationPanel`, `ReminderConfigDialog` work across domains with prop customization

---

### 15. Runner/Coordinator Separation

**Coordinator (API Layer - Stateless):**

```python
# app/api/reminders/routes.py
from fastapi import APIRouter, Depends
from app.primitives.ol.ReminderEngine import ReminderEngine
from app.primitives.ol.ReminderStore import ReminderStore

router = APIRouter(prefix="/api/reminders")

@router.post("/configs")
async def create_reminder_config(
    config_data: ReminderConfigCreate,
    user_id: str = Depends(get_current_user),
    engine: ReminderEngine = Depends(get_reminder_engine)
):
    """
    Coordinator: Validates input, calls ReminderEngine (Runner)
    """
    # 1. Validate user owns referenced entities (accounts, series)
    validate_entity_ownership(user_id, config_data)

    # 2. Delegate to Runner
    config = engine.create_reminder_config(
        user_id=user_id,
        type=config_data.type,
        conditions=config_data.conditions,
        schedule=config_data.schedule,
        channels=config_data.channels
    )

    return ReminderConfigResponse.from_orm(config)

@router.post("/notifications/{notification_id}/snooze")
async def snooze_notification(
    notification_id: str,
    snooze_data: SnoozeRequest,
    user_id: str = Depends(get_current_user),
    store: ReminderStore = Depends(get_reminder_store)
):
    """
    Coordinator: Validates ownership, calls ReminderStore (Runner)
    """
    # 1. Validate user owns notification
    notification = store.get_notification(notification_id)
    if notification.user_id != user_id:
        raise HTTPException(403, "Not authorized")

    # 2. Delegate to Runner
    store.snooze_notification(
        notification_id=notification_id,
        snooze_until=datetime.now() + timedelta(seconds=snooze_data.duration_seconds)
    )

    return {"status": "snoozed"}
```

**Runner (OL Primitive - Business Logic):**

```python
# app/primitives/ol/ReminderEngine.py
class ReminderEngine:
    """
    Runner: Pure business logic, no HTTP concerns
    """

    def __init__(
        self,
        reminder_store: ReminderStore,
        alert_evaluator: AlertRuleEvaluator,
        notification_dispatcher: NotificationDispatcher
    ):
        self.reminder_store = reminder_store
        self.alert_evaluator = alert_evaluator
        self.notification_dispatcher = notification_dispatcher

    def create_reminder_config(
        self,
        user_id: str,
        type: str,
        conditions: dict,
        schedule: dict,
        channels: List[str]
    ) -> ReminderConfig:
        """
        Business logic: Create and persist reminder configuration
        """
        # 1. Generate unique config_id
        config_id = generate_id("reminder")

        # 2. Validate cron expression (if scheduled)
        if schedule.get("type") == "cron":
            validate_cron_expression(schedule["expression"])

        # 3. Create config object
        config = ReminderConfig(
            config_id=config_id,
            user_id=user_id,
            type=type,
            enabled=True,
            conditions=conditions,
            schedule=schedule,
            channels=channels,
            created_at=datetime.utcnow()
        )

        # 4. Persist to database
        self.reminder_store.save_config(config)

        # 5. Schedule cron job (if applicable)
        if schedule.get("type") == "cron":
            self.schedule_cron_job(config_id, schedule)

        return config

    def evaluate_scheduled_rules(self, schedule_time: datetime) -> List[NotificationEvent]:
        """
        Business logic: Evaluate all scheduled rules at given time
        Called by cron daemon, NOT by HTTP request
        """
        notifications = []

        # 1. Fetch all enabled rules scheduled for this time
        configs = self.reminder_store.get_scheduled_configs(schedule_time)

        # 2. Evaluate each rule
        for config in configs:
            try:
                result = self.alert_evaluator.evaluate_condition(
                    config.config_id,
                    self.get_current_state(config)
                )

                if result.is_triggered:
                    # 3. Create notification
                    notification = self.create_notification(config, result.metadata)
                    notifications.append(notification)

                    # 4. Dispatch to channels (async)
                    self.notification_dispatcher.send_notification(
                        notification.notification_id,
                        config.channels
                    )
            except Exception as e:
                logger.error(f"Failed to evaluate rule {config.config_id}: {e}")
                continue

        return notifications

    def process_realtime_event(self, event_type: str, event_data: dict) -> List[NotificationEvent]:
        """
        Business logic: Handle real-time event (e.g., transaction.created)
        Called by webhook handler, NOT by user request
        """
        notifications = []

        # 1. Find rules triggered by this event type
        configs = self.reminder_store.get_realtime_configs(event_type)

        # 2. Evaluate each rule against event data
        for config in configs:
            result = self.alert_evaluator.evaluate_condition(
                config.config_id,
                event_data
            )

            if result.is_triggered:
                notification = self.create_notification(config, result.metadata)
                notifications.append(notification)
                self.notification_dispatcher.send_notification(
                    notification.notification_id,
                    config.channels
                )

        return notifications
```

**Background Worker (Cron Daemon):**

```python
# app/workers/reminder_scheduler.py
import schedule
import time
from app.primitives.ol.ReminderEngine import ReminderEngine

def run_scheduled_reminders():
    """
    Background worker: Runs every minute, triggers ReminderEngine
    """
    engine = get_reminder_engine()
    current_time = datetime.utcnow()

    logger.info(f"Running scheduled reminders at {current_time}")
    notifications = engine.evaluate_scheduled_rules(current_time)
    logger.info(f"Created {len(notifications)} notifications")

# Schedule every minute
schedule.every(1).minutes.do(run_scheduled_reminders)

while True:
    schedule.run_pending()
    time.sleep(1)
```

**Separation Benefits:**
1. **Coordinator (API):** Handles HTTP, auth, validation → stateless, horizontally scalable
2. **Runner (OL):** Pure business logic → testable without HTTP mocking
3. **Background Worker:** Scheduled execution → separate process, doesn't block API requests

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All API endpoints require valid JWT token (`Authorization: Bearer {token}`)
- Users can ONLY create/view/edit their OWN reminder configs and notifications
- Database queries filtered by `user_id` (multi-tenancy isolation)
- Admin users can view system-wide reminder metrics (not individual notifications)

**Data Privacy:**
- Notification bodies may contain sensitive data (balance amounts, merchant names)
- Email/SMS delivery must use TLS encryption (SendGrid/Twilio enforce this)
- Do NOT log full notification bodies (log only notification_id + type)
- Notification retention: 30 days in hot storage, then archive to S3 with encryption at rest

**Webhook Security:**
- Delivery webhook endpoints (email opened, SMS delivered) must validate signatures
  - SendGrid: Validate `X-Twilio-Email-Event-Webhook-Signature` header
  - Twilio: Validate `X-Twilio-Signature` header using HMAC-SHA256
- Reject webhooks with invalid signatures (prevent spoofing)

**Rate Limiting (Security):**
- User rate limit: 100 API requests per minute (prevent abuse)
- Notification rate limit: 20 notifications per day per user (prevent spam)
- Global rate limit: 10,000 notifications per minute (circuit breaker for system overload)

**Input Validation:**
- Cron expressions validated with croniter library (prevent code injection)
- Timezone strings validated against IANA database (prevent invalid timezones)
- Email addresses validated with regex (prevent invalid emails)
- Phone numbers validated with E.164 format (prevent invalid SMS)

**Secrets Management:**
- SendGrid API key stored in environment variable (NOT in code)
- Twilio credentials stored in AWS Secrets Manager (rotated every 90 days)
- Webhook signature secrets stored in environment (per-environment secrets)

---

### 17. Performance Characteristics

**Latency Targets:**
- Create reminder config: < 200ms (p95)
- Evaluate scheduled rules (1,000 rules): < 10 seconds (p95)
- Send notification (single channel): < 2 seconds (p95)
- Snooze/dismiss action: < 500ms (p95)
- Fetch unread notifications: < 300ms (p95)

**Throughput Targets:**
- Scheduled rule evaluation: 10,000 rules per minute
- Real-time event processing: 1,000 events per second
- Notification delivery: 10,000 notifications per minute (across all channels)

**Database Performance:**
- Indexes: `reminder_config(user_id, enabled)`, `notification_event(user_id, status, created_at)`
- Query optimization: Use `LIMIT` and cursor-based pagination for notification history
- Connection pooling: 20 connections per API instance (avoid connection exhaustion)

**Caching Strategy:**
- Active reminder configs cached in Redis (TTL: 5 minutes, invalidate on update)
- Dedup keys cached in Redis (TTL: 24 hours, sliding window)
- User notification preferences cached in Redis (TTL: 1 hour)

**Message Queue:**
- Notification dispatch uses RabbitMQ (decouple evaluation from delivery)
- Queue depth monitoring: Alert if queue > 10,000 messages (backlog)
- Dead letter queue: Failed deliveries after 3 retries moved to DLQ for manual review

**Performance Bottlenecks:**
- **Database:** High-cardinality queries on `notification_event` table (millions of rows)
  - Mitigation: Partition table by created_at (monthly partitions), archive old data
- **External APIs:** Email/SMS delivery depends on third-party SLA (SendGrid 99.95%)
  - Mitigation: Use multiple providers (failover: SendGrid → AWS SES), queue retries
- **Scheduler:** Single cron daemon is bottleneck for scheduled rules
  - Mitigation: Shard rules across multiple workers (hash user_id % num_workers)

---

### 18. Observability

**Metrics (Prometheus):**
- `reminders_evaluations_total{type, status}` - Counter of rule evaluations (triggered, not_triggered, error)
- `reminders_notifications_sent_total{channel, status}` - Counter of notifications sent (success, failed)
- `reminders_notification_latency_seconds{channel}` - Histogram of notification delivery latency
- `reminders_queue_depth` - Gauge of message queue depth
- `reminders_active_configs_total{type}` - Gauge of enabled reminder configs per type

**Logs (Structured JSON):**
```json
{
  "timestamp": "2024-10-17T08:00:15Z",
  "level": "info",
  "component": "ReminderEngine",
  "action": "evaluate_scheduled_rules",
  "schedule_time": "2024-10-17T08:00:00Z",
  "rules_evaluated": 1523,
  "notifications_created": 42,
  "duration_ms": 8734
}

{
  "timestamp": "2024-10-17T08:01:02Z",
  "level": "info",
  "component": "NotificationDispatcher",
  "action": "send_email",
  "notification_id": "notif_abc123",
  "user_id": "user_456",
  "template_id": "low_balance_alert_v1",
  "provider": "sendgrid",
  "status": "sent",
  "provider_message_id": "sendgrid_msg_xyz",
  "duration_ms": 1234
}

{
  "timestamp": "2024-10-17T08:05:30Z",
  "level": "error",
  "component": "AlertRuleEvaluator",
  "action": "evaluate_condition",
  "config_id": "reminder_789",
  "error": "AccountNotFoundError: account_id 'acct_123' does not exist",
  "user_id": "user_456"
}
```

**Tracing (OpenTelemetry):**
- Distributed trace: `POST /api/reminders/configs` → `ReminderEngine.create_reminder_config` → `ReminderStore.save_config`
- Trace: Scheduled evaluation → Rule evaluation → Notification creation → Email dispatch → SendGrid API call
- Span attributes: `user_id`, `config_id`, `notification_id`, `channel`, `status`

**Alerts (PagerDuty):**
- **Critical:** Notification queue depth > 50,000 messages (system overload)
- **Critical:** Email delivery failure rate > 10% (SendGrid outage)
- **Warning:** Scheduled evaluation latency > 30 seconds (performance degradation)
- **Warning:** User rate limit hit > 100 times per hour (potential abuse)

**Dashboards (Grafana):**
- **Reminder Overview:** Total active configs, notifications sent today, delivery success rate
- **Channel Performance:** Email/SMS/Push delivery latency and error rates
- **User Engagement:** Notification open rate, snooze rate, dismiss rate
- **System Health:** Queue depth, evaluation latency, database connection pool usage

---

### 19. Testing Strategy

**Unit Tests (OL Primitives):**

```python
# tests/unit/test_reminder_engine.py
def test_create_reminder_config_success():
    """Test creating valid reminder config"""
    engine = ReminderEngine(mock_store, mock_evaluator, mock_dispatcher)
    config = engine.create_reminder_config(
        user_id="user_123",
        type="low_balance",
        conditions={"account_id": "acct_456", "threshold_amount": 500.00},
        schedule={"type": "cron", "expression": "0 8 * * *"},
        channels=["in_app", "email"]
    )
    assert config.config_id.startswith("reminder_")
    assert config.enabled is True
    mock_store.save_config.assert_called_once()

def test_create_reminder_config_invalid_cron():
    """Test validation rejects invalid cron expression"""
    engine = ReminderEngine(mock_store, mock_evaluator, mock_dispatcher)
    with pytest.raises(ValueError, match="Invalid cron expression"):
        engine.create_reminder_config(
            user_id="user_123",
            type="low_balance",
            conditions={...},
            schedule={"type": "cron", "expression": "invalid"},
            channels=["in_app"]
        )

# tests/unit/test_alert_rule_evaluator.py
def test_evaluate_low_balance_true():
    """Test low balance condition evaluates to TRUE"""
    evaluator = AlertRuleEvaluator(mock_account_store)
    mock_account_store.get_balance.return_value = 450.00

    result = evaluator.check_balance_threshold(
        account_id="acct_123",
        threshold=500.00,
        comparison="less_than"
    )
    assert result.is_triggered is True
    assert result.metadata["current_balance"] == 450.00

def test_evaluate_low_balance_false():
    """Test low balance condition evaluates to FALSE"""
    evaluator = AlertRuleEvaluator(mock_account_store)
    mock_account_store.get_balance.return_value = 550.00

    result = evaluator.check_balance_threshold(
        account_id="acct_123",
        threshold=500.00,
        comparison="less_than"
    )
    assert result.is_triggered is False
```

**Integration Tests (API + DB):**

```python
# tests/integration/test_reminders_api.py
def test_create_and_evaluate_reminder_end_to_end(test_client, test_db):
    """Test full flow: create config → trigger evaluation → receive notification"""
    # 1. Create reminder config
    response = test_client.post("/api/reminders/configs", json={
        "type": "low_balance",
        "conditions": {"account_id": "acct_123", "threshold_amount": 500.00},
        "schedule": {"type": "cron", "expression": "0 8 * * *"},
        "channels": ["in_app"]
    }, headers={"Authorization": "Bearer {test_token}"})
    assert response.status_code == 201
    config_id = response.json()["config_id"]

    # 2. Mock account balance below threshold
    test_db.execute("UPDATE accounts SET balance = 450.00 WHERE account_id = 'acct_123'")

    # 3. Trigger scheduled evaluation
    engine = get_reminder_engine()
    notifications = engine.evaluate_scheduled_rules(datetime(2024, 10, 17, 8, 0, 0))

    # 4. Verify notification created
    assert len(notifications) == 1
    assert notifications[0].type == "low_balance"
    assert notifications[0].metadata["current_balance"] == 450.00

    # 5. Verify notification in database
    notif = test_db.query("SELECT * FROM notification_events WHERE config_id = ?", config_id)
    assert notif["status"] == "pending"

def test_snooze_notification(test_client, test_db):
    """Test snoozing notification updates status and timestamp"""
    # 1. Create notification
    notif_id = test_db.insert("notification_events", {
        "notification_id": "notif_123",
        "user_id": "user_456",
        "status": "delivered"
    })

    # 2. Snooze notification
    response = test_client.post(f"/api/reminders/notifications/{notif_id}/snooze", json={
        "duration_seconds": 86400  # 1 day
    }, headers={"Authorization": "Bearer {test_token}"})
    assert response.status_code == 200

    # 3. Verify status updated
    notif = test_db.query("SELECT * FROM notification_events WHERE notification_id = ?", notif_id)
    assert notif["status"] == "snoozed"
    assert notif["snoozed_until"] > datetime.utcnow()
```

**E2E Tests (Cypress):**

```javascript
// cypress/e2e/reminders.cy.js
describe('Reminders Flow', () => {
  it('User creates low balance alert and receives notification', () => {
    // 1. Login
    cy.login('test@example.com', 'password');

    // 2. Navigate to Reminders settings
    cy.visit('/settings/reminders');
    cy.contains('Create New Alert').click();

    // 3. Fill out form
    cy.get('[data-testid=alert-type]').select('Low Balance Threshold');
    cy.get('[data-testid=account-select]').select('Chase Checking');
    cy.get('[data-testid=threshold-amount]').type('500');
    cy.get('[data-testid=notification-channels]').check(['in_app', 'email']);
    cy.contains('Create Alert').click();

    // 4. Verify alert created
    cy.contains('Alert created successfully').should('be.visible');
    cy.get('[data-testid=active-alerts]').should('contain', 'Low Balance: Chase Checking');

    // 5. Mock balance update (trigger notification)
    cy.task('updateAccountBalance', { account_id: 'acct_123', balance: 450 });
    cy.task('triggerScheduledReminders');

    // 6. Verify notification appears in bell icon
    cy.get('[data-testid=reminder-bell]').should('have.attr', 'data-unread-count', '1');
    cy.get('[data-testid=reminder-bell]').click();

    // 7. Verify notification panel opens
    cy.get('[data-testid=notification-panel]').should('be.visible');
    cy.contains('Low Balance Alert: Chase Checking').should('be.visible');
    cy.contains('$450.00, below your $500 threshold').should('be.visible');

    // 8. Snooze notification
    cy.contains('Snooze').click();
    cy.contains('1 day').click();
    cy.get('[data-testid=notification-panel]').should('not.contain', 'Low Balance Alert');
  });
});
```

**Load Tests (k6):**

```javascript
// tests/load/reminders_load.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '1m', target: 100 },   // Ramp up to 100 users
    { duration: '5m', target: 100 },   // Stay at 100 users
    { duration: '1m', target: 0 },     // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95% of requests must complete in <500ms
  },
};

export default function () {
  // Create reminder config
  let createRes = http.post('http://api.example.com/api/reminders/configs', JSON.stringify({
    type: 'low_balance',
    conditions: { account_id: 'acct_123', threshold_amount: 500 },
    schedule: { type: 'cron', expression: '0 8 * * *' },
    channels: ['in_app']
  }), {
    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer {token}' },
  });

  check(createRes, {
    'create config status is 201': (r) => r.status === 201,
    'create config latency < 500ms': (r) => r.timings.duration < 500,
  });

  sleep(1);

  // Fetch unread notifications
  let fetchRes = http.get('http://api.example.com/api/reminders/notifications?status=unread', {
    headers: { 'Authorization': 'Bearer {token}' },
  });

  check(fetchRes, {
    'fetch notifications status is 200': (r) => r.status === 200,
    'fetch notifications latency < 300ms': (r) => r.timings.duration < 300,
  });

  sleep(2);
}
```

**Test Coverage Target:**
- Unit tests: 90% code coverage (all OL primitives)
- Integration tests: 80% coverage (critical API flows)
- E2E tests: 100% coverage of user journeys (happy path + key edge cases)

---

### 20. Operations & Deployment

**Deployment Architecture:**

```
┌─────────────────────────────────────────────────────────────┐
│                     Load Balancer (ALB)                     │
└────────────────────────┬────────────────────────────────────┘
                         │
         ┌───────────────┴───────────────┐
         │                               │
         ▼                               ▼
┌────────────────────┐          ┌────────────────────┐
│   API Instance 1   │          │   API Instance 2   │  (Auto-scaling: 2-10 instances)
│  (ReminderEngine)  │          │  (ReminderEngine)  │
└──────┬─────────────┘          └──────┬─────────────┘
       │                               │
       └───────────────┬───────────────┘
                       │
                       ▼
           ┌────────────────────┐
           │   RabbitMQ Cluster │  (3 nodes, mirrored queues)
           └──────┬─────────────┘
                  │
         ┌────────┴────────┐
         │                 │
         ▼                 ▼
┌──────────────────┐  ┌──────────────────┐
│  Worker 1 (Cron) │  │ Worker 2 (Async) │  (Background workers)
│  Scheduled Rules │  │ Notification     │
│                  │  │ Dispatcher       │
└──────────────────┘  └──────────────────┘
         │                 │
         └────────┬────────┘
                  │
                  ▼
      ┌───────────────────────┐
      │  PostgreSQL (Primary) │  (RDS Multi-AZ)
      │  + Read Replica       │
      └───────────────────────┘
                  │
                  ▼
      ┌───────────────────────┐
      │   Redis Cluster       │  (ElastiCache, 3 nodes)
      └───────────────────────┘
```

**Deployment Steps:**

1. **Build Docker Image:**
   ```bash
   docker build -t reminders-api:v1.0.0 .
   docker push registry.example.com/reminders-api:v1.0.0
   ```

2. **Deploy API Instances (Rolling Update):**
   ```bash
   kubectl set image deployment/reminders-api \
     reminders-api=registry.example.com/reminders-api:v1.0.0
   kubectl rollout status deployment/reminders-api
   ```

3. **Deploy Background Workers:**
   ```bash
   kubectl apply -f k8s/reminder-scheduler-cronjob.yaml
   kubectl apply -f k8s/notification-dispatcher-deployment.yaml
   ```

4. **Run Database Migrations:**
   ```bash
   alembic upgrade head
   ```

5. **Smoke Test:**
   ```bash
   curl https://api.example.com/health
   # Expected: {"status": "healthy", "components": {"db": "ok", "redis": "ok", "rabbitmq": "ok"}}
   ```

**Rollback Plan:**
```bash
kubectl rollout undo deployment/reminders-api
```

**Monitoring Post-Deployment:**
- Watch Grafana dashboard for 30 minutes
- Check error rate < 1% (baseline)
- Check p95 latency < 500ms (baseline)
- Verify notification delivery success rate > 95%

**Feature Flags:**
- `reminders.realtime_triggers_enabled` - Enable/disable real-time event processing
- `reminders.email_delivery_enabled` - Enable/disable email channel (kill switch)
- `reminders.sms_delivery_enabled` - Enable/disable SMS channel

**Database Migrations:**

```sql
-- Migration: 001_create_reminder_tables.sql
CREATE TABLE reminder_configs (
  config_id VARCHAR(50) PRIMARY KEY,
  user_id VARCHAR(50) NOT NULL,
  type VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  enabled BOOLEAN DEFAULT TRUE,
  conditions JSONB NOT NULL,
  schedule JSONB,
  channels TEXT[] NOT NULL,
  preferences JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_reminder_configs_user_enabled ON reminder_configs(user_id, enabled);

CREATE TABLE notification_events (
  notification_id VARCHAR(50) PRIMARY KEY,
  user_id VARCHAR(50) NOT NULL,
  config_id VARCHAR(50) REFERENCES reminder_configs(config_id) ON DELETE SET NULL,
  type VARCHAR(50) NOT NULL,
  severity VARCHAR(20) NOT NULL,
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL,
  action_url VARCHAR(500),
  action_label VARCHAR(50),
  status VARCHAR(20) NOT NULL,
  channels TEXT[] NOT NULL,
  snoozed_until TIMESTAMP,
  snoozed_by VARCHAR(50),
  snoozed_at TIMESTAMP,
  dismissed_by VARCHAR(50),
  dismissed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  metadata JSONB
);

CREATE INDEX idx_notification_events_user_status ON notification_events(user_id, status, created_at DESC);
CREATE INDEX idx_notification_events_snoozed ON notification_events(snoozed_until) WHERE status = 'snoozed';

CREATE TABLE notification_delivery_logs (
  log_id SERIAL PRIMARY KEY,
  notification_id VARCHAR(50) REFERENCES notification_events(notification_id) ON DELETE CASCADE,
  channel VARCHAR(20) NOT NULL,
  status VARCHAR(20) NOT NULL,
  sent_at TIMESTAMP,
  delivered_at TIMESTAMP,
  opened_at TIMESTAMP,
  failed_at TIMESTAMP,
  error_message TEXT,
  provider_message_id VARCHAR(100),
  retry_count INT DEFAULT 0
);

CREATE INDEX idx_delivery_logs_notification ON notification_delivery_logs(notification_id);
```

**Backup & Recovery:**
- Database: Daily backups to S3 (7-day retention)
- Redis: No persistence required (cache only, acceptable data loss)
- RabbitMQ: Mirrored queues across 3 nodes (no data loss on single node failure)

**Disaster Recovery:**
- RTO (Recovery Time Objective): 1 hour
- RPO (Recovery Point Objective): 24 hours (acceptable: reminders are not mission-critical)
- Failover: Multi-region deployment (primary: us-east-1, secondary: us-west-2)

---

**END OF VERTICAL 4.1 SPECIFICATION**

Total Sections: 20 ✓
Line Count: 1,800+ ✓
Multi-Domain Examples: Finance, Healthcare, Legal, Research, E-commerce, Logistics ✓
Pattern Abstraction: Generic RemindableEvent<T> interface ✓
