# Vertical 4.1: Reminders (Intelligent Alert & Notification System)

> **Type:** Event-Driven Notification System
> **Pattern:** Rule-Based Alerting + Multi-Channel Delivery + Snooze/Dismiss Management
> **Last Updated:** 2025-10-24

---

## ğŸ“‹ Overview

The **Reminders** vertical provides an **intelligent alert and notification system** for proactive user engagement based on financial events, patterns, and thresholds. While demonstrated in finance domain (missing payments, low balances, large expenses, due dates), the underlying primitives are domain-agnostic and apply to ANY event-driven notification system across domains.

**Key Characteristics:**
- **Event-Driven Triggers:** Real-time detection of financial events (transaction posted, balance updated, payment missed)
- **Scheduled Checks:** Cron-based evaluation for time-based reminders (due dates, recurring payment expectations)
- **Multi-Channel Delivery:** In-app notifications, email, SMS, push notifications (with user preferences)
- **Rule-Based Configuration:** User-defined alert rules with conditions and thresholds
- **Snooze & Dismiss:** User can defer or dismiss reminders with persistence
- **Delivery Tracking:** Track notification delivery status (sent, read, snoozed, dismissed)
- **Audit Trail:** Full provenance of when/why/how reminders were triggered

**Finance Domain Examples:**
- **Missing Recurring Payment:** "Netflix subscription ($15.99) expected on Oct 15, not detected yet"
- **Low Balance Alert:** "Chase Checking balance below $500 threshold ($485 current)"
- **Large Expense Detected:** "Unusual expense: $2,500 at Apple Store (3x your average)"
- **Payment Due Date:** "Chase Credit Card payment ($1,234) due in 3 days (Oct 18)"
- **Budget Exceeded:** "Dining category budget exceeded: $450 spent of $400 budget this month"

**Multi-Domain Applicability:**
- **Healthcare:** Medication refill reminders, appointment notifications, insurance expiration, test result availability, vaccination due dates
- **Legal:** Court date reminders, filing deadlines, contract expiration, retainer low balance, discovery deadline, statute of limitations
- **Research:** Grant deadline reminders, ethics review expiration, publication milestones, conference submissions, IRB renewal, data retention deadlines
- **E-commerce:** Inventory low stock alerts, price drop notifications, abandoned cart reminders, order status updates, subscription renewal
- **Logistics:** Shipment delay alerts, delivery confirmation, customs clearance status, warehouse capacity warnings, carrier performance alerts

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Event-driven reminder triggers based on financial transactions and account state
- Scheduled reminder checks for time-based alerts (daily 8 AM, hourly, custom cron)
- Multi-condition alert rules (missing payment + amount threshold + account filter)
- Multi-channel notification delivery (in-app, email, SMS, push) with user preferences
- Snooze functionality (defer reminder for 1h, 1d, 1w, custom) with server-side persistence
- Dismiss functionality (mark as read, hide forever) with audit trail
- Reminder history and delivery tracking (sent, delivered, read, snoozed, dismissed)
- Alert rule CRUD operations (create, edit, enable/disable, delete)
- Template-based notifications with dynamic content (transaction details, balance amounts)
- Batch notification processing (combine multiple alerts into digest)

**Out of Scope:**
- Two-way communication (user replies to notifications) - covered in future vertical 4.x Messaging
- Advanced AI predictions (ML-based anomaly detection) - covered in 3.4 Insights (already complete)
- Payment execution from notifications (pay now button) - covered in future 4.x Payments
- Calendar integration (add due dates to Google Calendar) - v2 feature
- Voice notifications (phone calls) - v2 feature
- Real-time streaming for millisecond latency - batch processing acceptable (30s-5m delay)

**Boundaries:**
- Reminder rules reference existing entities (accounts, counterparties, series) from Group 3 registries
- Notification delivery uses external services (email: SendGrid, SMS: Twilio) via adapters
- User must explicitly enable notifications (GDPR compliance, opt-in model)
- Rate limiting prevents notification spam (max 20 notifications/day per user by default)
- Notifications are ephemeral (30-day retention, then archived to cold storage)

---

### 2. User Flow (Real Usage)

**Scenario 1: User receives missing recurring payment alert (auto-detected)**

User: "My Netflix subscription usually posts on the 15th, but I haven't seen it yet. I want to be notified if it's late."

System:
1. User has previously defined Series: "Netflix Subscription" with expected date = 15th of month, amount = $15.99
2. RecurrenceEngine in Vertical 3.3 calculates expected date: Oct 15, 2024
3. On Oct 16, 2024 at 8:00 AM, ReminderEngine runs scheduled check
4. AlertRuleEvaluator detects: No transaction found matching series_id + date range (Oct 15 Â± 3 days)
5. ReminderEngine creates notification:
   ```json
   {
     "notification_id": "notif_abc123",
     "type": "missing_recurring_payment",
     "severity": "warning",
     "title": "Missing Payment: Netflix Subscription",
     "body": "Expected payment of $15.99 to Netflix on Oct 15, not detected yet. Last payment: Sep 15.",
     "action_url": "/series/series_netflix_123",
     "action_label": "View Series",
     "created_at": "2024-10-16T08:00:00Z",
     "channels": ["in_app", "email"],
     "metadata": {
       "series_id": "series_netflix_123",
       "expected_amount": 15.99,
       "expected_date": "2024-10-15",
       "days_late": 1
     }
   }
   ```
6. NotificationDispatcher sends:
   - In-app: Badge appears on bell icon (red dot + count)
   - Email: "Reminder: Missing Netflix payment ($15.99)" sent to user@example.com
7. User opens app, sees notification in NotificationPanel
8. User clicks "View Series" â†’ navigates to Series detail (Vertical 3.3)
9. User confirms payment posted on Oct 17 (late but present)
10. User dismisses notification â†’ status updated to "dismissed", removed from unread list

**Scenario 2: User sets up low balance alert (manual configuration)**

User: "I want to be notified if my checking account balance goes below $500"

System:
1. User navigates to Reminders settings
2. Clicks "Create New Alert"
3. ReminderConfigDialog opens:
   ```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Create New Alert                           [Ã—] â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Alert Type:                                    â”‚
   â”‚ â—‹ Missing Recurring Payment                    â”‚
   â”‚ â— Low Balance Threshold                        â”‚
   â”‚ â—‹ Large Expense Detected                       â”‚
   â”‚ â—‹ Payment Due Date                             â”‚
   â”‚ â—‹ Custom Condition                             â”‚
   â”‚                                                â”‚
   â”‚ â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” â”‚
   â”‚                                                â”‚
   â”‚ Account:                                       â”‚
   â”‚ [Chase Checking â–¼]                             â”‚
   â”‚                                                â”‚
   â”‚ Alert when balance is below:                   â”‚
   â”‚ [$___500.00___]                                â”‚
   â”‚                                                â”‚
   â”‚ Check frequency:                               â”‚
   â”‚ â—‹ Real-time (when transaction posts)           â”‚
   â”‚ â— Daily (8:00 AM)                              â”‚
   â”‚ â—‹ Hourly                                       â”‚
   â”‚                                                â”‚
   â”‚ Notification channels:                         â”‚
   â”‚ â˜‘ In-app notification                          â”‚
   â”‚ â˜‘ Email (user@example.com)                     â”‚
   â”‚ â˜ SMS (+1-555-0123)                            â”‚
   â”‚                                                â”‚
   â”‚ [Create Alert] [Cancel]                        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ```
4. User fills form and clicks "Create Alert"
5. System creates reminder_config record:
   ```json
   {
     "config_id": "reminder_low_balance_456",
     "user_id": "user_123",
     "type": "low_balance",
     "enabled": true,
     "conditions": {
       "account_id": "acct_chase_checking",
       "threshold_amount": 500.00,
       "comparison": "less_than"
     },
     "schedule": {
       "type": "cron",
       "expression": "0 8 * * *",  // Daily at 8 AM
       "timezone": "America/Los_Angeles"
     },
     "channels": ["in_app", "email"],
     "created_at": "2024-10-16T09:00:00Z"
   }
   ```
6. Next day (Oct 17 at 8:00 AM), ReminderEngine runs scheduled check
7. AlertRuleEvaluator fetches current balance: $485.00
8. Condition evaluates: $485 < $500 â†’ TRUE
9. NotificationDispatcher creates notification:
   ```
   Title: Low Balance Alert: Chase Checking
   Body: Your Chase Checking account balance is $485.00, below your $500 threshold.
   Action: View Account â†’
   ```
10. User receives email and in-app notification
11. User clicks "Snooze 1 day" â†’ notification reappears Oct 18 if balance still low

**Scenario 3: User is alerted to large expense (anomaly detection)**

User: "I just made a $2,500 purchase at Apple Store. The system should alert me since this is unusual."

System:
1. User has alert rule: "Large Expense Detected" with threshold = 3Ã— average transaction
2. User's average expense (last 30 days): $850 â†’ threshold = $2,550
3. Transaction posts: -$2,500 to Apple Store (Oct 16, 2024 3:45 PM)
4. ReminderEngine receives real-time event: `transaction.created` webhook
5. AlertRuleEvaluator checks:
   - Is transaction an expense? YES (amount < 0)
   - Is absolute amount > threshold? YES ($2,500 > $850 Ã— 3 = $2,550)? NO (close, but below)
   - Edge case: $2,500 is 2.94Ã— average (just below 3Ã—), no alert triggered
6. User manually lowers threshold to 2Ã— average in settings
7. ReminderEngine re-evaluates historical transactions (last 24h)
8. Finds Apple Store transaction now exceeds 2Ã— threshold
9. Creates notification:
   ```
   Title: Large Expense Detected
   Body: Unusual expense of $2,500 at Apple Store (2.9Ã— your average). Is this expected?
   Actions: [Mark as Expected] [Report Fraud]
   ```
10. User clicks "Mark as Expected" â†’ notification dismissed, transaction tagged `expected_large_expense: true`

**Scenario 4: User receives credit card payment due reminder**

User: "My Chase credit card payment is due on Oct 20. Remind me 3 days before."

System:
1. User has account: "Chase Freedom Credit Card" with `payment_due_date: 20` (field in Account schema)
2. User creates reminder rule:
   ```json
   {
     "type": "payment_due_date",
     "conditions": {
       "account_id": "acct_chase_freedom",
       "days_before_due": 3
     },
     "schedule": {
       "type": "cron",
       "expression": "0 9 * * *"  // Daily at 9 AM
     },
     "channels": ["in_app", "email", "sms"]
   }
   ```
3. On Oct 17, 2024 at 9:00 AM, ReminderEngine runs
4. AlertRuleEvaluator calculates:
   - Due date: Oct 20
   - Days until due: 3
   - Condition: days_until_due == 3 â†’ TRUE
5. Fetches current statement balance: $1,234.56 (from account metadata or external API)
6. Creates notification:
   ```
   Title: Payment Due in 3 Days
   Body: Your Chase Freedom credit card payment of $1,234.56 is due on Oct 20.
   Actions: [Pay Now] [Snooze]
   ```
7. Notification sent via email + SMS (user preference)
8. User clicks "Pay Now" â†’ redirected to payment flow (future vertical 4.x Payments)
9. After payment is made, ReminderEngine detects payment transaction
10. Automatically dismisses reminder (no longer relevant)

**Scenario 5: User snoozes reminder for later review**

User: "I see the low balance alert, but I'm depositing money tomorrow. Remind me again in 2 days."

System:
1. User opens NotificationPanel, sees low balance alert
2. Notification card shows:
   ```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ âš ï¸ Low Balance Alert: Chase Checking           â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Your balance is $485.00, below $500 threshold. â”‚
   â”‚                                                â”‚
   â”‚ Oct 17, 2024 8:00 AM                          â”‚
   â”‚                                                â”‚
   â”‚ [View Account] [Snooze â–¼] [Dismiss]           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ```
3. User clicks "Snooze â–¼" dropdown:
   ```
   â—‹ 1 hour
   â—‹ 4 hours
   â—‹ 1 day
   â— 2 days
   â—‹ 1 week
   â—‹ Custom...
   ```
4. User selects "2 days"
5. System updates notification:
   ```json
   {
     "notification_id": "notif_abc123",
     "status": "snoozed",
     "snoozed_until": "2024-10-19T08:00:00Z",
     "snoozed_by": "user_123",
     "snoozed_at": "2024-10-17T10:30:00Z"
   }
   ```
6. Notification removed from unread list, added to snoozed list
7. On Oct 19 at 8:00 AM, ReminderEngine re-evaluates condition
8. If balance still < $500, notification reappears in unread list
9. If balance >= $500 (deposit posted), notification auto-dismissed

**Scenario 6: User views notification history and delivery status**

User: "I want to see all the reminders I received this month."

System:
1. User navigates to Reminders â†’ History
2. UI shows table:
   ```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Notification History (October 2024)                             â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Date         â”‚ Title            â”‚ Type     â”‚ Status â”‚ Channels â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Oct 17 8:00  â”‚ Low Balance      â”‚ warning  â”‚ Read   â”‚ ğŸ“§ âœ…    â”‚
   â”‚ Oct 16 8:00  â”‚ Missing Netflix  â”‚ warning  â”‚ Dis... â”‚ ğŸ“§ âœ…    â”‚
   â”‚ Oct 15 9:00  â”‚ Payment Due      â”‚ info     â”‚ Dis... â”‚ ğŸ“§ âœ… ğŸ’¬ â”‚
   â”‚ Oct 14 8:00  â”‚ Large Expense    â”‚ alert    â”‚ Dis... â”‚ ğŸ“§ âœ…    â”‚
   â”‚ Oct 10 8:00  â”‚ Budget Exceeded  â”‚ warning  â”‚ Dis... â”‚ ğŸ“§ âœ…    â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ```
3. User clicks on "Low Balance" notification
4. Detail view shows:
   ```
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Low Balance Alert: Chase Checking              â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚ Created: Oct 17, 2024 8:00 AM                  â”‚
   â”‚ Status: Read                                   â”‚
   â”‚                                                â”‚
   â”‚ Delivery Log:                                  â”‚
   â”‚ âœ… In-app: Delivered at 8:00 AM, read 10:30 AM â”‚
   â”‚ âœ… Email: Sent 8:00 AM, opened 10:32 AM        â”‚
   â”‚                                                â”‚
   â”‚ Triggered by rule:                             â”‚
   â”‚ "Low Balance: Chase Checking < $500"           â”‚
   â”‚                                                â”‚
   â”‚ Condition evaluated:                           â”‚
   â”‚ Balance: $485.00 < Threshold: $500.00 âœ“        â”‚
   â”‚                                                â”‚
   â”‚ [Dismiss] [View Account]                       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ```
5. User sees full audit trail of notification lifecycle

---

### 3. States & Transitions

**ReminderConfig States:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DRAFT   â”‚ â† User creating new alert rule (not saved yet)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ .save()
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ENABLED  â”‚ â† Active alert rule, being evaluated
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ .disable()
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DISABLED â”‚ â† Paused, not evaluated (user can re-enable)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ .delete()
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DELETED  â”‚ â† Soft-deleted (retention for 30 days)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Notification States:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PENDING  â”‚ â† Created, queued for delivery
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ NotificationDispatcher.send()
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SENT   â”‚ â† Dispatched to channel (email sent, push queued)
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚ User receives
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DELIVEREDâ”‚ â”€â”€â†’ â”‚   READ   â”‚ â”€â”€â†’ â”‚ DISMISSEDâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                â”‚
     â”‚ .snooze()      â”‚ .snooze()
     â†“                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SNOOZED  â”‚ â”€â”€â†’ â”‚ DELIVEREDâ”‚ (re-surface after snooze expires)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â”‚ Auto-dismiss if condition no longer true
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚AUTO_DISM.â”‚ â† System dismissed (e.g., payment posted)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**State Transition Rules:**
- PENDING â†’ SENT: Automatic, triggered by NotificationDispatcher
- SENT â†’ DELIVERED: Confirmed by delivery service (email opened, push received)
- DELIVERED â†’ READ: User opens notification in UI
- READ â†’ DISMISSED: User clicks "Dismiss" or system auto-dismisses
- DELIVERED â†’ SNOOZED: User clicks "Snooze" with duration
- SNOOZED â†’ DELIVERED: Snooze duration expires + condition still true
- SNOOZED â†’ AUTO_DISMISSED: Condition no longer true (e.g., balance above threshold)

**Edge Cases:**
- User snoozes notification, then deletes the reminder rule â†’ Notification auto-dismissed on next check
- Notification sent via email, but email bounces â†’ Status = FAILED, retry 3Ã— with exponential backoff
- User disables reminder rule while notification is pending â†’ Notification cancelled (not sent)
- Snooze duration expires, but user is in "Do Not Disturb" mode (11 PM - 7 AM) â†’ Notification delayed until 7 AM

---

### 4. Edge Cases

**1. Duplicate Notification Prevention**

Problem: User has 2 alerts for low balance (one at $500, one at $400). Balance drops to $350. Should system send 2 notifications?

Solution:
- NotificationDispatcher deduplicates notifications with same `dedup_key` within 24h window
- `dedup_key = hash(type + account_id + date)` â†’ "low_balance:acct_123:2024-10-17"
- If notification with same dedup_key exists and is SENT/DELIVERED/READ, skip new notification
- If user has 2 rules, send 1 notification with combined context:
  ```
  Title: Low Balance Alert: Chase Checking
  Body: Your balance ($350) is below your thresholds: $500 (Alert 1) and $400 (Alert 2).
  ```

**2. Timezone Handling for Scheduled Reminders**

Problem: User in Los Angeles (PST) wants daily reminder at 8 AM PST. System runs on UTC. What time should cron run?

Solution:
- Store user timezone in `reminder_config.schedule.timezone: "America/Los_Angeles"`
- Convert cron expression to UTC at schedule time (8 AM PST = 4 PM UTC)
- Handle DST transitions: Re-calculate UTC offset twice per year (spring forward, fall back)
- If DST changes during snooze period, adjust snooze_until timestamp accordingly

**3. Missing Data for Alert Evaluation**

Problem: User creates alert "Notify if Chase balance < $500", but account balance is not synced (external API failed). Should system alert?

Solution:
- AlertRuleEvaluator checks data freshness: `last_synced_at` timestamp
- If data older than 24h, skip evaluation + log warning: `Alert skipped: stale data`
- Send separate notification to user: "Unable to check balance alerts due to sync failure"
- Retry evaluation every hour until data is fresh

**4. Snooze Expiration During Condition Resolution**

Problem: User snoozes "low balance" alert for 2 days. Before snooze expires, user deposits $1,000 (balance now $1,485). Should notification reappear?

Solution:
- When snooze expires, ReminderEngine re-evaluates condition
- If condition is FALSE (balance >= $500), auto-dismiss notification with status `AUTO_DISMISSED`
- Log reason: `Condition resolved: balance increased to $1,485`
- Do NOT send notification (saves user from irrelevant alerts)

**5. Rapid Condition Oscillation**

Problem: User balance oscillates around $500 threshold: $510 â†’ $490 â†’ $505 â†’ $495. System sends 4 alerts in 1 day?

Solution:
- Implement **cooldown period**: After sending notification, wait 24h before sending another for same condition
- Store `last_notified_at` timestamp in notification_event table
- AlertRuleEvaluator checks: `if now - last_notified_at < cooldown_period, skip`
- User can configure cooldown per rule (default: 24h, min: 1h, max: 7 days)

**6. User Deletes Alert Rule While Notification Pending**

Problem: User creates alert, notification queued (PENDING), then user deletes alert rule before notification is sent. Should system still send?

Solution:
- NotificationDispatcher checks `reminder_config.enabled` before sending
- If rule is DISABLED or DELETED, mark notification as CANCELLED
- Log: `Notification cancelled: rule deleted by user`
- Do NOT send notification (respect user intent)

**7. Email Bounces or SMS Delivery Fails**

Problem: User's email address is invalid, or SMS number is disconnected. Notification fails to deliver.

Solution:
- NotificationDispatcher receives delivery webhook from SendGrid/Twilio
- Update notification status: SENT â†’ FAILED with error reason: `Email bounced: invalid address`
- Retry 3Ã— with exponential backoff: 5 min, 30 min, 2h
- After 3 failures, mark as PERMANENTLY_FAILED
- Send in-app notification: "Unable to deliver email notification to user@example.com. Please update your email."
- User can update contact info, then manually retry failed notifications

**8. User in Multiple Timezones (Travel)**

Problem: User creates alert in Los Angeles (PST), then travels to New York (EST). Should alert fire at 8 AM PST or 8 AM EST?

Solution:
- Reminder config stores `timezone: "America/Los_Angeles"` (set at creation time)
- Alert ALWAYS fires at 8 AM in configured timezone, regardless of user's current location
- User can edit alert to change timezone if needed
- UI shows: "This alert fires at 8:00 AM Pacific Time (currently 11:00 AM Eastern Time)"

**9. High-Frequency Events Causing Alert Spam**

Problem: User has alert "Large expense > $100". User makes 20 transactions in 1 hour. System sends 20 notifications?

Solution:
- Implement **rate limiting**: Max 20 notifications per day per user (configurable)
- If limit reached, batch remaining alerts into digest: "You have 15 more large expense alerts. [View All]"
- Send digest once per day (configurable time, default: 6 PM)
- User can increase rate limit in settings (max: 100/day)

**10. Notification Preferences Override**

Problem: User enables email notifications for "Low Balance" alert, but later disables ALL email notifications globally. Which setting wins?

Solution:
- Global notification preferences ALWAYS override rule-specific preferences
- Precedence: User Global Preferences > Rule Preferences > System Defaults
- If user disables email globally, NO email notifications sent (regardless of rule settings)
- UI shows warning in rule editor: "âš ï¸ Email notifications are disabled in your global settings"

---

### 5. Performance Requirements

**Latency:**
- **Real-time alerts:** Notification created within 30 seconds of triggering event (transaction post)
- **Scheduled alerts:** Evaluation completes within 5 minutes of scheduled time
- **Notification delivery:** In-app notification delivered within 5 seconds, email within 2 minutes, SMS within 30 seconds
- **Snooze action:** UI update within 500ms, server persistence within 2 seconds
- **Dismiss action:** UI update within 500ms, server persistence within 2 seconds
- **Rule evaluation:** 1,000 rules evaluated in < 10 seconds (per-user rules, not global)

**Throughput:**
- **Bulk evaluation:** Support 10,000 users Ã— 10 rules each = 100,000 rule evaluations per scheduled run
- **Notification delivery:** 10,000 notifications sent per minute across all channels
- **Webhook processing:** Handle 1,000 transaction.created events per second (real-time triggers)

**Scalability:**
- **User growth:** Support 100,000 users with average 5 reminder rules each = 500,000 active rules
- **Notification retention:** Store 30 days of notifications (estimated 10M records), archive older to S3

**Availability:**
- **Uptime:** 99.5% (acceptable: reminder is not mission-critical, brief outages tolerable)
- **Degraded mode:** If email service is down, queue notifications for retry (24h buffer)

**Performance Optimization Strategies:**
- **Indexing:** Database indexes on `reminder_config.user_id`, `notification_event.status`, `notification_event.created_at`
- **Caching:** Cache active reminder rules in Redis (invalidate on update)
- **Batch processing:** Evaluate scheduled rules in batches of 1,000 users (parallel workers)
- **Async delivery:** Use message queue (RabbitMQ) for notification dispatch (decouple evaluation from delivery)

---

### 6. Dependencies

**Internal Dependencies (Existing Verticals):**
- **1.3 Normalization:** Fetch canonical transactions for alert evaluation (missing payments, large expenses)
- **3.1 Account Registry:** Reference accounts in alert conditions (balance thresholds, payment due dates)
- **3.2 Counterparty Registry:** Filter alerts by merchant (e.g., "Alert when spending at Amazon > $500/month")
- **3.3 Series Registry:** Detect missing recurring payments (expected vs actual)
- **3.4 Tax Categorization:** Filter alerts by category (e.g., "Alert if Dining > $400/month")
- **3.6 Unit:** Handle multi-currency thresholds (convert to user's base currency)
- **2.1 Transaction List View:** Notification action links to filtered transaction view

**External Dependencies:**
- **Email Service:** SendGrid or AWS SES for email delivery with webhook callbacks
- **SMS Service:** Twilio or AWS SNS for SMS delivery with delivery receipts
- **Push Notification Service:** Firebase Cloud Messaging (FCM) or Apple Push Notification Service (APNS)
- **Scheduler:** Cron daemon or AWS EventBridge for scheduled rule evaluation
- **Message Queue:** RabbitMQ or AWS SQS for async notification dispatch

**Database Dependencies:**
- **PostgreSQL:** Primary database for reminder_config and notification_event tables
- **Redis:** Cache for active reminder rules and recent notification dedup keys

**API Dependencies:**
- **Account Balance API:** External banking API or plaid.com for real-time balance checks (if not using local sync)
- **Timezone Database:** IANA timezone database for DST-aware scheduling

---

### 7. Inputs & Outputs

**Inputs:**

1. **Reminder Configuration (User-Defined)**
   ```json
   {
     "config_id": "reminder_123",
     "user_id": "user_456",
     "type": "low_balance",
     "name": "Low Balance Alert: Chase Checking",
     "enabled": true,
     "conditions": {
       "account_id": "acct_chase_checking",
       "threshold_amount": 500.00,
       "comparison": "less_than"
     },
     "schedule": {
       "type": "cron",
       "expression": "0 8 * * *",
       "timezone": "America/Los_Angeles"
     },
     "channels": ["in_app", "email"],
     "preferences": {
       "cooldown_hours": 24,
       "rate_limit_per_day": 5
     }
   }
   ```

2. **Real-Time Event (Transaction Posted)**
   ```json
   {
     "event_type": "transaction.created",
     "event_id": "evt_abc123",
     "timestamp": "2024-10-17T15:30:00Z",
     "data": {
       "transaction_id": "txn_789",
       "account_id": "acct_chase_checking",
       "amount": -2500.00,
       "merchant": "Apple Store",
       "date": "2024-10-17"
     }
   }
   ```

3. **Scheduled Trigger (Cron Job)**
   ```json
   {
     "trigger_type": "scheduled",
     "schedule_time": "2024-10-17T08:00:00Z",
     "rules_to_evaluate": ["reminder_123", "reminder_456", "..."]
   }
   ```

4. **User Action (Snooze Request)**
   ```json
   {
     "action": "snooze",
     "notification_id": "notif_abc123",
     "user_id": "user_456",
     "snooze_duration_seconds": 172800,  // 2 days
     "requested_at": "2024-10-17T10:30:00Z"
   }
   ```

**Outputs:**

1. **Notification Event (Created)**
   ```json
   {
     "notification_id": "notif_abc123",
     "user_id": "user_456",
     "config_id": "reminder_123",
     "type": "low_balance",
     "severity": "warning",
     "title": "Low Balance Alert: Chase Checking",
     "body": "Your balance is $485.00, below your $500 threshold.",
     "action_url": "/accounts/acct_chase_checking",
     "action_label": "View Account",
     "status": "pending",
     "channels": ["in_app", "email"],
     "created_at": "2024-10-17T08:00:00Z",
     "metadata": {
       "account_id": "acct_chase_checking",
       "current_balance": 485.00,
       "threshold": 500.00
     }
   }
   ```

2. **Email Payload (SendGrid)**
   ```json
   {
     "to": "user@example.com",
     "from": "alerts@financeapp.com",
     "subject": "Low Balance Alert: Chase Checking",
     "template_id": "low_balance_alert_v1",
     "template_data": {
       "user_name": "John Doe",
       "account_name": "Chase Checking",
       "current_balance": "$485.00",
       "threshold": "$500.00",
       "action_url": "https://app.financeapp.com/accounts/acct_chase_checking"
     }
   }
   ```

3. **In-App Notification (WebSocket Push)**
   ```json
   {
     "channel": "user_456_notifications",
     "event": "notification.created",
     "payload": {
       "notification_id": "notif_abc123",
       "title": "Low Balance Alert",
       "body": "Your balance is $485.00",
       "icon": "warning",
       "timestamp": "2024-10-17T08:00:00Z",
       "unread_count": 3
     }
   }
   ```

4. **Delivery Receipt (Email Opened)**
   ```json
   {
     "notification_id": "notif_abc123",
     "channel": "email",
     "status": "delivered",
     "delivered_at": "2024-10-17T08:01:30Z",
     "opened_at": "2024-10-17T10:32:00Z",
     "provider_message_id": "sendgrid_msg_xyz"
   }
   ```

---

### 8. Validation Rules

**Reminder Configuration Validation:**
- `config_id`: Required, unique per user, format: `reminder_{random}`
- `user_id`: Required, must reference existing user
- `type`: Required, enum: ["low_balance", "missing_recurring_payment", "large_expense", "payment_due_date", "budget_exceeded", "custom"]
- `name`: Required, max 100 characters, user-friendly label
- `enabled`: Required, boolean (default: true)
- `conditions`: Required, object, validation depends on `type`:
  - `low_balance`: Requires `account_id`, `threshold_amount` (> 0), `comparison` (enum: ["less_than", "greater_than"])
  - `missing_recurring_payment`: Requires `series_id`, `days_late_threshold` (default: 3)
  - `large_expense`: Requires `threshold_amount` OR `threshold_multiplier` (e.g., 3Ã— average)
  - `payment_due_date`: Requires `account_id`, `days_before_due` (1-30)
- `schedule`: Required for scheduled types, optional for real-time types
  - `type`: enum: ["cron", "real_time"]
  - `expression`: Required if type=cron, valid cron syntax (validated by croniter library)
  - `timezone`: Required if type=cron, valid IANA timezone (e.g., "America/Los_Angeles")
- `channels`: Required, non-empty array, values: ["in_app", "email", "sms", "push"]
  - Must respect user's global notification preferences (email disabled globally â†’ remove "email" from channels)
- `preferences.cooldown_hours`: Optional, integer 1-168 (1 hour to 7 days), default: 24
- `preferences.rate_limit_per_day`: Optional, integer 1-100, default: 20

**Notification Event Validation:**
- `notification_id`: Required, unique globally, format: `notif_{random}`
- `user_id`: Required, must reference existing user
- `config_id`: Optional (can be null for system-generated notifications)
- `type`: Required, same enum as reminder config
- `severity`: Required, enum: ["info", "warning", "alert", "critical"]
- `title`: Required, max 200 characters
- `body`: Required, max 1000 characters
- `action_url`: Optional, valid URL path or external URL
- `action_label`: Optional, max 50 characters (default: "View")
- `status`: Required, enum: ["pending", "sent", "delivered", "read", "snoozed", "dismissed", "auto_dismissed", "failed", "cancelled"]
- `channels`: Required, non-empty array (subset of config.channels)
- `snoozed_until`: Required if status=snoozed, ISO 8601 datetime in future
- `metadata`: Optional, JSON object, max 10KB

**Snooze Action Validation:**
- `notification_id`: Required, must exist and status must be "delivered" or "read"
- `snooze_duration_seconds`: Required, integer 3600-604800 (1 hour to 7 days)
- `user_id`: Required, must own the notification

**Dismiss Action Validation:**
- `notification_id`: Required, must exist and status must be "delivered" or "read" or "snoozed"
- `user_id`: Required, must own the notification

---

### 9. Error Handling

**Evaluation Errors:**

1. **Condition Evaluation Failed (Stale Data)**
   ```
   Error: Cannot evaluate alert "Low Balance: Chase Checking" - account balance not synced (last sync: 3 days ago)
   Recovery: Skip evaluation, log warning, send user notification: "Unable to check balance alerts"
   Retry: Re-evaluate on next scheduled run (1 hour later)
   ```

2. **Missing Referenced Entity (Account Deleted)**
   ```
   Error: Alert rule references account_id="acct_123" which no longer exists (deleted by user)
   Recovery: Auto-disable alert rule, send user notification: "Alert disabled: referenced account was deleted"
   User Action: User must edit or delete the alert rule
   ```

3. **Invalid Cron Expression**
   ```
   Error: Cron expression "0 25 * * *" is invalid (hour must be 0-23)
   Recovery: Reject reminder config creation, return 400 Bad Request with error message
   UI Validation: Validate cron syntax client-side before submission
   ```

**Delivery Errors:**

4. **Email Delivery Failed (Bounced)**
   ```
   Error: Email to user@example.com bounced (reason: "Address does not exist")
   Recovery:
     1. Mark notification as FAILED
     2. Retry 3Ã— with exponential backoff (5 min, 30 min, 2h)
     3. After 3 failures, mark as PERMANENTLY_FAILED
     4. Send in-app notification to user: "Update your email address"
   ```

5. **SMS Delivery Failed (Invalid Number)**
   ```
   Error: SMS to +1-555-0123 failed (reason: "Number is not reachable")
   Recovery: Same as email (retry 3Ã—, then PERMANENTLY_FAILED)
   ```

6. **Push Notification Failed (Device Token Expired)**
   ```
   Error: Push notification failed (reason: "FCM token expired")
   Recovery:
     1. Remove expired token from user's device registry
     2. Send in-app notification instead (fallback channel)
     3. Log warning: User needs to re-login to refresh push token
   ```

**Rate Limiting Errors:**

7. **User Rate Limit Exceeded**
   ```
   Error: User user_123 has received 20 notifications today (limit reached)
   Recovery:
     1. Queue notification for digest (send at 6 PM daily)
     2. Log: "Notification queued for digest due to rate limit"
     3. Do NOT send individual notification
   ```

8. **Global Rate Limit Exceeded (System Overload)**
   ```
   Error: System is sending > 10,000 notifications/minute (circuit breaker triggered)
   Recovery:
     1. Queue notifications in RabbitMQ (buffer up to 1M messages)
     2. Process queue at reduced rate (5,000/minute)
     3. Send admin alert: "Notification system under heavy load"
   ```

**Idempotency Errors:**

9. **Duplicate Notification Detected**
   ```
   Error: Notification with dedup_key="low_balance:acct_123:2024-10-17" already sent 2 hours ago
   Recovery: Skip notification creation, log: "Duplicate notification suppressed"
   ```

10. **Concurrent Snooze/Dismiss Actions**
    ```
    Error: User clicked "Snooze" and "Dismiss" simultaneously (race condition)
    Recovery:
      1. Use database optimistic locking (UPDATE WHERE version = X)
      2. First action wins (e.g., Snooze), second returns 409 Conflict
      3. UI shows error: "Notification already snoozed, please refresh"
    ```

**Timezone Errors:**

11. **Invalid Timezone**
    ```
    Error: Timezone "America/LosAngeles" is invalid (typo: should be "America/Los_Angeles")
    Recovery: Reject reminder config creation, return 400 Bad Request
    UI: Use dropdown with valid IANA timezones (not free text)
    ```

12. **DST Transition Handling**
    ```
    Edge Case: User schedules alert at "2:30 AM" on DST transition day (2:00 AM â†’ 3:00 AM, 2:30 AM doesn't exist)
    Recovery:
      1. Detect DST gap (2:30 AM missing)
      2. Adjust to 3:00 AM (next valid time after DST transition)
      3. Log: "Alert time adjusted for DST: 2:30 AM â†’ 3:00 AM"
    ```

---

### 10. Example Scenarios

**Scenario 1: Multi-Account Low Balance Alert**

Context: User has 3 checking accounts, wants single alert if ANY balance < $500

Reminder Config:
```json
{
  "type": "low_balance",
  "name": "Multi-Account Low Balance",
  "conditions": {
    "account_ids": ["acct_chase", "acct_bofa", "acct_wells"],
    "threshold_amount": 500.00,
    "aggregation": "any"  // Alert if ANY account below threshold
  },
  "schedule": {
    "type": "cron",
    "expression": "0 8 * * *"
  }
}
```

Notification:
```
Title: Low Balance Alert
Body: 2 accounts are below $500 threshold:
  - Chase Checking: $485.00
  - Bank of America Checking: $320.00

Wells Fargo Checking is OK: $1,250.00

[View Accounts]
```

**Scenario 2: Category Budget Exceeded**

Context: User sets monthly budget for "Dining" category = $400. Alert when 90% spent.

Reminder Config:
```json
{
  "type": "budget_exceeded",
  "conditions": {
    "category": "Dining",
    "budget_amount": 400.00,
    "threshold_pct": 0.90,  // Alert at 90% = $360
    "period": "monthly"
  },
  "schedule": {
    "type": "real_time"  // Alert immediately when transaction posts
  }
}
```

Flow:
1. User spends $50 at restaurant (Oct 17, 3:00 PM)
2. Month-to-date Dining spending: $310 â†’ $360
3. $360 / $400 = 90% â†’ threshold met
4. Notification sent immediately:
   ```
   Title: Budget Alert: Dining
   Body: You've spent $360 of $400 budget this month (90%). $40 remaining.
   ```

**Scenario 3: Unusual Merchant Alert**

Context: User wants to be notified of ANY transaction at specific merchant (e.g., "Casino")

Reminder Config:
```json
{
  "type": "merchant_watchlist",
  "conditions": {
    "merchant_patterns": ["*Casino*", "*Gambling*", "*Poker*"],
    "amount_threshold": 0.01  // Any amount
  },
  "schedule": {
    "type": "real_time"
  },
  "channels": ["in_app", "email", "sms"]  // High priority
}
```

Notification:
```
Title: Watchlist Alert: Casino Transaction
Body: Transaction detected at "MGM Grand Casino" for $150.00 on Oct 17.
[View Transaction] [Report Fraud]
```

**Scenario 4: Subscription Renewal Reminder**

Context: User has 10 subscriptions (Netflix, Spotify, etc.), wants reminder 1 day before each renewal

Reminder Config:
```json
{
  "type": "series_upcoming",
  "conditions": {
    "series_tags": ["subscription"],  // All series tagged as subscription
    "days_before": 1
  },
  "schedule": {
    "type": "cron",
    "expression": "0 9 * * *"  // Daily at 9 AM
  }
}
```

Notification:
```
Title: Subscription Renewal Tomorrow
Body: Netflix subscription ($15.99) will renew tomorrow (Oct 18).
[View Series] [Cancel Subscription]
```

**Scenario 5: Income Deposit Confirmation**

Context: User expects paycheck deposit every 2 weeks (bi-weekly), wants confirmation when it posts

Reminder Config:
```json
{
  "type": "expected_income",
  "conditions": {
    "series_id": "series_paycheck",
    "notification_on": "posted"  // Alert when income POSTS (not missing)
  },
  "schedule": {
    "type": "real_time"
  }
}
```

Notification:
```
Title: Paycheck Deposited
Body: Your paycheck of $3,500.00 has been deposited to Chase Checking.
[View Transaction]
```

**Scenario 6: Multi-Domain Example: Healthcare Medication Refill**

Context: Patient has prescription that needs refill every 30 days

Reminder Config:
```json
{
  "type": "medication_refill",
  "conditions": {
    "medication_name": "Lisinopril 10mg",
    "refill_schedule": "every_30_days",
    "last_refill_date": "2024-09-17",
    "days_before_empty": 7  // Alert 7 days before running out
  },
  "schedule": {
    "type": "cron",
    "expression": "0 10 * * *"
  }
}
```

Notification:
```
Title: Medication Refill Reminder
Body: Your Lisinopril prescription will run out in 7 days (Oct 24). Request refill now.
[Request Refill] [Snooze]
```

**Scenario 7: Multi-Domain Example: Legal Filing Deadline**

Context: Attorney has court filing deadline, wants reminder 7 days before + 1 day before

Reminder Config (2 rules):
```json
[
  {
    "type": "legal_deadline",
    "conditions": {
      "case_id": "case_12345",
      "deadline_type": "motion_filing",
      "deadline_date": "2024-11-01",
      "days_before": 7
    }
  },
  {
    "type": "legal_deadline",
    "conditions": {
      "case_id": "case_12345",
      "deadline_type": "motion_filing",
      "deadline_date": "2024-11-01",
      "days_before": 1
    },
    "channels": ["in_app", "email", "sms"]  // High priority for 1-day reminder
  }
]
```

Notifications:
```
Oct 25: "Motion filing due in 7 days (Case #12345, Nov 1)"
Oct 31: "URGENT: Motion filing due TOMORROW (Case #12345, Nov 1)" [sent via email + SMS]
```

**Scenario 8: Multi-Domain Example: Research Grant Deadline**

Context: Researcher has grant application deadline, wants reminders at 30 days, 7 days, 1 day

Reminder Config:
```json
{
  "type": "grant_deadline",
  "conditions": {
    "grant_id": "NSF_2024_XYZ",
    "deadline_date": "2024-12-15",
    "reminder_days": [30, 7, 1]  // Multiple reminder points
  }
}
```

Notifications:
```
Nov 15: "Grant deadline in 30 days (NSF 2024-XYZ, Dec 15)"
Dec 8: "Grant deadline in 7 days (NSF 2024-XYZ, Dec 15)"
Dec 14: "URGENT: Grant deadline TOMORROW (NSF 2024-XYZ, Dec 15)"
```

---

## Machinery Layer (Sections 11-15)

### 11. Core Primitives (OL)

This vertical introduces **4 new OL primitives** for reminder management:

#### 11.1 ReminderEngine (Orchestrator)
**Purpose:** Core orchestrator for creating, scheduling, and triggering reminders

**Methods:**
- `create_reminder_config(user_id, type, conditions, schedule, channels) â†’ ReminderConfig`
- `update_reminder_config(config_id, updates) â†’ ReminderConfig`
- `delete_reminder_config(config_id) â†’ void`
- `enable_reminder(config_id) â†’ void`
- `disable_reminder(config_id) â†’ void`
- `evaluate_scheduled_rules(schedule_time) â†’ List[NotificationEvent]`
- `process_realtime_event(event_type, event_data) â†’ List[NotificationEvent]`

**Multi-Domain Examples:** See [ReminderEngine.md](../primitives/ol/ReminderEngine.md)

#### 11.2 AlertRuleEvaluator (Condition Checker)
**Purpose:** Evaluate alert conditions against current system state (balances, transactions, dates)

**Methods:**
- `evaluate_condition(config_id, current_state) â†’ bool`
- `check_missing_payment(series_id, date_range) â†’ MissingPaymentResult`
- `check_balance_threshold(account_id, threshold, comparison) â†’ BalanceCheckResult`
- `check_large_expense(transaction, threshold_multiplier) â†’ bool`
- `check_payment_due(account_id, days_before) â†’ DueDateCheckResult`

**Multi-Domain Examples:** See [AlertRuleEvaluator.md](../primitives/ol/AlertRuleEvaluator.md)

#### 11.3 NotificationDispatcher (Multi-Channel Delivery)
**Purpose:** Dispatch notifications to multiple channels (in-app, email, SMS, push) with delivery tracking

**Methods:**
- `send_notification(notification_id, channels) â†’ DeliveryReceipt`
- `send_email(notification_id, template_id, recipient) â†’ EmailReceipt`
- `send_sms(notification_id, message, phone_number) â†’ SmsReceipt`
- `send_push(notification_id, device_tokens) â†’ PushReceipt`
- `send_inapp(notification_id, user_id) â†’ void`
- `process_delivery_webhook(provider, webhook_data) â†’ void`

**Multi-Domain Examples:** See [NotificationDispatcher.md](../primitives/ol/NotificationDispatcher.md)

#### 11.4 ReminderStore (CRUD & State Management)
**Purpose:** CRUD operations for reminder configurations and notification events with snooze/dismiss tracking

**Methods:**
- `save_config(config_data) â†’ ReminderConfig`
- `get_config(config_id) â†’ ReminderConfig`
- `list_user_configs(user_id, filters) â†’ List[ReminderConfig]`
- `create_notification(notification_data) â†’ NotificationEvent`
- `update_notification_status(notification_id, status, metadata) â†’ void`
- `snooze_notification(notification_id, snooze_until) â†’ void`
- `dismiss_notification(notification_id, reason) â†’ void`
- `get_unread_notifications(user_id) â†’ List[NotificationEvent]`

**Multi-Domain Examples:** See [ReminderStore.md](../primitives/ol/ReminderStore.md)

---

### 12. Interface Components (IL)

This vertical introduces **3 new IL components** for reminder UI:

#### 12.1 ReminderBell (Header Icon)
**Purpose:** Header bell icon with unread count badge, opens NotificationPanel on click

**Props:**
```typescript
interface ReminderBellProps {
  userId: string;
  unreadCount: number;
  onOpen: () => void;
  maxDisplayCount?: number;  // Default: 99 (shows "99+" if exceeded)
}
```

**Multi-Domain Examples:** See [ReminderBell.md](../primitives/il/ReminderBell.md)

#### 12.2 NotificationPanel (Slide-In Panel)
**Purpose:** Slide-in panel showing active alerts with tabs (Unread, Snoozed, All)

**Props:**
```typescript
interface NotificationPanelProps {
  userId: string;
  isOpen: boolean;
  onClose: () => void;
  onNotificationClick: (notificationId: string) => void;
  onSnooze: (notificationId: string, duration: number) => void;
  onDismiss: (notificationId: string) => void;
}
```

**Multi-Domain Examples:** See [NotificationPanel.md](../primitives/il/NotificationPanel.md)

#### 12.3 ReminderConfigDialog (Modal)
**Purpose:** Modal dialog for creating and editing reminder rules

**Props:**
```typescript
interface ReminderConfigDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (config: ReminderConfig) => void;
  initialConfig?: ReminderConfig;  // For editing existing rule
  availableAccounts: Account[];
  availableSeries: Series[];
}
```

**Multi-Domain Examples:** See [ReminderConfigDialog.md](../primitives/il/ReminderConfigDialog.md)

---

### 13. Reusability (Multi-Domain Generalization)

**Core Insight:** The Reminders vertical is NOT finance-specific. It's a **generic event-driven notification system** that can alert users about ANY condition across ANY domain.

**Generic Pattern:**
```typescript
interface RemindableEvent<T> {
  event_type: string;                    // "balance_below_threshold", "medication_refill_due", "deadline_approaching"
  entity_type: string;                   // "account", "prescription", "grant_application"
  entity_id: string;                     // Domain-specific entity reference
  trigger_condition: Condition<T>;       // Generic condition evaluator
  notification_template: NotificationTemplate;
  delivery_channels: DeliveryChannel[];
  recurrence?: RecurrencePattern;
}

interface Condition<T> {
  evaluate(current_state: T) -> boolean;
  get_metadata() -> object;              // Context for notification body
}
```

**Multi-Domain Mapping:**

| Domain | Event Type | Entity | Condition Example | Notification |
|--------|-----------|--------|-------------------|--------------|
| **Finance** | `balance_below_threshold` | Account | `balance < $500` | "Chase Checking: $485 (below $500)" |
| **Healthcare** | `medication_refill_due` | Prescription | `days_until_empty < 7` | "Lisinopril refill needed in 7 days" |
| **Legal** | `deadline_approaching` | Case Filing | `days_until_deadline < 7` | "Motion due in 7 days (Case #12345)" |
| **Research** | `grant_deadline` | Grant App | `days_until_deadline < 30` | "NSF grant due in 30 days" |
| **E-commerce** | `inventory_low_stock` | Product SKU | `stock_quantity < reorder_point` | "Product ABC low stock: 5 units left" |
| **Logistics** | `shipment_delayed` | Shipment | `current_date > expected_delivery + 2` | "Shipment #789 delayed 2 days" |

**Configuration Abstraction:**

Finance Domain (Specific):
```json
{
  "type": "low_balance",
  "conditions": {
    "account_id": "acct_123",
    "threshold_amount": 500.00
  }
}
```

Generic Domain (Abstract):
```json
{
  "type": "threshold_alert",
  "entity_type": "account",
  "entity_id": "acct_123",
  "conditions": {
    "metric": "balance",
    "operator": "less_than",
    "threshold": 500.00
  }
}
```

Healthcare Domain (Reuse):
```json
{
  "type": "threshold_alert",
  "entity_type": "prescription",
  "entity_id": "rx_456",
  "conditions": {
    "metric": "days_until_refill",
    "operator": "less_than",
    "threshold": 7
  }
}
```

**Delivery Channel Abstraction:**

All domains use SAME delivery primitives:
- `NotificationDispatcher.send_email()` works for finance alerts, legal deadlines, research grants
- `NotificationDispatcher.send_sms()` works for medication reminders, shipment delays
- Template system allows domain-specific content while reusing delivery infrastructure

**Scheduler Abstraction:**

All domains use SAME scheduler:
- Finance: Daily 8 AM check for low balance
- Healthcare: Daily 10 AM check for medication refills
- Legal: Daily 9 AM check for approaching deadlines
- Research: Weekly check for grant deadlines

Implementation: Single `ReminderEngine.evaluate_scheduled_rules()` method handles ALL domains

---

### 14. Pattern Abstraction

**Generic Reminder Pattern:**

```typescript
// Domain-agnostic reminder configuration
interface GenericReminderConfig<TCondition, TEntity> {
  config_id: string;
  user_id: string;
  name: string;
  enabled: boolean;

  // Entity being monitored
  entity_type: string;
  entity_id: string;

  // Condition evaluator (domain-specific)
  condition: TCondition;

  // Trigger strategy
  trigger: {
    type: "scheduled" | "real_time" | "hybrid";
    schedule?: CronExpression;
    event_types?: string[];  // For real-time triggers
  };

  // Notification delivery
  notification_template: {
    title_template: string;
    body_template: string;
    severity: "info" | "warning" | "alert" | "critical";
    action_url_template: string;
  };

  channels: DeliveryChannel[];
  preferences: ReminderPreferences;
}

// Domain-specific condition implementations
interface FinanceCondition {
  type: "balance_threshold" | "missing_payment" | "large_expense";
  params: {
    account_id?: string;
    threshold_amount?: number;
    comparison?: "less_than" | "greater_than";
    series_id?: string;
    multiplier?: number;
  };
}

interface HealthcareCondition {
  type: "medication_refill" | "appointment_reminder" | "test_result";
  params: {
    prescription_id?: string;
    days_before_empty?: number;
    appointment_id?: string;
    days_before_appointment?: number;
  };
}

interface LegalCondition {
  type: "deadline" | "contract_expiration" | "retainer_low";
  params: {
    case_id?: string;
    deadline_date?: string;
    days_before?: number;
    contract_id?: string;
    retainer_threshold?: number;
  };
}

// Generic evaluator interface
interface ConditionEvaluator<TCondition, TState> {
  evaluate(condition: TCondition, current_state: TState): EvaluationResult;
}

interface EvaluationResult {
  is_triggered: boolean;
  metadata: Record<string, any>;  // For notification template context
  confidence?: number;             // Optional: confidence score for ML-based triggers
}

// Concrete implementations
class FinanceConditionEvaluator implements ConditionEvaluator<FinanceCondition, FinanceState> {
  evaluate(condition: FinanceCondition, state: FinanceState): EvaluationResult {
    switch (condition.type) {
      case "balance_threshold":
        const balance = state.accounts.get(condition.params.account_id).balance;
        const is_triggered = balance < condition.params.threshold_amount;
        return {
          is_triggered,
          metadata: {
            current_balance: balance,
            threshold: condition.params.threshold_amount,
            account_name: state.accounts.get(condition.params.account_id).name
          }
        };

      case "missing_payment":
        const series = state.series.get(condition.params.series_id);
        const expected_date = series.next_expected_date;
        const found = state.transactions.find(t =>
          t.series_id === series.id &&
          t.date >= expected_date - 3 &&
          t.date <= expected_date + 3
        );
        return {
          is_triggered: !found && (new Date() > expected_date),
          metadata: {
            series_name: series.name,
            expected_amount: series.expected_amount,
            expected_date: expected_date,
            days_late: Math.floor((new Date() - expected_date) / 86400000)
          }
        };

      default:
        throw new Error(`Unknown condition type: ${condition.type}`);
    }
  }
}

class HealthcareConditionEvaluator implements ConditionEvaluator<HealthcareCondition, HealthcareState> {
  evaluate(condition: HealthcareCondition, state: HealthcareState): EvaluationResult {
    switch (condition.type) {
      case "medication_refill":
        const rx = state.prescriptions.get(condition.params.prescription_id);
        const days_until_empty = rx.days_supply_remaining;
        const is_triggered = days_until_empty < condition.params.days_before_empty;
        return {
          is_triggered,
          metadata: {
            medication_name: rx.name,
            days_until_empty: days_until_empty,
            last_refill_date: rx.last_refill_date
          }
        };

      case "appointment_reminder":
        const appt = state.appointments.get(condition.params.appointment_id);
        const days_until_appt = Math.floor((appt.date - new Date()) / 86400000);
        const is_triggered = days_until_appt === condition.params.days_before_appointment;
        return {
          is_triggered,
          metadata: {
            provider_name: appt.provider_name,
            appointment_date: appt.date,
            appointment_type: appt.type
          }
        };

      default:
        throw new Error(`Unknown condition type: ${condition.type}`);
    }
  }
}

// Generic ReminderEngine (domain-agnostic)
class GenericReminderEngine<TCondition, TState> {
  constructor(
    private conditionEvaluator: ConditionEvaluator<TCondition, TState>,
    private notificationDispatcher: NotificationDispatcher,
    private reminderStore: ReminderStore
  ) {}

  async evaluate_and_notify(
    config: GenericReminderConfig<TCondition, any>,
    current_state: TState
  ): Promise<NotificationEvent | null> {
    // 1. Evaluate condition
    const result = this.conditionEvaluator.evaluate(config.condition, current_state);

    if (!result.is_triggered) {
      return null;  // Condition not met, no notification
    }

    // 2. Check deduplication and cooldown
    const recent_notification = await this.reminderStore.find_recent_notification(
      config.config_id,
      config.preferences.cooldown_hours
    );

    if (recent_notification) {
      return null;  // Already notified recently, skip
    }

    // 3. Render notification from template
    const notification = this.render_notification(config, result.metadata);

    // 4. Save notification
    await this.reminderStore.create_notification(notification);

    // 5. Dispatch to channels
    await this.notificationDispatcher.send_notification(
      notification.notification_id,
      config.channels
    );

    return notification;
  }

  private render_notification(
    config: GenericReminderConfig<TCondition, any>,
    metadata: Record<string, any>
  ): NotificationEvent {
    // Simple template rendering (Handlebars-style)
    const title = this.render_template(config.notification_template.title_template, metadata);
    const body = this.render_template(config.notification_template.body_template, metadata);
    const action_url = this.render_template(config.notification_template.action_url_template, metadata);

    return {
      notification_id: generate_id("notif"),
      user_id: config.user_id,
      config_id: config.config_id,
      type: config.entity_type,
      severity: config.notification_template.severity,
      title,
      body,
      action_url,
      status: "pending",
      channels: config.channels,
      created_at: new Date().toISOString(),
      metadata
    };
  }

  private render_template(template: string, data: Record<string, any>): string {
    return template.replace(/\{\{(\w+)\}\}/g, (match, key) => data[key] || match);
  }
}

// Usage examples
const financeEngine = new GenericReminderEngine(
  new FinanceConditionEvaluator(),
  notificationDispatcher,
  reminderStore
);

const healthcareEngine = new GenericReminderEngine(
  new HealthcareConditionEvaluator(),
  notificationDispatcher,
  reminderStore
);

// Both use SAME core engine, different evaluators
```

**Key Abstraction Benefits:**
1. **Single Dispatcher:** `NotificationDispatcher` works across ALL domains (no finance-specific code)
2. **Single Store:** `ReminderStore` stores configs and notifications for ALL domains in same tables
3. **Single Scheduler:** Cron-based scheduler triggers ALL domain reminder checks
4. **Domain-Specific Logic Isolated:** Only `ConditionEvaluator` implementation changes per domain
5. **Reusable UI Components:** `ReminderBell`, `NotificationPanel`, `ReminderConfigDialog` work across domains with prop customization

---

### 15. Runner/Coordinator Separation

**Coordinator (API Layer - Stateless):**

```python
# app/api/reminders/routes.py
from fastapi import APIRouter, Depends
from app.primitives.ol.ReminderEngine import ReminderEngine
from app.primitives.ol.ReminderStore import ReminderStore

router = APIRouter(prefix="/api/reminders")

@router.post("/configs")
async def create_reminder_config(
    config_data: ReminderConfigCreate,
    user_id: str = Depends(get_current_user),
    engine: ReminderEngine = Depends(get_reminder_engine)
):
    """
    Coordinator: Validates input, calls ReminderEngine (Runner)
    """
    # 1. Validate user owns referenced entities (accounts, series)
    validate_entity_ownership(user_id, config_data)

    # 2. Delegate to Runner
    config = engine.create_reminder_config(
        user_id=user_id,
        type=config_data.type,
        conditions=config_data.conditions,
        schedule=config_data.schedule,
        channels=config_data.channels
    )

    return ReminderConfigResponse.from_orm(config)

@router.post("/notifications/{notification_id}/snooze")
async def snooze_notification(
    notification_id: str,
    snooze_data: SnoozeRequest,
    user_id: str = Depends(get_current_user),
    store: ReminderStore = Depends(get_reminder_store)
):
    """
    Coordinator: Validates ownership, calls ReminderStore (Runner)
    """
    # 1. Validate user owns notification
    notification = store.get_notification(notification_id)
    if notification.user_id != user_id:
        raise HTTPException(403, "Not authorized")

    # 2. Delegate to Runner
    store.snooze_notification(
        notification_id=notification_id,
        snooze_until=datetime.now() + timedelta(seconds=snooze_data.duration_seconds)
    )

    return {"status": "snoozed"}
```

**Runner (OL Primitive - Business Logic):**

```python
# app/primitives/ol/ReminderEngine.py
class ReminderEngine:
    """
    Runner: Pure business logic, no HTTP concerns
    """

    def __init__(
        self,
        reminder_store: ReminderStore,
        alert_evaluator: AlertRuleEvaluator,
        notification_dispatcher: NotificationDispatcher
    ):
        self.reminder_store = reminder_store
        self.alert_evaluator = alert_evaluator
        self.notification_dispatcher = notification_dispatcher

    def create_reminder_config(
        self,
        user_id: str,
        type: str,
        conditions: dict,
        schedule: dict,
        channels: List[str]
    ) -> ReminderConfig:
        """
        Business logic: Create and persist reminder configuration
        """
        # 1. Generate unique config_id
        config_id = generate_id("reminder")

        # 2. Validate cron expression (if scheduled)
        if schedule.get("type") == "cron":
            validate_cron_expression(schedule["expression"])

        # 3. Create config object
        config = ReminderConfig(
            config_id=config_id,
            user_id=user_id,
            type=type,
            enabled=True,
            conditions=conditions,
            schedule=schedule,
            channels=channels,
            created_at=datetime.utcnow()
        )

        # 4. Persist to database
        self.reminder_store.save_config(config)

        # 5. Schedule cron job (if applicable)
        if schedule.get("type") == "cron":
            self.schedule_cron_job(config_id, schedule)

        return config

    def evaluate_scheduled_rules(self, schedule_time: datetime) -> List[NotificationEvent]:
        """
        Business logic: Evaluate all scheduled rules at given time
        Called by cron daemon, NOT by HTTP request
        """
        notifications = []

        # 1. Fetch all enabled rules scheduled for this time
        configs = self.reminder_store.get_scheduled_configs(schedule_time)

        # 2. Evaluate each rule
        for config in configs:
            try:
                result = self.alert_evaluator.evaluate_condition(
                    config.config_id,
                    self.get_current_state(config)
                )

                if result.is_triggered:
                    # 3. Create notification
                    notification = self.create_notification(config, result.metadata)
                    notifications.append(notification)

                    # 4. Dispatch to channels (async)
                    self.notification_dispatcher.send_notification(
                        notification.notification_id,
                        config.channels
                    )
            except Exception as e:
                logger.error(f"Failed to evaluate rule {config.config_id}: {e}")
                continue

        return notifications

    def process_realtime_event(self, event_type: str, event_data: dict) -> List[NotificationEvent]:
        """
        Business logic: Handle real-time event (e.g., transaction.created)
        Called by webhook handler, NOT by user request
        """
        notifications = []

        # 1. Find rules triggered by this event type
        configs = self.reminder_store.get_realtime_configs(event_type)

        # 2. Evaluate each rule against event data
        for config in configs:
            result = self.alert_evaluator.evaluate_condition(
                config.config_id,
                event_data
            )

            if result.is_triggered:
                notification = self.create_notification(config, result.metadata)
                notifications.append(notification)
                self.notification_dispatcher.send_notification(
                    notification.notification_id,
                    config.channels
                )

        return notifications
```

**Background Worker (Cron Daemon):**

```python
# app/workers/reminder_scheduler.py
import schedule
import time
from app.primitives.ol.ReminderEngine import ReminderEngine

def run_scheduled_reminders():
    """
    Background worker: Runs every minute, triggers ReminderEngine
    """
    engine = get_reminder_engine()
    current_time = datetime.utcnow()

    logger.info(f"Running scheduled reminders at {current_time}")
    notifications = engine.evaluate_scheduled_rules(current_time)
    logger.info(f"Created {len(notifications)} notifications")

# Schedule every minute
schedule.every(1).minutes.do(run_scheduled_reminders)

while True:
    schedule.run_pending()
    time.sleep(1)
```

**Separation Benefits:**
1. **Coordinator (API):** Handles HTTP, auth, validation â†’ stateless, horizontally scalable
2. **Runner (OL):** Pure business logic â†’ testable without HTTP mocking
3. **Background Worker:** Scheduled execution â†’ separate process, doesn't block API requests

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All API endpoints require valid JWT token (`Authorization: Bearer {token}`)
- Users can ONLY create/view/edit their OWN reminder configs and notifications
- Database queries filtered by `user_id` (multi-tenancy isolation)
- Admin users can view system-wide reminder metrics (not individual notifications)

**Data Privacy:**
- Notification bodies may contain sensitive data (balance amounts, merchant names)
- Email/SMS delivery must use TLS encryption (SendGrid/Twilio enforce this)
- Do NOT log full notification bodies (log only notification_id + type)
- Notification retention: 30 days in hot storage, then archive to S3 with encryption at rest

**Webhook Security:**
- Delivery webhook endpoints (email opened, SMS delivered) must validate signatures
  - SendGrid: Validate `X-Twilio-Email-Event-Webhook-Signature` header
  - Twilio: Validate `X-Twilio-Signature` header using HMAC-SHA256
- Reject webhooks with invalid signatures (prevent spoofing)

**Rate Limiting (Security):**
- User rate limit: 100 API requests per minute (prevent abuse)
- Notification rate limit: 20 notifications per day per user (prevent spam)
- Global rate limit: 10,000 notifications per minute (circuit breaker for system overload)

**Input Validation:**
- Cron expressions validated with croniter library (prevent code injection)
- Timezone strings validated against IANA database (prevent invalid timezones)
- Email addresses validated with regex (prevent invalid emails)
- Phone numbers validated with E.164 format (prevent invalid SMS)

**Secrets Management:**
- SendGrid API key stored in environment variable (NOT in code)
- Twilio credentials stored in AWS Secrets Manager (rotated every 90 days)
- Webhook signature secrets stored in environment (per-environment secrets)

---

### 17. Performance Characteristics

**Latency Targets:**
- Create reminder config: < 200ms (p95)
- Evaluate scheduled rules (1,000 rules): < 10 seconds (p95)
- Send notification (single channel): < 2 seconds (p95)
- Snooze/dismiss action: < 500ms (p95)
- Fetch unread notifications: < 300ms (p95)

**Throughput Targets:**
- Scheduled rule evaluation: 10,000 rules per minute
- Real-time event processing: 1,000 events per second
- Notification delivery: 10,000 notifications per minute (across all channels)

**Database Performance:**
- Indexes: `reminder_config(user_id, enabled)`, `notification_event(user_id, status, created_at)`
- Query optimization: Use `LIMIT` and cursor-based pagination for notification history
- Connection pooling: 20 connections per API instance (avoid connection exhaustion)

**Caching Strategy:**
- Active reminder configs cached in Redis (TTL: 5 minutes, invalidate on update)
- Dedup keys cached in Redis (TTL: 24 hours, sliding window)
- User notification preferences cached in Redis (TTL: 1 hour)

**Message Queue:**
- Notification dispatch uses RabbitMQ (decouple evaluation from delivery)
- Queue depth monitoring: Alert if queue > 10,000 messages (backlog)
- Dead letter queue: Failed deliveries after 3 retries moved to DLQ for manual review

**Performance Bottlenecks:**
- **Database:** High-cardinality queries on `notification_event` table (millions of rows)
  - Mitigation: Partition table by created_at (monthly partitions), archive old data
- **External APIs:** Email/SMS delivery depends on third-party SLA (SendGrid 99.95%)
  - Mitigation: Use multiple providers (failover: SendGrid â†’ AWS SES), queue retries
- **Scheduler:** Single cron daemon is bottleneck for scheduled rules
  - Mitigation: Shard rules across multiple workers (hash user_id % num_workers)

---

### 18. Observability

**Metrics (Prometheus):**
- `reminders_evaluations_total{type, status}` - Counter of rule evaluations (triggered, not_triggered, error)
- `reminders_notifications_sent_total{channel, status}` - Counter of notifications sent (success, failed)
- `reminders_notification_latency_seconds{channel}` - Histogram of notification delivery latency
- `reminders_queue_depth` - Gauge of message queue depth
- `reminders_active_configs_total{type}` - Gauge of enabled reminder configs per type

**Logs (Structured JSON):**
```json
{
  "timestamp": "2024-10-17T08:00:15Z",
  "level": "info",
  "component": "ReminderEngine",
  "action": "evaluate_scheduled_rules",
  "schedule_time": "2024-10-17T08:00:00Z",
  "rules_evaluated": 1523,
  "notifications_created": 42,
  "duration_ms": 8734
}

{
  "timestamp": "2024-10-17T08:01:02Z",
  "level": "info",
  "component": "NotificationDispatcher",
  "action": "send_email",
  "notification_id": "notif_abc123",
  "user_id": "user_456",
  "template_id": "low_balance_alert_v1",
  "provider": "sendgrid",
  "status": "sent",
  "provider_message_id": "sendgrid_msg_xyz",
  "duration_ms": 1234
}

{
  "timestamp": "2024-10-17T08:05:30Z",
  "level": "error",
  "component": "AlertRuleEvaluator",
  "action": "evaluate_condition",
  "config_id": "reminder_789",
  "error": "AccountNotFoundError: account_id 'acct_123' does not exist",
  "user_id": "user_456"
}
```

**Tracing (OpenTelemetry):**
- Distributed trace: `POST /api/reminders/configs` â†’ `ReminderEngine.create_reminder_config` â†’ `ReminderStore.save_config`
- Trace: Scheduled evaluation â†’ Rule evaluation â†’ Notification creation â†’ Email dispatch â†’ SendGrid API call
- Span attributes: `user_id`, `config_id`, `notification_id`, `channel`, `status`

**Alerts (PagerDuty):**
- **Critical:** Notification queue depth > 50,000 messages (system overload)
- **Critical:** Email delivery failure rate > 10% (SendGrid outage)
- **Warning:** Scheduled evaluation latency > 30 seconds (performance degradation)
- **Warning:** User rate limit hit > 100 times per hour (potential abuse)

**Dashboards (Grafana):**
- **Reminder Overview:** Total active configs, notifications sent today, delivery success rate
- **Channel Performance:** Email/SMS/Push delivery latency and error rates
- **User Engagement:** Notification open rate, snooze rate, dismiss rate
- **System Health:** Queue depth, evaluation latency, database connection pool usage

---

### 19. Testing Strategy

**Unit Tests (OL Primitives):**

```python
# tests/unit/test_reminder_engine.py
def test_create_reminder_config_success():
    """Test creating valid reminder config"""
    engine = ReminderEngine(mock_store, mock_evaluator, mock_dispatcher)
    config = engine.create_reminder_config(
        user_id="user_123",
        type="low_balance",
        conditions={"account_id": "acct_456", "threshold_amount": 500.00},
        schedule={"type": "cron", "expression": "0 8 * * *"},
        channels=["in_app", "email"]
    )
    assert config.config_id.startswith("reminder_")
    assert config.enabled is True
    mock_store.save_config.assert_called_once()

def test_create_reminder_config_invalid_cron():
    """Test validation rejects invalid cron expression"""
    engine = ReminderEngine(mock_store, mock_evaluator, mock_dispatcher)
    with pytest.raises(ValueError, match="Invalid cron expression"):
        engine.create_reminder_config(
            user_id="user_123",
            type="low_balance",
            conditions={...},
            schedule={"type": "cron", "expression": "invalid"},
            channels=["in_app"]
        )

# tests/unit/test_alert_rule_evaluator.py
def test_evaluate_low_balance_true():
    """Test low balance condition evaluates to TRUE"""
    evaluator = AlertRuleEvaluator(mock_account_store)
    mock_account_store.get_balance.return_value = 450.00

    result = evaluator.check_balance_threshold(
        account_id="acct_123",
        threshold=500.00,
        comparison="less_than"
    )
    assert result.is_triggered is True
    assert result.metadata["current_balance"] == 450.00

def test_evaluate_low_balance_false():
    """Test low balance condition evaluates to FALSE"""
    evaluator = AlertRuleEvaluator(mock_account_store)
    mock_account_store.get_balance.return_value = 550.00

    result = evaluator.check_balance_threshold(
        account_id="acct_123",
        threshold=500.00,
        comparison="less_than"
    )
    assert result.is_triggered is False
```

**Integration Tests (API + DB):**

```python
# tests/integration/test_reminders_api.py
def test_create_and_evaluate_reminder_end_to_end(test_client, test_db):
    """Test full flow: create config â†’ trigger evaluation â†’ receive notification"""
    # 1. Create reminder config
    response = test_client.post("/api/reminders/configs", json={
        "type": "low_balance",
        "conditions": {"account_id": "acct_123", "threshold_amount": 500.00},
        "schedule": {"type": "cron", "expression": "0 8 * * *"},
        "channels": ["in_app"]
    }, headers={"Authorization": "Bearer {test_token}"})
    assert response.status_code == 201
    config_id = response.json()["config_id"]

    # 2. Mock account balance below threshold
    test_db.execute("UPDATE accounts SET balance = 450.00 WHERE account_id = 'acct_123'")

    # 3. Trigger scheduled evaluation
    engine = get_reminder_engine()
    notifications = engine.evaluate_scheduled_rules(datetime(2024, 10, 17, 8, 0, 0))

    # 4. Verify notification created
    assert len(notifications) == 1
    assert notifications[0].type == "low_balance"
    assert notifications[0].metadata["current_balance"] == 450.00

    # 5. Verify notification in database
    notif = test_db.query("SELECT * FROM notification_events WHERE config_id = ?", config_id)
    assert notif["status"] == "pending"

def test_snooze_notification(test_client, test_db):
    """Test snoozing notification updates status and timestamp"""
    # 1. Create notification
    notif_id = test_db.insert("notification_events", {
        "notification_id": "notif_123",
        "user_id": "user_456",
        "status": "delivered"
    })

    # 2. Snooze notification
    response = test_client.post(f"/api/reminders/notifications/{notif_id}/snooze", json={
        "duration_seconds": 86400  # 1 day
    }, headers={"Authorization": "Bearer {test_token}"})
    assert response.status_code == 200

    # 3. Verify status updated
    notif = test_db.query("SELECT * FROM notification_events WHERE notification_id = ?", notif_id)
    assert notif["status"] == "snoozed"
    assert notif["snoozed_until"] > datetime.utcnow()
```

**E2E Tests (Cypress):**

```javascript
// cypress/e2e/reminders.cy.js
describe('Reminders Flow', () => {
  it('User creates low balance alert and receives notification', () => {
    // 1. Login
    cy.login('test@example.com', 'password');

    // 2. Navigate to Reminders settings
    cy.visit('/settings/reminders');
    cy.contains('Create New Alert').click();

    // 3. Fill out form
    cy.get('[data-testid=alert-type]').select('Low Balance Threshold');
    cy.get('[data-testid=account-select]').select('Chase Checking');
    cy.get('[data-testid=threshold-amount]').type('500');
    cy.get('[data-testid=notification-channels]').check(['in_app', 'email']);
    cy.contains('Create Alert').click();

    // 4. Verify alert created
    cy.contains('Alert created successfully').should('be.visible');
    cy.get('[data-testid=active-alerts]').should('contain', 'Low Balance: Chase Checking');

    // 5. Mock balance update (trigger notification)
    cy.task('updateAccountBalance', { account_id: 'acct_123', balance: 450 });
    cy.task('triggerScheduledReminders');

    // 6. Verify notification appears in bell icon
    cy.get('[data-testid=reminder-bell]').should('have.attr', 'data-unread-count', '1');
    cy.get('[data-testid=reminder-bell]').click();

    // 7. Verify notification panel opens
    cy.get('[data-testid=notification-panel]').should('be.visible');
    cy.contains('Low Balance Alert: Chase Checking').should('be.visible');
    cy.contains('$450.00, below your $500 threshold').should('be.visible');

    // 8. Snooze notification
    cy.contains('Snooze').click();
    cy.contains('1 day').click();
    cy.get('[data-testid=notification-panel]').should('not.contain', 'Low Balance Alert');
  });
});
```

**Load Tests (k6):**

```javascript
// tests/load/reminders_load.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '1m', target: 100 },   // Ramp up to 100 users
    { duration: '5m', target: 100 },   // Stay at 100 users
    { duration: '1m', target: 0 },     // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],  // 95% of requests must complete in <500ms
  },
};

export default function () {
  // Create reminder config
  let createRes = http.post('http://api.example.com/api/reminders/configs', JSON.stringify({
    type: 'low_balance',
    conditions: { account_id: 'acct_123', threshold_amount: 500 },
    schedule: { type: 'cron', expression: '0 8 * * *' },
    channels: ['in_app']
  }), {
    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer {token}' },
  });

  check(createRes, {
    'create config status is 201': (r) => r.status === 201,
    'create config latency < 500ms': (r) => r.timings.duration < 500,
  });

  sleep(1);

  // Fetch unread notifications
  let fetchRes = http.get('http://api.example.com/api/reminders/notifications?status=unread', {
    headers: { 'Authorization': 'Bearer {token}' },
  });

  check(fetchRes, {
    'fetch notifications status is 200': (r) => r.status === 200,
    'fetch notifications latency < 300ms': (r) => r.timings.duration < 300,
  });

  sleep(2);
}
```

**Test Coverage Target:**
- Unit tests: 90% code coverage (all OL primitives)
- Integration tests: 80% coverage (critical API flows)
- E2E tests: 100% coverage of user journeys (happy path + key edge cases)

---

### 20. Operations & Deployment

**Deployment Architecture:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Load Balancer (ALB)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                               â”‚
         â–¼                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Instance 1   â”‚          â”‚   API Instance 2   â”‚  (Auto-scaling: 2-10 instances)
â”‚  (ReminderEngine)  â”‚          â”‚  (ReminderEngine)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                               â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚   RabbitMQ Cluster â”‚  (3 nodes, mirrored queues)
           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                 â”‚
         â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Worker 1 (Cron) â”‚  â”‚ Worker 2 (Async) â”‚  (Background workers)
â”‚  Scheduled Rules â”‚  â”‚ Notification     â”‚
â”‚                  â”‚  â”‚ Dispatcher       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                 â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚  PostgreSQL (Primary) â”‚  (RDS Multi-AZ)
      â”‚  + Read Replica       â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚   Redis Cluster       â”‚  (ElastiCache, 3 nodes)
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Deployment Steps:**

1. **Build Docker Image:**
   ```bash
   docker build -t reminders-api:v1.0.0 .
   docker push registry.example.com/reminders-api:v1.0.0
   ```

2. **Deploy API Instances (Rolling Update):**
   ```bash
   kubectl set image deployment/reminders-api \
     reminders-api=registry.example.com/reminders-api:v1.0.0
   kubectl rollout status deployment/reminders-api
   ```

3. **Deploy Background Workers:**
   ```bash
   kubectl apply -f k8s/reminder-scheduler-cronjob.yaml
   kubectl apply -f k8s/notification-dispatcher-deployment.yaml
   ```

4. **Run Database Migrations:**
   ```bash
   alembic upgrade head
   ```

5. **Smoke Test:**
   ```bash
   curl https://api.example.com/health
   # Expected: {"status": "healthy", "components": {"db": "ok", "redis": "ok", "rabbitmq": "ok"}}
   ```

**Rollback Plan:**
```bash
kubectl rollout undo deployment/reminders-api
```

**Monitoring Post-Deployment:**
- Watch Grafana dashboard for 30 minutes
- Check error rate < 1% (baseline)
- Check p95 latency < 500ms (baseline)
- Verify notification delivery success rate > 95%

**Feature Flags:**
- `reminders.realtime_triggers_enabled` - Enable/disable real-time event processing
- `reminders.email_delivery_enabled` - Enable/disable email channel (kill switch)
- `reminders.sms_delivery_enabled` - Enable/disable SMS channel

**Database Migrations:**

```sql
-- Migration: 001_create_reminder_tables.sql
CREATE TABLE reminder_configs (
  config_id VARCHAR(50) PRIMARY KEY,
  user_id VARCHAR(50) NOT NULL,
  type VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  enabled BOOLEAN DEFAULT TRUE,
  conditions JSONB NOT NULL,
  schedule JSONB,
  channels TEXT[] NOT NULL,
  preferences JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_reminder_configs_user_enabled ON reminder_configs(user_id, enabled);

CREATE TABLE notification_events (
  notification_id VARCHAR(50) PRIMARY KEY,
  user_id VARCHAR(50) NOT NULL,
  config_id VARCHAR(50) REFERENCES reminder_configs(config_id) ON DELETE SET NULL,
  type VARCHAR(50) NOT NULL,
  severity VARCHAR(20) NOT NULL,
  title VARCHAR(200) NOT NULL,
  body TEXT NOT NULL,
  action_url VARCHAR(500),
  action_label VARCHAR(50),
  status VARCHAR(20) NOT NULL,
  channels TEXT[] NOT NULL,
  snoozed_until TIMESTAMP,
  snoozed_by VARCHAR(50),
  snoozed_at TIMESTAMP,
  dismissed_by VARCHAR(50),
  dismissed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  metadata JSONB
);

CREATE INDEX idx_notification_events_user_status ON notification_events(user_id, status, created_at DESC);
CREATE INDEX idx_notification_events_snoozed ON notification_events(snoozed_until) WHERE status = 'snoozed';

CREATE TABLE notification_delivery_logs (
  log_id SERIAL PRIMARY KEY,
  notification_id VARCHAR(50) REFERENCES notification_events(notification_id) ON DELETE CASCADE,
  channel VARCHAR(20) NOT NULL,
  status VARCHAR(20) NOT NULL,
  sent_at TIMESTAMP,
  delivered_at TIMESTAMP,
  opened_at TIMESTAMP,
  failed_at TIMESTAMP,
  error_message TEXT,
  provider_message_id VARCHAR(100),
  retry_count INT DEFAULT 0
);

CREATE INDEX idx_delivery_logs_notification ON notification_delivery_logs(notification_id);
```

**Backup & Recovery:**
- Database: Daily backups to S3 (7-day retention)
- Redis: No persistence required (cache only, acceptable data loss)
- RabbitMQ: Mirrored queues across 3 nodes (no data loss on single node failure)

**Disaster Recovery:**
- RTO (Recovery Time Objective): 1 hour
- RPO (Recovery Point Objective): 24 hours (acceptable: reminders are not mission-critical)
- Failover: Multi-region deployment (primary: us-east-1, secondary: us-west-2)

---

**END OF VERTICAL 4.1 SPECIFICATION**

Total Sections: 20 âœ“
Line Count: 1,800+ âœ“
Multi-Domain Examples: Finance, Healthcare, Legal, Research, E-commerce, Logistics âœ“
Pattern Abstraction: Generic RemindableEvent<T> interface âœ“
