# Vertical 3.3: Series Registry

> **Type:** Closed Registry
> **Pattern:** Recurring Template + Instance Tracking
> **Last Updated:** 2025-10-24

---

## ðŸ“‹ Overview

The **Series Registry** is a **closed registry** where users manually define recurring payment templates (subscriptions, bills, salaries). Each series represents an expected pattern (e.g., "Netflix $15.99 monthly"), and the system tracks actual transaction instances against these expectations.

**Key Characteristics:**
- **Closed Registry:** User explicitly creates series (not auto-generated)
- **Template-Based:** Series defines expected amount, frequency, account
- **Instance Tracking:** Links actual transactions to series instances
- **Variance Detection:** Alerts on missing payments, amount mismatches, schedule drift

**Examples:**
- Finance: Netflix subscription, rent, salary
- Healthcare: Insurance premium, prescription refills
- Legal: Monthly retainer fees
- Research: Recurring grant disbursements

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- User-defined recurring payment series
- CRUD operations (create, edit, archive series)
- Recurrence pattern definition (daily, weekly, monthly, yearly, custom)
- Expected amount and tolerance ranges
- Instance tracking (linking transactions to series)
- Missing payment detection
- Amount variance alerts
- Schedule drift tracking

**Out of Scope:**
- Auto-detection of recurring patterns (deferred to 3.8 Cluster Rules)
- Budget forecasting (covered in 4.2 Forecast)
- Payment reminders (covered in 4.1 Reminders)
- Multi-series dependencies (e.g., "if X paid, then Y expected")

**Boundaries:**
- Series are user-scoped (each user has their own series list)
- Series are single-account (each series tied to one account)
- Series instances are single-transaction (1:1 mapping series â†” transaction)
- Cross-currency series supported (expected in USD, actual in MXN triggers conversion)

---

### 2. User Flow (Real Usage)

**Scenario 1: User creates monthly subscription series**

User: "I want to track my OpenAI subscription - $20/month on the 5th"

System:
1. User opens Series Manager
2. Clicks "New Series" button
3. Fills form:
   - Name: "OpenAI ChatGPT Plus"
   - Account: Chase Credit Card
   - Counterparty: OpenAI (from 3.2 registry)
   - Expected Amount: $20.00
   - Tolerance: Â±$2.00 (allow $18-$22)
   - Frequency: Monthly on day 5
   - Start Date: 2024-01-05
   - Category: Software & SaaS
4. Clicks "Create"
5. System validates (unique name, valid frequency)
6. System saves series with ID `series_openai_chatgpt_1`
7. System calculates next 12 expected instances
8. User sees series card with "Next Expected: Feb 5, 2024 ($20.00)"

**Scenario 2: User views series dashboard with variance alerts**

User: "Show me all my recurring payments and which ones are late"

System:
1. User opens Series Manager
2. Displays list of active series grouped by category
3. For each series, shows:
   - Series name and icon
   - Last payment date and amount (actual)
   - Next expected date and amount
   - Status badge:
     - âœ… "Paid on time" (matched within tolerance)
     - âš ï¸ "Amount variance" (paid but amount off)
     - ðŸ”´ "Missing" (expected date passed, no match)
     - ðŸ“… "Upcoming" (within 7 days)
4. User clicks on series "Netflix" with ðŸ”´ "Missing" badge
5. System shows expected vs actual:
   - Expected: Nov 15, 2024 ($15.99)
   - Actual: No transaction found
   - Actions: [Mark as Skipped] [Link Transaction] [Edit Series]

**Scenario 3: System auto-links transaction to series instance**

Background process (runs after normalization):
1. New transaction normalized:
   - Date: 2024-02-05
   - Counterparty: OpenAI
   - Account: Chase Credit Card
   - Amount: -$20.00
2. InstanceTracker searches for matching series:
   - Counterparty = "OpenAI"
   - Account = "Chase Credit Card"
   - Amount within tolerance ($18-$22)
   - Date within Â±3 days of expected (Feb 5)
3. Finds series `series_openai_chatgpt_1`
4. Creates instance link:
   ```json
   {
     "instance_id": "instance_series_openai_chatgpt_1_202402",
     "series_id": "series_openai_chatgpt_1",
     "transaction_id": "txn_12345",
     "expected_date": "2024-02-05",
     "actual_date": "2024-02-05",
     "expected_amount": -20.00,
     "actual_amount": -20.00,
     "status": "matched",
     "variance": 0.00
   }
   ```
5. User sees series updated with âœ… "Paid on time"

**Scenario 4: User manually links transaction to series**

User: "This transaction is my rent, but the system didn't auto-link it"

System:
1. User views transaction in Transaction List (2.1)
2. Clicks "Link to Series" button in transaction detail
3. SeriesSelector dropdown appears with active series
4. User selects "Rent - Monthly"
5. System validates:
   - Amount within tolerance? Â±$50 allowed, transaction is -$1200, expected -$1250 â†’ âœ…
   - Account matches? Yes â†’ âœ…
6. Creates instance link with status "matched_manual"
7. Transaction now shows series badge "Rent - Monthly"
8. Series shows instance as paid

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `SeriesStore` - CRUD operations for series (NEW - this vertical)
- `RecurrenceEngine` - Calculates next expected date based on frequency rules (NEW - this vertical)
- `InstanceTracker` - Links transactions to series instances, detects variances (NEW - this vertical)
- `TransactionQuery` - Query transactions for matching (from 2.1)
- `CounterpartyStore` - Reference counterparties (from 3.2)
- `AccountStore` - Reference accounts (from 3.1)

**Interaction Layer (IL):**
- `SeriesManager` - Full CRUD UI for managing series (NEW - this vertical)
- `SeriesSelector` - Dropdown for selecting series to link (NEW - this vertical)
- `RecurrenceConfigDialog` - Dialog for configuring recurrence patterns (NEW - this vertical)
- `TransactionList` - View transactions with series badges (from 2.1)

**Schemas:**
- `series.schema.json` - Series definition (NEW - this vertical)
- `series-instance.schema.json` - Instance tracking (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# Create Series
POST /api/series
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "OpenAI ChatGPT Plus",
  "account_id": "acc_chase_credit_1",
  "counterparty_id": "cpty_openai_1",
  "expected_amount": -20.00,
  "tolerance": 2.00,
  "frequency": {
    "type": "monthly",
    "day_of_month": 5
  },
  "start_date": "2024-01-05",
  "category": "software_saas"
}

Response 201:
{
  "series_id": "series_openai_chatgpt_1",
  "name": "OpenAI ChatGPT Plus",
  "account_id": "acc_chase_credit_1",
  "counterparty_id": "cpty_openai_1",
  "expected_amount": -20.00,
  "tolerance": 2.00,
  "frequency": {
    "type": "monthly",
    "day_of_month": 5
  },
  "start_date": "2024-01-05",
  "end_date": null,
  "category": "software_saas",
  "is_active": true,
  "next_expected_date": "2024-02-05",
  "created_at": "2024-01-03T10:00:00Z",
  "updated_at": "2024-01-03T10:00:00Z"
}

Response 400:
{
  "error": "DUPLICATE_SERIES_NAME",
  "message": "Series with name 'OpenAI ChatGPT Plus' already exists"
}
```

```http
# List Series
GET /api/series?is_active=true&account_id=acc_chase_credit_1
Authorization: Bearer {token}

Response 200:
{
  "series": [
    {
      "series_id": "series_openai_chatgpt_1",
      "name": "OpenAI ChatGPT Plus",
      "expected_amount": -20.00,
      "frequency": {"type": "monthly", "day_of_month": 5},
      "next_expected_date": "2024-02-05",
      "last_instance": {
        "instance_id": "instance_series_openai_chatgpt_1_202401",
        "actual_date": "2024-01-05",
        "status": "matched"
      }
    }
  ],
  "total": 1
}
```

```http
# Get Series with Instances
GET /api/series/{series_id}/instances?limit=12
Authorization: Bearer {token}

Response 200:
{
  "series": {...},
  "instances": [
    {
      "instance_id": "instance_series_openai_chatgpt_1_202402",
      "expected_date": "2024-02-05",
      "actual_date": "2024-02-05",
      "expected_amount": -20.00,
      "actual_amount": -20.00,
      "status": "matched",
      "variance": 0.00,
      "transaction_id": "txn_12345"
    },
    {
      "instance_id": "instance_series_openai_chatgpt_1_202401",
      "expected_date": "2024-01-05",
      "actual_date": null,
      "status": "missing",
      "variance": null,
      "transaction_id": null
    }
  ]
}
```

```http
# Link Transaction to Series (Manual)
POST /api/series/{series_id}/link
Authorization: Bearer {token}
Content-Type: application/json

{
  "transaction_id": "txn_67890",
  "force": false  // If true, override tolerance checks
}

Response 201:
{
  "instance_id": "instance_series_rent_monthly_202402",
  "series_id": "series_rent_monthly_1",
  "transaction_id": "txn_67890",
  "status": "matched_manual",
  "variance": -50.00
}

Response 400:
{
  "error": "AMOUNT_OUT_OF_TOLERANCE",
  "message": "Transaction amount -$1300 exceeds tolerance range ($1200 Â± $50)",
  "details": {
    "expected": -1200.00,
    "actual": -1300.00,
    "tolerance": 50.00,
    "variance": -100.00
  }
}
```

**Internal OL API:**

```python
class SeriesStore:
    def create(self, user_id: str, name: str, account_id: str,
               counterparty_id: str, expected_amount: Decimal,
               tolerance: Decimal, frequency: FrequencyPattern,
               start_date: date, category: Optional[str] = None) -> Series:
        """
        Creates a new series.

        Raises:
            DuplicateSeriesNameError: If name already exists for user (case-insensitive)
            InvalidAccountError: If account_id doesn't exist or not owned by user
            InvalidCounterpartyError: If counterparty_id doesn't exist or not owned by user
            InvalidFrequencyError: If frequency pattern is malformed
        """

    def get(self, user_id: str, series_id: str) -> Optional[Series]:
        """Returns series if exists and owned by user."""

    def list(self, user_id: str, is_active: bool = True,
             account_id: Optional[str] = None) -> List[Series]:
        """Returns list of series for user, optionally filtered."""

    def update(self, user_id: str, series_id: str, **updates) -> Series:
        """
        Updates series fields. Immutable: account_id, counterparty_id.

        Raises:
            ImmutableFieldError: If trying to change account or counterparty
        """

    def archive(self, user_id: str, series_id: str, end_date: date) -> Series:
        """Soft deletes series by setting is_active=false and end_date."""

class RecurrenceEngine:
    def calculate_next_expected(self, frequency: FrequencyPattern,
                                  last_date: date) -> date:
        """
        Calculates next expected date based on frequency pattern.

        Supports:
        - daily: {type: "daily", interval: 1}
        - weekly: {type: "weekly", day_of_week: 1, interval: 1}  // 0=Mon
        - monthly: {type: "monthly", day_of_month: 5, interval: 1}
        - yearly: {type: "yearly", month: 1, day: 15}
        - custom: {type: "custom", dates: ["2024-01-15", "2024-07-15"]}
        """

    def generate_expected_instances(self, series: Series,
                                     months_ahead: int = 12) -> List[ExpectedInstance]:
        """Generates future expected instances for a series."""

class InstanceTracker:
    def auto_link(self, transaction: Transaction) -> Optional[SeriesInstance]:
        """
        Attempts to auto-link transaction to a series instance.

        Matching criteria:
        1. Account matches series.account_id
        2. Counterparty matches series.counterparty_id (exact or alias)
        3. Amount within tolerance: |txn.amount - series.expected_amount| <= tolerance
        4. Date within window: |txn.date - expected_date| <= 3 days
        5. No existing instance for this expected_date (prevent duplicates)

        Returns:
            SeriesInstance if match found and linked, None otherwise
        """

    def manual_link(self, user_id: str, series_id: str,
                     transaction_id: str, force: bool = False) -> SeriesInstance:
        """
        Manually links transaction to series.

        Raises:
            AmountOutOfToleranceError: If amount exceeds tolerance (unless force=True)
            AccountMismatchError: If transaction account != series account
            TransactionAlreadyLinkedError: If transaction already linked to another series
        """

    def unlink(self, user_id: str, instance_id: str) -> None:
        """Removes instance link, transaction remains but instance deleted."""

    def get_missing_instances(self, user_id: str,
                               as_of_date: date = today) -> List[ExpectedInstance]:
        """Returns all expected instances with expected_date <= as_of_date and no match."""
```

---

### 5. Schemas / Tipos (Persistencia)

**Series Schema:**

```json
{
  "series_id": "series_{slug}_{seq}",
  "user_id": "uuid",
  "name": "OpenAI ChatGPT Plus",
  "account_id": "acc_chase_credit_1",
  "counterparty_id": "cpty_openai_1",
  "expected_amount": -20.00,
  "tolerance": 2.00,
  "frequency": {
    "type": "monthly",
    "day_of_month": 5,
    "interval": 1
  },
  "start_date": "2024-01-05",
  "end_date": null,
  "category": "software_saas",
  "is_active": true,
  "next_expected_date": "2024-02-05",
  "created_at": "2024-01-03T10:00:00Z",
  "updated_at": "2024-01-03T10:00:00Z"
}
```

**SeriesInstance Schema:**

```json
{
  "instance_id": "instance_{series_id}_{YYYYMM}",
  "series_id": "series_openai_chatgpt_1",
  "user_id": "uuid",
  "transaction_id": "txn_12345",
  "expected_date": "2024-02-05",
  "actual_date": "2024-02-05",
  "expected_amount": -20.00,
  "actual_amount": -20.00,
  "status": "matched",
  "variance": 0.00,
  "link_type": "auto",
  "created_at": "2024-02-06T08:00:00Z"
}
```

**Frequency Pattern Types:**

```typescript
type FrequencyPattern =
  | { type: "daily"; interval: number }  // Every N days
  | { type: "weekly"; day_of_week: 0-6; interval: number }  // Every N weeks on day
  | { type: "monthly"; day_of_month: 1-31; interval: number }  // Every N months on day
  | { type: "yearly"; month: 1-12; day: 1-31 }  // Yearly on specific date
  | { type: "custom"; dates: string[] };  // Explicit list of dates

type InstanceStatus =
  | "matched"           // Auto-linked, within tolerance
  | "matched_manual"    // Manually linked
  | "variance"          // Matched but amount outside tolerance
  | "missing"           // Expected date passed, no match
  | "upcoming"          // Expected in future
  | "skipped";          // User marked as intentionally skipped
```

---

### 6. Validaciones & Estados

**Create Validations:**
- Name: 1-100 chars, pattern `^[A-Za-z0-9\s\-'()]+$`
- Name uniqueness: Case-insensitive per user
- Account: Must exist and be owned by user, is_active=true
- Counterparty: Must exist and be owned by user
- Expected amount: Non-zero, up to 2 decimal places
- Tolerance: >= 0, up to 2 decimal places
- Frequency: Valid pattern (see schema)
- Start date: Cannot be in the future (max today)

**Update Validations:**
- Immutable fields: account_id, counterparty_id (would break instance links)
- Can update: name (if unique), expected_amount, tolerance, frequency, category
- Cannot reactivate if end_date is set

**Auto-Link Criteria:**
1. Account match: `transaction.account_id == series.account_id`
2. Counterparty match: `transaction.counterparty_id == series.counterparty_id` OR counterparty alias match
3. Amount tolerance: `abs(transaction.amount - series.expected_amount) <= series.tolerance`
4. Date window: `abs(transaction.date - expected_date) <= 3 days`
5. No duplicate: No existing instance for this expected_date + series

**State Machine (Series):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ active  â”‚â”€â”€archiveâ”€â”€â–¶â”‚ archived â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â”‚                           â”‚
  â””â”€â”€â”€â”€â”€â”€unarchive (if no end_date)â”€â”€â”˜
```

**State Machine (Instance):**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ upcoming â”‚â”€â”€transaction arrivesâ”€â”€â–¶â”‚ matched â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                    â”‚
     â”‚                              amount out of tolerance
     â”‚                                    â”‚
     â””â”€â”€expected_date passesâ”€â”€â–¶â”‚ missing â”‚â”€â”€manual linkâ”€â”€â–¶â”‚ matched_manual â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚
                                user marks
                                     â”‚
                                     â–¼
                                â”‚ skipped â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 7. Edge Cases

**EC1: Last day of month for monthly series**
- Series: "Rent - Monthly" on day 31
- Problem: February only has 28/29 days
- **Solution:** RecurrenceEngine uses "last day of month" logic if day_of_month > actual days in month
- Example: Jan 31 â†’ Feb 28 â†’ Mar 31 â†’ Apr 30 â†’ May 31

**EC2: Multiple transactions match same expected instance**
- Series: "Netflix $15.99" expected on Feb 15
- Transactions:
  - Feb 14: Netflix -$15.99 (pending)
  - Feb 16: Netflix -$15.99 (posted)
- **Solution:** InstanceTracker links to first chronologically (Feb 14), ignores duplicate
- User can manually unlink and relink if incorrect

**EC3: Amount variance outside tolerance**
- Series: "Rent $1200 Â± $50"
- Transaction: -$1300 (landlord raised rent)
- **Solution:**
  - Auto-link fails (outside tolerance)
  - User gets alert "Amount variance detected"
  - User can: (1) Update series expected_amount, (2) Force link with variance, (3) Ignore
  - If force linked, status = "variance", variance = -100.00

**EC4: User creates series after transactions already exist**
- User has 12 months of Netflix transactions (Jan-Dec 2024)
- User creates series on Dec 31, 2024
- **Solution:**
  - System only auto-links future transactions (after series creation)
  - User can manually link past transactions via "Link to Series" button in Transaction List
  - InstanceTracker.backfill() method (optional) can scan past transactions

**EC5: Series archived mid-year**
- Series: "Gym Membership" created Jan 1, archived Jun 30
- **Solution:**
  - end_date = 2024-06-30
  - is_active = false
  - RecurrenceEngine stops generating expected instances after end_date
  - Existing instances (Jan-Jun) remain linked

**EC6: Counterparty merged after series creation**
- Series: "Uber Eats" linked to counterparty `cpty_uber_eats_1`
- User merges `cpty_uber_eats_1` into `cpty_uber_1`
- **Solution:**
  - Series.counterparty_id remains `cpty_uber_eats_1` (now merged_into=`cpty_uber_1`)
  - CounterpartyMatcher searches both canonical and merged counterparties
  - Auto-link still works via alias matching

**EC7: Zero-amount series (informational tracking)**
- Series: "Paycheck (Direct Deposit)" - user wants to track but amount varies
- **Solution:**
  - Allow expected_amount = 0, tolerance = 9999999 (infinite)
  - Auto-link based only on counterparty + account + date
  - status = "matched" regardless of amount
  - Use case: Track that paycheck arrived, not amount

---

### 8. Acceptance Criteria (Definition of Done)

**CRUD Operations:**
- [ ] User can create series with all required fields
- [ ] System enforces unique name per user (case-insensitive)
- [ ] User can edit series (name, amount, tolerance, frequency, category)
- [ ] System prevents editing immutable fields (account, counterparty)
- [ ] User can archive series (sets is_active=false, end_date=today)
- [ ] User can unarchive series (if no end_date set)
- [ ] System validates all fields on create/update

**Recurrence Engine:**
- [ ] RecurrenceEngine calculates next expected date for all frequency types (daily, weekly, monthly, yearly, custom)
- [ ] Monthly recurrence handles last-day-of-month correctly (day 31 â†’ Feb 28)
- [ ] System generates 12 months of expected instances on series creation
- [ ] System updates next_expected_date after each instance match

**Instance Tracking:**
- [ ] InstanceTracker auto-links transactions within tolerance (account + counterparty + amount + date)
- [ ] System creates instance with status="matched" on successful auto-link
- [ ] System sets status="missing" for expected instances past due with no match
- [ ] User can manually link transaction to series via UI
- [ ] User can unlink instance (deletes instance, keeps transaction)
- [ ] System prevents linking same transaction to multiple series
- [ ] System detects amount variance (outside tolerance) and alerts user

**UI:**
- [ ] SeriesManager displays list of active series with status badges
- [ ] User can filter series by account, category, status
- [ ] User can search series by name
- [ ] User can view series detail with instance history (last 12 months)
- [ ] User sees variance alerts (missing, amount off, schedule drift)
- [ ] RecurrenceConfigDialog provides UI for all frequency types
- [ ] SeriesSelector dropdown available in Transaction Detail

**Multi-Domain:**
- [ ] Pattern works for finance (subscriptions, rent, salary)
- [ ] Pattern works for healthcare (insurance, prescriptions)
- [ ] Pattern works for legal (retainers)
- [ ] Pattern works for research (grants)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "series_created",
  "series_id": "series_openai_chatgpt_1",
  "user_id": "uuid",
  "name": "OpenAI ChatGPT Plus",
  "account_id": "acc_chase_credit_1",
  "counterparty_id": "cpty_openai_1",
  "expected_amount": -20.00,
  "frequency": {"type": "monthly", "day_of_month": 5},
  "timestamp": "2024-01-03T10:00:00Z"
}
```

```json
{
  "event": "instance_auto_linked",
  "instance_id": "instance_series_openai_chatgpt_1_202402",
  "series_id": "series_openai_chatgpt_1",
  "transaction_id": "txn_12345",
  "expected_date": "2024-02-05",
  "actual_date": "2024-02-05",
  "variance": 0.00,
  "match_criteria": {
    "account_match": true,
    "counterparty_match": true,
    "amount_match": true,
    "date_match": true
  },
  "timestamp": "2024-02-06T08:00:00Z"
}
```

```json
{
  "event": "instance_missing_detected",
  "series_id": "series_netflix_1",
  "expected_date": "2024-11-15",
  "expected_amount": -15.99,
  "days_overdue": 3,
  "timestamp": "2024-11-18T00:00:00Z"
}
```

**Provenance Chain:**
```
Series Created (user action)
  â†“
Expected Instances Generated (RecurrenceEngine)
  â†“
Transaction Normalized (from 1.3)
  â†“
Instance Auto-Linked (InstanceTracker)
  â†“
Series Status Updated (next_expected_date)
```

---

### 10. Risks & Deferred

**Risks:**
- **R1: Frequency edge cases** - Complex recurrence patterns (e.g., "last Friday of month") not supported initially
  - **Mitigation:** Start with simple patterns (daily, weekly, monthly, yearly), add custom patterns later
- **R2: Timezone handling** - Series expected_date is date-only, but transactions have timestamps
  - **Mitigation:** Use user's timezone for date extraction from transaction timestamp
- **R3: Currency mismatch** - Series in USD, transaction in MXN
  - **Mitigation:** Normalize transaction amount to series currency using exchange rate (from 3.6 Unit)

**Deferred:**
- **D1: Auto-detection of recurring patterns** - Moved to 3.8 Cluster Rules
- **D2: Forecast based on series** - Moved to 4.2 Forecast
- **D3: Reminders for missing payments** - Moved to 4.1 Reminders
- **D4: Multi-series dependencies** - Not in initial scope

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 3 new primitives:**

1. **SeriesStore** - CRUD operations for series registry
   - File: `docs/primitives/ol/SeriesStore.md`
   - Methods: create, get, list, update, archive, unarchive
   - Responsibilities: Persistence, uniqueness validation, immutable field enforcement

2. **RecurrenceEngine** - Calculates next expected dates based on frequency patterns
   - File: `docs/primitives/ol/RecurrenceEngine.md`
   - Methods: calculate_next_expected, generate_expected_instances, handle_last_day_of_month
   - Responsibilities: Date math, frequency pattern interpretation, edge case handling

3. **InstanceTracker** - Links transactions to series instances, detects variances
   - File: `docs/primitives/ol/InstanceTracker.md`
   - Methods: auto_link, manual_link, unlink, get_missing_instances, detect_variance
   - Responsibilities: Matching logic, tolerance checking, status management

**Interaction Layer (IL) - 3 new components:**

4. **SeriesManager** - Full CRUD UI for managing series
   - File: `docs/primitives/il/SeriesManager.md`
   - Features: List view, create/edit modals, archive confirmation, status badges, variance alerts
   - Responsibilities: Display series, user interactions, filtering/search

5. **SeriesSelector** - Dropdown for selecting series to link
   - File: `docs/primitives/il/SeriesSelector.md`
   - Features: Search, group by category, show next expected date, "Create new series" inline
   - Responsibilities: Series selection, quick create

6. **RecurrenceConfigDialog** - Dialog for configuring recurrence patterns
   - File: `docs/primitives/il/RecurrenceConfigDialog.md`
   - Features: Frequency type selector, day/date pickers, preview next 3 occurrences
   - Responsibilities: Frequency pattern UI, validation

**Schemas - 2 new:**

7. **series.schema.json** - Series definition
8. **series-instance.schema.json** - Instance tracking record

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **3.1 Account Registry** - Series references account_id
- **3.2 Counterparty Registry** - Series references counterparty_id for matching
- **2.1 Transaction List** - InstanceTracker links to transactions
- **1.3 Normalization** - Auto-link runs after transaction normalization

**Used By:**
- **4.1 Reminders** - Uses SeriesInstance.status="missing" to trigger alerts
- **4.2 Forecast** - Uses Series expected_amount + frequency for projections
- **2.3 Finance Dashboard** - Can display series status widget

**Data Flow:**
```
Transaction Normalized (1.3)
  â†“
InstanceTracker.auto_link() (3.3)
  â†“
Check Account (3.1)
  â†“
Check Counterparty (3.2)
  â†“
Check Amount/Date Tolerance
  â†“
Create SeriesInstance or Mark Missing
  â†“
Update Series.next_expected_date
  â†“
Trigger Reminder if Missing (4.1)
```

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Recurring Template + Instance Tracking**

This pattern applies to **any domain with expected recurring events**:

**Finance:**
- Series: Subscriptions (Netflix, Spotify), Bills (Rent, Utilities), Income (Salary, Dividends)
- Instance: Each monthly payment
- Variance: Amount changed, payment missed, date drifted

**Healthcare:**
- Series: Insurance premiums, prescription refills, therapy sessions
- Instance: Each monthly premium payment, each prescription pickup
- Variance: Premium increased, refill missed, appointment rescheduled

**Legal:**
- Series: Monthly retainers, court filing deadlines (if recurring), lease payments
- Instance: Each retainer payment
- Variance: Retainer adjusted, payment late

**Research:**
- Series: Grant disbursements (quarterly), lab equipment maintenance (annual), journal subscriptions
- Instance: Each disbursement, each maintenance
- Variance: Disbursement delayed, maintenance skipped

**Manufacturing:**
- Series: Equipment maintenance schedules, supplier invoices (if recurring), lease payments
- Instance: Each maintenance event, each invoice
- Variance: Maintenance overdue, invoice amount changed

**Media/Publishing:**
- Series: Licensing fees (annual), hosting fees (monthly), API subscription costs
- Instance: Each monthly charge
- Variance: API overage fees, hosting plan changed

**Key Abstraction:**
```python
class RecurringTemplate:
    """
    Universal pattern for tracking expected recurring events.

    Generic enough to apply across:
    - Finance: payments, income
    - Healthcare: appointments, prescriptions
    - Legal: deadlines, retainers
    - Research: grants, subscriptions
    """
    template_id: str
    name: str
    entity_id: str  # account, provider, court, lab, etc.
    expected_value: Any  # amount, date, quantity
    tolerance: Any
    frequency: RecurrencePattern

class RecurringInstance:
    """Tracks expected vs actual for a single occurrence."""
    instance_id: str
    template_id: str
    event_id: str  # transaction, appointment, filing, disbursement
    expected: Any
    actual: Any
    status: InstanceStatus
    variance: Any
```

---

### 14. Pattern Abstraction

**Pattern Name:** Recurring Template + Instance Tracking

**Problem Statement:**
Users need to track whether expected recurring events (payments, appointments, deadlines) actually occurred, and detect variances (missing, amount changed, schedule drifted).

**Solution Architecture:**

1. **Template Layer** - User defines expected pattern
   - What: Expected amount, counterparty, account
   - When: Frequency pattern (daily, weekly, monthly, yearly, custom)
   - Tolerance: Acceptable variance (Â±$50, Â±3 days)

2. **Instance Layer** - System tracks actual occurrences
   - Expected vs Actual comparison
   - Status: matched, missing, variance, upcoming
   - Link to actual event (transaction, appointment, etc.)

3. **Matching Engine** - Auto-links actuals to expected
   - Multi-criteria matching (entity + value + date)
   - Tolerance checking
   - Duplicate prevention

4. **Variance Detection** - Alerts user to anomalies
   - Missing: Expected date passed, no match
   - Amount: Matched but outside tolerance
   - Schedule: Date drift over time

**Components:**
- **Store** - Persists templates
- **Recurrence Engine** - Calculates expected dates
- **Instance Tracker** - Links actuals, detects variances
- **Manager UI** - CRUD for templates
- **Selector UI** - Choose template to link

**When to Use:**
- âœ… Events expected to recur on a schedule
- âœ… Need to detect missing or variance
- âœ… User manages template definitions
- âŒ Events are irregular (use one-time tracking)
- âŒ Auto-detection needed (use clustering first, then templates)

---

### 15. MÃ©tricas de Madurez

**Coverage Metrics:**
- % of recurring transactions linked to series (target: >80%)
- % of series with at least 1 instance match (target: >90%)
- % of missing instances resolved within 7 days (target: >70%)

**Quality Metrics:**
- Auto-link success rate (target: >85%)
- Manual link rate (lower is better, target: <15%)
- Variance detection accuracy (target: >95%)

**Performance Metrics:**
- Time to auto-link after normalization (target: <5s p95)
- Series list load time (target: <200ms p95)
- Instance history load time for 12 months (target: <300ms p95)

**User Engagement:**
- % users with at least 1 active series (target: >60%)
- Average series per active user (target: 5-10)
- % users who act on missing instance alerts (target: >40%)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All series operations require valid bearer token
- Series are user-scoped (user_id foreign key)
- Users can only view/edit/delete their own series
- Instance links enforce transaction ownership (user owns transaction)

**Input Validation:**
- Name: Pattern validation, length limits (prevent XSS)
- Expected amount: Range validation (-999999.99 to 999999.99)
- Tolerance: Must be >= 0
- Frequency: Schema validation (reject malformed patterns)
- Date: ISO 8601 format, range validation (1900-2100)

**SQL Injection Prevention:**
- Use parameterized queries for all database operations
- Example: `SELECT * FROM series WHERE user_id = ? AND name = ?`

**Trust Construction Elements:**
- **Ownership verification:** All operations check user_id match
- **Immutable fields:** Cannot change account/counterparty after creation (preserves instance integrity)
- **Audit trail:** All create/update/delete operations logged with user_id + timestamp
- **Force flag validation:** Manual links with force=true logged separately (prevent abuse)
- **Duplicate prevention:** Instance linking checks for existing links (prevent double-counting)

**Data Privacy:**
- Series names may contain PII (e.g., "Rent - 123 Main St")
- Do not log series names in external systems
- Redact sensitive data in error messages

**Rate Limiting:**
- Create series: 10 per minute per user
- Auto-link: No limit (background process)
- Manual link: 60 per minute per user

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `POST /api/series` (create): <300ms
- `GET /api/series` (list): <200ms
- `GET /api/series/{id}/instances` (12 months): <300ms
- `POST /api/series/{id}/link` (manual): <200ms
- `InstanceTracker.auto_link()` (background): <5s per transaction

**Scalability:**
- Series per user: 100 (typical), 500 (max recommended)
- Instances per series: 365 (1 year daily), unbounded (system retains all history)
- Auto-link batch size: 100 transactions per batch

**Database Indexes:**
```sql
-- Series lookups
CREATE INDEX idx_series_user_id ON series(user_id, is_active);
CREATE INDEX idx_series_name ON series(user_id, LOWER(name));
CREATE INDEX idx_series_account ON series(account_id);

-- Instance lookups
CREATE INDEX idx_instance_series_id ON series_instances(series_id, expected_date DESC);
CREATE INDEX idx_instance_transaction ON series_instances(transaction_id);
CREATE INDEX idx_instance_status ON series_instances(user_id, status, expected_date);
```

**Caching Strategy:**
- Cache user's active series list (TTL: 5 minutes)
- Invalidate on create/update/archive
- Cache recurrence calculations for common patterns

**Background Jobs:**
- **Daily:** Generate next month of expected instances for all active series
- **Hourly:** Detect missing instances (expected_date < now, status=upcoming â†’ missing)
- **Per-transaction:** Auto-link after normalization (via event queue)

---

### 18. Observability

**Metrics:**
```
series.created.count (counter, labels: user_id)
series.archived.count (counter, labels: user_id)
instance.auto_linked.count (counter, labels: series_id, status)
instance.manual_linked.count (counter, labels: series_id)
instance.missing.count (gauge, labels: user_id, series_id)
auto_link.latency (histogram, labels: status)
auto_link.success_rate (gauge)
```

**Structured Logs:**
- All series CRUD operations
- All instance link/unlink operations
- Auto-link matching decisions (criteria met/failed)
- Missing instance detections
- Variance alerts

**Dashboards:**
- Series creation rate (trend over time)
- Auto-link success rate (target: >85%)
- Missing instance count per user (alert if spike)
- Manual link rate (should be low)
- Top series by instance count

**Alerts:**
- Auto-link success rate drops below 80% (investigate matching logic)
- Missing instance count spike (investigate data quality)
- Manual link rate above 20% (users struggling with auto-link)
- Series creation errors >5% (investigate validation issues)

**Tracing:**
- Trace auto-link flow: normalization â†’ matching â†’ instance creation
- Include transaction_id, series_id, match_criteria, decision in trace

---

### 19. Testing Strategy

**Unit Tests:**

```python
# SeriesStore tests
def test_create_series_success():
    series = store.create(user_id, "Netflix", account_id, counterparty_id, -15.99, 2.0, monthly_pattern, start_date)
    assert series.series_id.startswith("series_")
    assert series.name == "Netflix"

def test_create_series_duplicate_name():
    store.create(user_id, "Netflix", ...)
    with pytest.raises(DuplicateSeriesNameError):
        store.create(user_id, "netflix", ...)  # Case-insensitive

def test_update_immutable_field():
    series = store.create(...)
    with pytest.raises(ImmutableFieldError):
        store.update(user_id, series.series_id, account_id="different_account")

# RecurrenceEngine tests
def test_monthly_last_day():
    pattern = {"type": "monthly", "day_of_month": 31}
    assert engine.calculate_next_expected(pattern, date(2024,1,31)) == date(2024,2,29)  # Leap year
    assert engine.calculate_next_expected(pattern, date(2024,2,29)) == date(2024,3,31)

def test_weekly_pattern():
    pattern = {"type": "weekly", "day_of_week": 1, "interval": 2}  # Every 2 weeks on Tuesday
    assert engine.calculate_next_expected(pattern, date(2024,1,2)) == date(2024,1,16)  # 2 weeks later

# InstanceTracker tests
def test_auto_link_success():
    series = create_series(expected_amount=-20.00, tolerance=2.0)
    transaction = create_transaction(amount=-20.00, date=expected_date)
    instance = tracker.auto_link(transaction)
    assert instance.status == "matched"
    assert instance.variance == 0.00

def test_auto_link_amount_out_of_tolerance():
    series = create_series(expected_amount=-20.00, tolerance=2.0)
    transaction = create_transaction(amount=-25.00)  # Outside tolerance
    instance = tracker.auto_link(transaction)
    assert instance is None  # No auto-link

def test_manual_link_force():
    series = create_series(expected_amount=-20.00, tolerance=2.0)
    transaction = create_transaction(amount=-30.00)  # Way outside
    instance = tracker.manual_link(user_id, series.series_id, transaction.transaction_id, force=True)
    assert instance.status == "variance"
    assert instance.variance == -10.00
```

**Integration Tests:**

```python
def test_end_to_end_series_creation_and_auto_link():
    # 1. Create series
    response = client.post("/api/series", json={...})
    assert response.status_code == 201
    series_id = response.json()["series_id"]

    # 2. Upload and normalize transaction
    upload_transaction(counterparty="OpenAI", amount=-20.00, date=expected_date)

    # 3. Wait for auto-link (background job)
    time.sleep(2)

    # 4. Verify instance created
    response = client.get(f"/api/series/{series_id}/instances")
    instances = response.json()["instances"]
    assert len(instances) == 1
    assert instances[0]["status"] == "matched"

def test_missing_instance_detection():
    # 1. Create series with expected_date in past
    series = create_series(start_date=date.today() - timedelta(days=10))

    # 2. Run missing instance detection job
    detect_missing_instances()

    # 3. Verify instance status = missing
    instances = get_instances(series.series_id)
    assert instances[0]["status"] == "missing"
```

**Multi-Domain Tests:**
- Finance: Create subscription series, link Netflix transaction
- Healthcare: Create insurance premium series, link Cigna transaction
- Legal: Create retainer series, link law firm transaction
- Research: Create grant series, link NSF disbursement transaction

**Edge Case Tests:**
- Last day of month (Jan 31 â†’ Feb 28)
- Multiple transactions match same expected instance
- Amount variance outside tolerance
- Series created after transactions exist (backfill)
- Counterparty merged after series creation

---

### 20. Operations Runbook

**Deployment:**

1. **Database Migrations:**
```sql
-- Create series table
CREATE TABLE series (
    series_id VARCHAR(100) PRIMARY KEY,
    user_id UUID NOT NULL,
    name VARCHAR(100) NOT NULL,
    account_id VARCHAR(100) NOT NULL,
    counterparty_id VARCHAR(100) NOT NULL,
    expected_amount DECIMAL(12,2) NOT NULL,
    tolerance DECIMAL(12,2) NOT NULL,
    frequency JSONB NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE,
    category VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    next_expected_date DATE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(user_id, LOWER(name)),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (account_id) REFERENCES accounts(account_id),
    FOREIGN KEY (counterparty_id) REFERENCES counterparties(counterparty_id)
);

-- Create series_instances table
CREATE TABLE series_instances (
    instance_id VARCHAR(100) PRIMARY KEY,
    series_id VARCHAR(100) NOT NULL,
    user_id UUID NOT NULL,
    transaction_id VARCHAR(100),
    expected_date DATE NOT NULL,
    actual_date DATE,
    expected_amount DECIMAL(12,2) NOT NULL,
    actual_amount DECIMAL(12,2),
    status VARCHAR(20) NOT NULL,
    variance DECIMAL(12,2),
    link_type VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (series_id) REFERENCES series(series_id) ON DELETE CASCADE,
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id)
);
```

2. **Background Jobs:**
```bash
# Daily: Generate expected instances
0 0 * * * /usr/bin/python /app/jobs/generate_expected_instances.py

# Hourly: Detect missing instances
0 * * * * /usr/bin/python /app/jobs/detect_missing_instances.py

# Per-transaction: Auto-link (via event queue)
# No cron, triggered by normalization complete event
```

**Monitoring:**

- **Health Check:** `GET /api/health/series` - Returns OK if SeriesStore can query database
- **Metric Alerts:**
  - Auto-link success rate < 80% â†’ page on-call
  - Missing instance count per user > 50 â†’ investigate data quality
  - Manual link rate > 20% â†’ user experience issue

**Common Issues:**

**Issue 1: Auto-link not working**
- **Symptom:** Transactions not linking to series, instances remain "upcoming"
- **Debug:**
  1. Check auto-link logs for match_criteria failures
  2. Verify transaction.counterparty_id matches series.counterparty_id (or alias)
  3. Verify amount within tolerance
  4. Check date window (Â±3 days)
- **Fix:** Adjust tolerance, update series counterparty, or manual link

**Issue 2: Missing instances spike**
- **Symptom:** Sudden increase in status="missing" instances
- **Debug:**
  1. Check if transactions are being normalized (upstream issue in 1.3)
  2. Verify counterparty matching (3.2 registry may have duplicates)
  3. Check if user changed accounts (series still references old account)
- **Fix:** Run backfill job, update series accounts, merge duplicate counterparties

**Issue 3: Recurrence calculation incorrect**
- **Symptom:** next_expected_date is wrong (e.g., Feb 30)
- **Debug:**
  1. Check frequency pattern in series record
  2. Test RecurrenceEngine.calculate_next_expected() with pattern
  3. Verify last-day-of-month logic
- **Fix:** Update RecurrenceEngine logic, recalculate all expected instances

**Incident Response:**

```bash
# Query missing instances for user
SELECT s.name, i.expected_date, i.status
FROM series s
JOIN series_instances i ON s.series_id = i.series_id
WHERE s.user_id = 'USER_ID' AND i.status = 'missing'
ORDER BY i.expected_date DESC;

# Force manual link (bypass tolerance)
curl -X POST /api/series/{series_id}/link \
  -H "Authorization: Bearer TOKEN" \
  -d '{"transaction_id": "txn_123", "force": true}'

# Regenerate expected instances
python /app/scripts/regenerate_instances.py --series-id={series_id} --months=12

# Backfill past transactions
python /app/scripts/backfill_series.py --user-id={user_id} --series-id={series_id} --since=2024-01-01
```

---

## ðŸŽ¯ Summary

Vertical 3.3 delivers a **closed registry for recurring payment tracking** with:

âœ… **3 OL Primitives** (SeriesStore, RecurrenceEngine, InstanceTracker)
âœ… **3 IL Components** (SeriesManager, SeriesSelector, RecurrenceConfigDialog)
âœ… **2 Schemas** (series, series-instance)
âœ… **20 Complete Sections** (Product, Machinery, Cross-Cutting)
âœ… **Multi-Domain Pattern** (Finance, Healthcare, Legal, Research, Manufacturing, Media)

**Next:** 3.4 Tax Categorization
