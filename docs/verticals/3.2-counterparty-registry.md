# Vertical 3.2: Counterparty Registry

**Status:** ✅ Complete
**Type:** Registry Management (Open Registry)
**Domain:** Finance (multi-domain pattern)

---

## PRODUCT LAYER (Sections 1-10)

### 1. Scope & Boundaries

**IN SCOPE:**
- Auto-create counterparties from transaction normalization (e.g., "OPENAI" → counterparty)
- Store canonical name + aliases (e.g., canonical: "OpenAI", aliases: ["OPENAI", "OPENAI INC", "openai.com"])
- Merge duplicate counterparties (e.g., merge "OpenAI" + "OpenAI Inc" → single entity)
- Edit counterparty details (canonical name, type, notes)
- List all counterparties with search/filter
- Assign type (merchant, person, business, government)
- Link transactions to counterparties via counterparty_id

**OUT OF SCOPE:**
- External data enrichment (e.g., fetch company logo from API) - deferred to V2
- Automatic duplicate detection (ML-based) - deferred to V2
- Counterparty relationships (e.g., "parent company") - deferred
- Multi-user shared counterparty database - deferred
- Counterparty tags/categories beyond type - simplified for V1

**KEY INSIGHT:**
"Open registry" = grows automatically as new merchants/people appear in transactions. Unlike Account (closed registry - manually created), Counterparty is auto-populated during normalization.

**Canonical Name + Aliases Pattern:**
- Canonical name: User-friendly, normalized (e.g., "OpenAI")
- Aliases: All variations seen in raw data (e.g., ["OPENAI", "OPENAI INC", "openai.com", "OPENAI*"])
- When transaction has merchant = "OPENAI INC" → links to counterparty with canonical name "OpenAI"

---

### 2. User Flow (Real Usage)

**Scenario 1: Auto-creation during normalization**
```
Normalizer processes observation: merchant = "UBER EATS *1234"
→ CounterpartyMatcher searches for existing counterparty with alias "UBER EATS *1234"
→ Not found
→ CounterpartyStore creates new counterparty:
   - canonical_name: "Uber Eats" (cleaned)
   - aliases: ["UBER EATS *1234"]
   - type: merchant (inferred)
   - counterparty_id: "cpty_uber_eats_1"
→ Canonical transaction links to counterparty_id = "cpty_uber_eats_1"
```

**Scenario 2: Matching existing counterparty (alias match)**
```
Normalizer processes observation: merchant = "UBER *5678"
→ CounterpartyMatcher searches for alias "UBER *5678"
→ Not found
→ CounterpartyMatcher fuzzy matches "UBER *5678" → finds "Uber Eats" (score 0.85)
→ System suggests: "Link 'UBER *5678' to existing 'Uber Eats'?" (auto-accept if score > 0.90)
→ If accepted: Add "UBER *5678" to aliases for "Uber Eats"
→ Canonical transaction links to counterparty_id = "cpty_uber_eats_1"
```

**Scenario 3: User merges duplicates**
```
User sees in counterparty list:
  - OpenAI (5 transactions)
  - OpenAI Inc (3 transactions)
  - OPENAI* (2 transactions)

User suspects these are duplicates
→ User selects all 3 counterparties
→ User clicks [Merge Counterparties]
→ Merge dialog opens:
   - Primary: OpenAI (most transactions)
   - Merge into primary: OpenAI Inc, OPENAI*
   - New aliases: ["OPENAI", "OPENAI INC", "OPENAI*", "openai.com"]
→ User confirms
→ System:
   1. Updates all transactions from "cpty_openai_inc_2" → "cpty_openai_1"
   2. Updates all transactions from "cpty_openai_3" → "cpty_openai_1"
   3. Merges aliases into "cpty_openai_1"
   4. Marks "cpty_openai_inc_2" and "cpty_openai_3" as merged (soft delete)
→ User now sees single "OpenAI" with 10 transactions
```

**Scenario 4: User edits canonical name**
```
User views counterparty "Uber Eats"
→ User clicks [Edit]
→ User changes canonical_name: "Uber Eats" → "UberEats"
→ User clicks [Save]
→ System updates canonical_name
→ Aliases remain unchanged (still ["UBER EATS *1234", "UBER *5678"])
→ All transactions still linked to same counterparty_id
```

**Scenario 5: User assigns type**
```
User views counterparty "Diana de la Tejera" (auto-created as merchant)
→ User clicks [Edit]
→ User changes type: merchant → person
→ User adds note: "Freelance designer"
→ System updates type and notes
```

---

### 3. Primitives Touched

**OL (Objective Layer):**
- **CounterpartyStore** (NEW) - CRUD operations for counterparties with alias management
- **CounterpartyMatcher** (NEW) - Fuzzy matching to find existing counterparties from raw merchant names
- **AliasMerger** (NEW) - Merges duplicate counterparties and migrates transactions
- **Normalizer** (from 1.3) - Creates counterparties during normalization
- **CanonicalStore** (from 1.3) - Transactions link to counterparty_id

**IL (Interface Layer):**
- **CounterpartyManager** (NEW) - Full UI for viewing, editing, merging counterparties
- **CounterpartySelector** (NEW) - Reusable dropdown for selecting counterparty
- **MergeCounterpartiesDialog** (NEW) - UI for merging duplicate counterparties

---

### 4. Contracts (API + Internal)

**Public API:**

#### POST /api/counterparties
```http
POST /api/counterparties
Authorization: Bearer {token}
Content-Type: application/json

{
  "canonical_name": "OpenAI",
  "type": "merchant",
  "aliases": ["OPENAI", "OPENAI INC"],
  "notes": "AI research company"
}
```

**Response (Success - 201 Created):**
```json
{
  "counterparty": {
    "counterparty_id": "cpty_openai_1",
    "user_id": "user_darwin",
    "canonical_name": "OpenAI",
    "type": "merchant",
    "aliases": ["OPENAI", "OPENAI INC"],
    "notes": "AI research company",
    "transaction_count": 0,
    "created_at": "2025-05-20T10:00:00Z",
    "updated_at": "2025-05-20T10:00:00Z",
    "merged_into": null
  }
}
```

**Response (Error - 409 Conflict - Duplicate Canonical Name):**
```json
{
  "error": {
    "code": "DUPLICATE_CANONICAL_NAME",
    "message": "Counterparty with canonical name 'OpenAI' already exists",
    "field": "canonical_name",
    "existing_counterparty_id": "cpty_openai_1"
  }
}
```

---

#### GET /api/counterparties
```http
GET /api/counterparties?type=merchant&search=uber
Authorization: Bearer {token}
```

**Response (Success - 200 OK):**
```json
{
  "counterparties": [
    {
      "counterparty_id": "cpty_uber_1",
      "canonical_name": "Uber",
      "type": "merchant",
      "aliases": ["UBER *RIDE", "UBER *TRIP", "UBER USA"],
      "notes": null,
      "transaction_count": 15,
      "created_at": "2025-05-15T08:00:00Z",
      "updated_at": "2025-05-18T14:30:00Z",
      "merged_into": null
    },
    {
      "counterparty_id": "cpty_uber_eats_2",
      "canonical_name": "Uber Eats",
      "type": "merchant",
      "aliases": ["UBER EATS *1234", "UBER *5678", "UBEREATS"],
      "notes": null,
      "transaction_count": 8,
      "created_at": "2025-05-16T09:00:00Z",
      "updated_at": "2025-05-19T11:15:00Z",
      "merged_into": null
    }
  ],
  "count": 2,
  "total": 127
}
```

**Query Parameters:**
- `type` (optional): Filter by type (merchant, person, business, government)
- `search` (optional): Search in canonical_name and aliases (case-insensitive)
- `limit` (optional): Pagination limit (default: 50, max: 100)
- `offset` (optional): Pagination offset

---

#### PUT /api/counterparties/{counterparty_id}
```http
PUT /api/counterparties/cpty_openai_1
Authorization: Bearer {token}
Content-Type: application/json

{
  "canonical_name": "OpenAI Inc",
  "type": "business",
  "notes": "AI research and deployment company"
}
```

**Response (Success - 200 OK):**
```json
{
  "counterparty": {
    "counterparty_id": "cpty_openai_1",
    "canonical_name": "OpenAI Inc",
    "type": "business",
    "aliases": ["OPENAI", "OPENAI INC", "openai.com"],
    "notes": "AI research and deployment company",
    "transaction_count": 5,
    "created_at": "2025-05-20T10:00:00Z",
    "updated_at": "2025-05-21T15:45:00Z",
    "merged_into": null
  }
}
```

---

#### POST /api/counterparties/merge
```http
POST /api/counterparties/merge
Authorization: Bearer {token}
Content-Type: application/json

{
  "primary_id": "cpty_openai_1",
  "merge_ids": ["cpty_openai_inc_2", "cpty_openai_3"],
  "merge_aliases": true
}
```

**Response (Success - 200 OK):**
```json
{
  "primary_counterparty": {
    "counterparty_id": "cpty_openai_1",
    "canonical_name": "OpenAI",
    "aliases": ["OPENAI", "OPENAI INC", "OPENAI*", "openai.com", "OpenAI Inc"],
    "transaction_count": 10,
    "merged_count": 2
  },
  "merged_counterparties": [
    {
      "counterparty_id": "cpty_openai_inc_2",
      "canonical_name": "OpenAI Inc",
      "merged_into": "cpty_openai_1",
      "transactions_migrated": 3
    },
    {
      "counterparty_id": "cpty_openai_3",
      "canonical_name": "OPENAI*",
      "merged_into": "cpty_openai_1",
      "transactions_migrated": 2
    }
  ],
  "message": "Successfully merged 2 counterparties into cpty_openai_1. Migrated 5 transactions."
}
```

---

#### GET /api/counterparties/suggest-duplicates
```http
GET /api/counterparties/suggest-duplicates?threshold=0.85
Authorization: Bearer {token}
```

**Response (Success - 200 OK):**
```json
{
  "duplicate_groups": [
    {
      "primary": {
        "counterparty_id": "cpty_openai_1",
        "canonical_name": "OpenAI",
        "transaction_count": 5
      },
      "duplicates": [
        {
          "counterparty_id": "cpty_openai_inc_2",
          "canonical_name": "OpenAI Inc",
          "transaction_count": 3,
          "similarity_score": 0.92
        },
        {
          "counterparty_id": "cpty_openai_3",
          "canonical_name": "OPENAI*",
          "transaction_count": 2,
          "similarity_score": 0.88
        }
      ]
    },
    {
      "primary": {
        "counterparty_id": "cpty_uber_1",
        "canonical_name": "Uber",
        "transaction_count": 15
      },
      "duplicates": [
        {
          "counterparty_id": "cpty_uber_ride_4",
          "canonical_name": "Uber Ride",
          "transaction_count": 2,
          "similarity_score": 0.87
        }
      ]
    }
  ],
  "count": 2
}
```

---

**Internal Contracts:**

#### CounterpartyStore.find_or_create()
```python
class CounterpartyStore:
    def find_or_create(
        self,
        user_id: str,
        merchant_name: str,  # Raw merchant from transaction
        type: Optional[str] = None
    ) -> Counterparty:
        """
        Find existing counterparty or create new one.

        Steps:
        1. Check for exact alias match
        2. If not found, fuzzy match (similarity > 0.90 = auto-link)
        3. If no match, create new counterparty

        Args:
            user_id: Owner
            merchant_name: Raw merchant from transaction (e.g., "UBER EATS *1234")
            type: Optional type (merchant, person, business, government)

        Returns:
            Counterparty object (existing or newly created)
        """
```

#### CounterpartyMatcher.fuzzy_match()
```python
class CounterpartyMatcher:
    def fuzzy_match(
        self,
        user_id: str,
        merchant_name: str,
        threshold: float = 0.85
    ) -> List[Tuple[Counterparty, float]]:
        """
        Find counterparties matching merchant_name using fuzzy matching.

        Algorithm:
        - Levenshtein distance for string similarity
        - Token-based matching (e.g., "UBER EATS" matches "UBER")
        - Ignore special characters (*1234, etc.)

        Args:
            user_id: Owner
            merchant_name: Raw merchant to match
            threshold: Minimum similarity score (0.0-1.0)

        Returns:
            List of (Counterparty, similarity_score) tuples, sorted by score DESC
        """
```

#### AliasMerger.merge()
```python
class AliasMerger:
    def merge(
        self,
        user_id: str,
        primary_id: str,
        merge_ids: List[str],
        merge_aliases: bool = True
    ) -> MergeResult:
        """
        Merge counterparties into primary.

        Steps:
        1. Validate all counterparties exist and user owns them
        2. Migrate all transactions from merge_ids → primary_id
        3. Merge aliases into primary (if merge_aliases=True)
        4. Mark merge_ids as merged (soft delete, set merged_into=primary_id)
        5. Log merge operation

        Args:
            user_id: Owner
            primary_id: Primary counterparty to merge into
            merge_ids: List of counterparty IDs to merge
            merge_aliases: Whether to merge aliases (default True)

        Returns:
            MergeResult with transaction counts, aliases merged

        Raises:
            CounterpartyNotFoundError: If any ID doesn't exist
            UnauthorizedError: If user doesn't own counterparties
            CannotMergeSelfError: If primary_id in merge_ids
        """
```

---

### 5. Schemas / Tipos (Persistencia)

**Counterparty Entity (Database):**
```sql
CREATE TABLE counterparties (
    counterparty_id VARCHAR(50) PRIMARY KEY,  -- Format: "cpty_{slug}_{seq}"
    user_id VARCHAR(50) NOT NULL,

    -- Core fields
    canonical_name VARCHAR(200) NOT NULL,   -- "OpenAI"
    type VARCHAR(20) NOT NULL,              -- merchant, person, business, government
    aliases TEXT[],                         -- ["OPENAI", "OPENAI INC", "openai.com"]
    notes TEXT,                             -- Optional user notes

    -- Metadata
    transaction_count INT DEFAULT 0,        -- Denormalized for performance
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    merged_into VARCHAR(50),                -- NULL if active, cpty_id if merged

    -- Constraints
    UNIQUE(user_id, canonical_name),        -- Unique canonical name per user
    INDEX idx_user (user_id),
    INDEX idx_canonical (canonical_name),
    INDEX idx_aliases (aliases) USING GIN,  -- PostgreSQL GIN index for array search
    INDEX idx_type (type),
    INDEX idx_merged (merged_into),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (merged_into) REFERENCES counterparties(counterparty_id)
);
```

**CounterpartyType Enum:**
```typescript
type CounterpartyType =
  | "merchant"    // Business/store (e.g., Uber, Starbucks, Amazon)
  | "person"      // Individual (e.g., Diana de la Tejera, John Doe)
  | "business"    // Company (e.g., OpenAI Inc, Acme Corp)
  | "government"  // Government entity (e.g., IRS, CFE, CDMX)
```

**See:** `docs/schemas/counterparty.schema.json`

---

### 6. Validaciones & Estados

**Counterparty Validation Rules:**

1. **Canonical Name Validation:**
   - Required: `canonical_name.length >= 1`
   - Max length: `canonical_name.length <= 200`
   - Uniqueness: No duplicate canonical names per user (case-insensitive)
   - No leading/trailing whitespace

2. **Type Validation:**
   - Required: `type` must be specified
   - Allowed values: `["merchant", "person", "business", "government"]`

3. **Aliases Validation:**
   - Array of strings
   - Each alias max length: 200 characters
   - No duplicates within same counterparty
   - No empty strings

4. **Notes Validation:**
   - Optional field
   - Max length: 1000 characters

**Counterparty States:**

Counterparties have 2 states:

```
merged_into = null  → Active counterparty (appears in lists, used in transactions)
merged_into = "cpty_xyz" → Merged counterparty (hidden, transactions migrated)
```

**Merge is irreversible** (by design - prevents data corruption).

---

### 7. Edge Cases

**Edge Case 1: Merging counterparty with 1000+ transactions**
```
Scenario: User merges "Uber" (1000 txns) with "Uber Ride" (500 txns)
Solution: Batch update transactions in chunks of 100
Performance: <5 seconds for 1500 transactions
Validation: Verify transaction_count = 1500 after merge
```

**Edge Case 2: Alias conflict after merge**
```
Scenario:
  - Counterparty A has alias "UBER"
  - Counterparty B has alias "UBER"
  - User merges A + B

Solution: De-duplicate aliases during merge (keep unique values only)
Result: Merged counterparty has alias "UBER" once
```

**Edge Case 3: Circular merge (merged_into points to another merged counterparty)**
```
Scenario:
  - cpty_1 merged_into cpty_2
  - cpty_2 merged_into cpty_3
  - Transaction still references cpty_1

Solution: CounterpartyStore.resolve() follows merge chain to find final counterparty
Query: SELECT * FROM counterparties WHERE counterparty_id = resolve('cpty_1') → returns cpty_3
```

**Edge Case 4: User edits canonical name to match existing counterparty**
```
Scenario: User has "OpenAI" and "OpenAI Inc", tries to rename "OpenAI Inc" → "OpenAI"
Result: 409 Conflict error
Suggestion: "Merge with existing 'OpenAI' instead?"
```

**Edge Case 5: Fuzzy match ambiguity**
```
Scenario:
  - Existing: "Uber" (score 0.88), "Uber Eats" (score 0.87)
  - New merchant: "UBER *1234"

Solution:
  - If top score > 0.90: Auto-link (high confidence)
  - If top score 0.80-0.90: Suggest to user (medium confidence)
  - If top score < 0.80: Create new counterparty (low confidence)
```

**Edge Case 6: Deleted user with counterparties**
```
Scenario: User deleted, but counterparties exist
Solution: Cascade delete counterparties (and unlink from transactions)
Alternative: Anonymize counterparties (keep for audit trail)
Decision: V1 = cascade delete, V2 = anonymize option
```

**Edge Case 7: Two users create same canonical name**
```
Scenario:
  - User A creates "OpenAI"
  - User B creates "OpenAI"

Result: Allowed - canonical names are unique per user, not globally
Rationale: Each user has their own counterparty namespace
```

---

### 8. Acceptance Criteria (Definition of Done)

**Auto-creation during normalization:**
- ✅ Normalizer creates counterparty if merchant not found
- ✅ Counterparty assigned unique counterparty_id
- ✅ Canonical name cleaned (remove special chars, normalize case)
- ✅ Alias added from raw merchant name

**Fuzzy matching works:**
- ✅ Exact alias match returns existing counterparty
- ✅ Fuzzy match with score > 0.90 auto-links
- ✅ Fuzzy match with score 0.80-0.90 suggests to user
- ✅ No match (score < 0.80) creates new counterparty

**User can merge counterparties:**
- ✅ POST /api/counterparties/merge merges multiple counterparties
- ✅ All transactions migrated to primary counterparty
- ✅ Aliases merged (de-duplicated)
- ✅ Merged counterparties marked as merged_into = primary_id
- ✅ Transaction count updated correctly

**User can edit counterparty:**
- ✅ PUT /api/counterparties/{id} updates canonical_name, type, notes
- ✅ Cannot rename to conflict with existing canonical_name
- ✅ Aliases remain unchanged (managed separately)

**Duplicate suggestions work:**
- ✅ GET /api/counterparties/suggest-duplicates returns similar counterparties
- ✅ Similarity score calculated correctly (Levenshtein distance)
- ✅ Grouped by primary counterparty

**Search and filter work:**
- ✅ GET /api/counterparties?search=uber searches canonical_name and aliases
- ✅ GET /api/counterparties?type=merchant filters by type
- ✅ Pagination works (limit, offset)

---

### 9. Logs & Provenance

**Counterparty Change Log:**

Every counterparty modification logged in `counterparty_change_log` table:

```sql
CREATE TABLE counterparty_change_log (
    log_id VARCHAR(50) PRIMARY KEY,
    counterparty_id VARCHAR(50) NOT NULL,
    user_id VARCHAR(50) NOT NULL,

    operation VARCHAR(20) NOT NULL,  -- CREATE, UPDATE, MERGE, ADD_ALIAS
    changes JSONB,                   -- {field: {old: X, new: Y}}
    related_counterparty_ids TEXT[], -- For merge operations

    timestamp TIMESTAMP NOT NULL,

    FOREIGN KEY (counterparty_id) REFERENCES counterparties(counterparty_id),
    INDEX idx_counterparty (counterparty_id),
    INDEX idx_user (user_id)
);
```

**Example Log Entry (CREATE):**
```json
{
  "log_id": "cptycl_1234567890",
  "counterparty_id": "cpty_openai_1",
  "user_id": "user_darwin",
  "operation": "CREATE",
  "changes": {
    "canonical_name": {"old": null, "new": "OpenAI"},
    "type": {"old": null, "new": "merchant"},
    "aliases": {"old": [], "new": ["OPENAI"]}
  },
  "related_counterparty_ids": [],
  "timestamp": "2025-05-20T10:00:00Z"
}
```

**Example Log Entry (MERGE):**
```json
{
  "log_id": "cptycl_1234567891",
  "counterparty_id": "cpty_openai_1",
  "user_id": "user_darwin",
  "operation": "MERGE",
  "changes": {
    "aliases": {
      "old": ["OPENAI"],
      "new": ["OPENAI", "OPENAI INC", "openai.com"]
    },
    "transaction_count": {"old": 5, "new": 10}
  },
  "related_counterparty_ids": ["cpty_openai_inc_2", "cpty_openai_3"],
  "timestamp": "2025-05-21T14:30:00Z"
}
```

---

### 10. Risks & Deferred

**RISKS:**

1. **Fuzzy matching accuracy:**
   - Risk: False positives (linking wrong counterparties)
   - Mitigation: Conservative threshold (0.90 for auto-link), user confirmation for 0.80-0.90
   - Monitoring: Track user overrides (when they reject suggestions)

2. **Performance of alias search (GIN index):**
   - Risk: Slow queries on large alias arrays (1000+ counterparties)
   - Mitigation: PostgreSQL GIN index on aliases array
   - Fallback: Full-text search (tsvector) if GIN insufficient

3. **Irreversible merge:**
   - Risk: User accidentally merges wrong counterparties
   - Mitigation: Confirmation dialog with preview
   - Future: "Undo merge" operation (restore from change log)

4. **Transaction count drift:**
   - Risk: Denormalized transaction_count becomes inaccurate
   - Mitigation: Recalculate on merge, periodic reconciliation job
   - Monitoring: Alert if count differs from actual COUNT(*) by >10%

**DEFERRED:**

1. **ML-based duplicate detection:**
   - Feature: Automatic duplicate suggestions using machine learning
   - Deferred to: V2 (requires training data, model deployment)

2. **External data enrichment:**
   - Feature: Fetch company logo, address, industry from external API
   - Deferred to: Vertical 5.x (External Integrations)

3. **Counterparty relationships:**
   - Feature: Model parent/subsidiary relationships (e.g., "Uber" parent of "Uber Eats")
   - Deferred to: V3 (complex graph structure)

4. **Multi-user shared counterparty DB:**
   - Feature: Global counterparty database shared across users
   - Deferred to: V3 (privacy, consent, canonicalization challenges)

5. **Undo merge:**
   - Feature: Revert merge operation
   - Deferred to: V2 (requires complex transaction migration rollback)

6. **Bulk import counterparties:**
   - Feature: Upload CSV of counterparties
   - Deferred to: V2 (UX enhancement)

---

## MACHINERY LAYER (Sections 11-15)

### 11. Primitives Introduced

This vertical introduces **6 new primitives:**

#### 11.1 CounterpartyStore (OL Primitive)

**Purpose:** CRUD operations for counterparties with alias management and find_or_create pattern

**Multi-domain applicability:**
- Finance: Merchants, payees, service providers
- Healthcare: Healthcare providers, pharmacies, insurance companies
- Legal: Opposing parties, law firms, courts
- Research: Publishers, institutions, co-authors
- Manufacturing: Suppliers, vendors, distributors
- Media: Advertisers, sponsors, content creators

**See:** `docs/primitives/ol/CounterpartyStore.md`

---

#### 11.2 CounterpartyMatcher (OL Primitive)

**Purpose:** Fuzzy matching to find existing counterparties from raw merchant names

**Multi-domain applicability:**
- Finance: Match "UBER EATS *1234" to "Uber Eats"
- Healthcare: Match "DR SMITH CLINIC" to "Dr. Smith Clinic"
- Legal: Match "JONES & ASSOCIATES" to "Jones & Associates Law Firm"
- Research: Match "MIT PRESS" to "MIT Press"
- Manufacturing: Match "ACME CORP INC" to "Acme Corporation"
- Media: Match "GOOGLE ADS *5678" to "Google Ads"

**See:** `docs/primitives/ol/CounterpartyMatcher.md`

---

#### 11.3 AliasMerger (OL Primitive)

**Purpose:** Merges duplicate counterparties and migrates transactions

**Multi-domain applicability:**
- Finance: Merge "OpenAI" + "OpenAI Inc" + "OPENAI*"
- Healthcare: Merge "Blue Cross" + "BlueCross BlueShield" + "BCBS"
- Legal: Merge "Smith Law" + "Smith & Associates" + "Smith Legal"
- Research: Merge "Nature" + "Nature Publishing" + "Nature Journal"
- Manufacturing: Merge "Acme Corp" + "ACME" + "Acme Manufacturing"
- Media: Merge "YouTube" + "YouTube Inc" + "YOUTUBE*"

**See:** `docs/primitives/ol/AliasMerger.md`

---

#### 11.4 CounterpartyManager (IL Component)

**Purpose:** Full UI for viewing, editing, merging counterparties with duplicate suggestions

**Multi-domain applicability:**
- Finance: Manage merchants and payees
- Healthcare: Manage healthcare providers
- Legal: Manage opposing parties and law firms
- Research: Manage publishers and co-authors
- Manufacturing: Manage suppliers and vendors
- Media: Manage advertisers and sponsors

**See:** `docs/primitives/il/CounterpartyManager.md`

---

#### 11.5 CounterpartySelector (IL Component)

**Purpose:** Reusable dropdown for selecting counterparty (used in transaction editing, filtering)

**Multi-domain applicability:**
- Finance: Select merchant in transaction edit
- Healthcare: Select provider in claim edit
- Legal: Select opposing party in case allocation
- Research: Select publisher in citation management
- Manufacturing: Select supplier in purchase order
- Media: Select advertiser in campaign analytics

**See:** `docs/primitives/il/CounterpartySelector.md`

---

#### 11.6 MergeCounterpartiesDialog (IL Component)

**Purpose:** Dialog for merging duplicate counterparties with preview and confirmation

**Multi-domain applicability:**
- Finance: Merge duplicate merchants
- Healthcare: Merge duplicate providers
- Legal: Merge duplicate parties
- Research: Merge duplicate publishers
- Manufacturing: Merge duplicate suppliers
- Media: Merge duplicate advertisers

**See:** `docs/primitives/il/MergeCounterpartiesDialog.md`

---

### 12. Interlocks with Other Verticals

**DEPENDS ON (Prerequisites):**

1. **Vertical 1.3 (Normalization) - Normalizer, CanonicalStore**
   - Why: Normalizer creates counterparties during transaction normalization
   - Integration: Normalizer calls CounterpartyStore.find_or_create()
   - Example: Transaction with merchant = "UBER" → creates/links counterparty

2. **Vertical 3.1 (Account Registry) - AccountStore**
   - Why: Transactions link to both account_id and counterparty_id
   - Integration: Both are foreign keys in canonical_transactions table
   - Example: "BofA Checking → Uber" (account → counterparty)

**ENABLES (Future Verticals):**

1. **Vertical 3.3 (Series) - Recurring Payments**
   - Why: Series track recurring payments to same counterparty
   - Integration: Series entity has counterparty_id field
   - Example: "OpenAI Subscription" always charged to counterparty "OpenAI"

2. **Vertical 3.4 (Tax Categorization)**
   - Why: Tax rules may depend on counterparty type
   - Integration: Tax engine reads counterparty type (government = tax payment)
   - Example: Payments to "IRS" are tax payments

3. **Vertical 4.x (Analytics & Reports)**
   - Why: Reports group by counterparty (e.g., "top 10 merchants")
   - Integration: Dashboard queries CounterpartyStore
   - Example: "Spending by merchant" report

**CROSS-CUTTING:**

1. **Vertical 2.1 (Transaction List View) - TransactionTable**
   - Integration: Transaction list shows counterparty canonical name
   - Enhancement: Click counterparty → filter by that counterparty

2. **Vertical 2.2 (OL Exploration) - DrillDownPanel**
   - Integration: Drill-down shows counterparty details (canonical name, aliases)
   - Enhancement: View all transactions for this counterparty

---

### 13. Reusability (Multi-Domain Generalization)

**Core Pattern: Open Registry with Aliases**

Counterparty Registry is an instance of **Open Registry Pattern** - auto-growing collection with alias management.

**Universal Properties:**
1. Auto-created from incoming data (not manually created)
2. Canonical name + aliases (many-to-one mapping)
3. Fuzzy matching to link variants to canonical entity
4. Merge duplicates (consolidate multiple entities into one)
5. Used as foreign keys in other entities
6. Large dataset (100s-1000s of items per user)

**Other Domains Using Same Pattern:**

| Domain | Finance Example | Healthcare Example | Legal Example | Research Example |
|--------|----------------|-------------------|---------------|------------------|
| **Entity** | Counterparty | Healthcare Provider | Opposing Party | Publisher |
| **Canonical** | OpenAI | Dr. Smith Clinic | Jones & Associates | MIT Press |
| **Aliases** | ["OPENAI", "OPENAI INC"] | ["DR SMITH", "SMITH CLINIC"] | ["JONES LAW", "JONES & ASSOC"] | ["MIT PRESS", "MIT Publishing"] |
| **Type** | merchant, person, business | hospital, clinic, pharmacy | law_firm, individual, court | journal, book_publisher, preprint |
| **Merge** | OpenAI + OpenAI Inc → OpenAI | Dr. Smith + Smith Clinic → Dr. Smith Clinic | Jones Law + Jones & Assoc → Jones & Associates | MIT + MIT Press → MIT Press |

**Abstraction:**

```typescript
interface OpenRegistry<T> {
  find_or_create(raw_name: string): T;
  fuzzy_match(raw_name: string, threshold: number): T[];
  merge(primary_id: string, merge_ids: string[]): MergeResult;
  add_alias(id: string, alias: string): T;
}

// Finance instantiation
type Counterparty = {
  counterparty_id: string;
  canonical_name: string;
  aliases: string[];
  type: CounterpartyType;
}

// Healthcare instantiation
type HealthcareProvider = {
  provider_id: string;
  canonical_name: string;
  aliases: string[];
  type: ProviderType;
}

// Same find_or_create + fuzzy_match + merge operations, different data
```

---

### 14. Pattern Abstraction

**Pattern Name:** **Open Registry with Aliases Pattern**

**Intent:**
Manage an auto-growing collection of entities extracted from raw data, with fuzzy matching and duplicate merging.

**When to Use:**
- Data comes from external sources with inconsistent naming
- Same entity appears with multiple variations (e.g., "UBER", "Uber Eats", "UBER *1234")
- Need to consolidate duplicates post-hoc
- Dataset too large for manual curation (100s-1000s of items)

**Structure:**

```
┌─────────────────────────────────────────┐
│     CounterpartyManager (UI)            │
│  - List counterparties                  │
│  - Search and filter                    │
│  - Merge duplicates                     │
│  - View/edit details                    │
└─────────────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│       CounterpartyStore (OL)            │
│  - find_or_create(raw_name)             │
│  - fuzzy_match(raw_name)                │
│  - merge(primary, merge_ids)            │
│  - add_alias(id, alias)                 │
└─────────────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│    CounterpartyMatcher (OL)             │
│  - exact_match(alias)                   │
│  - fuzzy_match(raw_name, threshold)     │
│  - calculate_similarity(a, b)           │
└─────────────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│       AliasMerger (OL)                  │
│  - merge(primary, merge_ids)            │
│  - migrate_transactions()               │
│  - merge_aliases()                      │
└─────────────────────────────────────────┘
```

**Participants:**

1. **OpenRegistryStore** - CRUD + find_or_create + merge operations
2. **FuzzyMatcher** - Similarity scoring and duplicate detection
3. **AliasMerger** - Merge duplicates and migrate foreign keys
4. **RegistryManager** (UI) - View, search, merge UI
5. **RegistrySelector** (UI) - Dropdown for selecting entity

**Consequences:**

**Benefits:**
- ✅ Auto-grows from incoming data (no manual entry)
- ✅ Handles inconsistent naming (fuzzy matching)
- ✅ Consolidates duplicates (merge operation)
- ✅ Reusable across domains

**Drawbacks:**
- ❌ Fuzzy matching can have false positives
- ❌ Merge is complex (migrate foreign keys)
- ❌ Requires user review (suggest duplicates, don't auto-merge everything)

**Related Patterns:**
- **Closed Registry Pattern** (Vertical 3.1 Account) - Manually curated, fixed-size
- **Master Data Management (MDM)** - Enterprise-scale with global IDs, hierarchies

---

### 15. Métricas de Madurez

**Functional Maturity:**

| Metric | Target | Measurement |
|--------|--------|-------------|
| Auto-creation during normalization | 100% | All new merchants create counterparties |
| Fuzzy match accuracy | >90% | % of correct matches (user doesn't override) |
| Merge operation success | 100% | All merges migrate transactions correctly |
| Duplicate detection recall | >80% | % of actual duplicates suggested |
| Alias search works | 100% | Exact alias match always finds counterparty |

**Non-Functional Maturity:**

| Metric | Target | Current | Measurement |
|--------|--------|---------|-------------|
| find_or_create latency | <200ms p95 | TBD | Time to find or create counterparty |
| Fuzzy match latency | <500ms p95 | TBD | Time to fuzzy match against 1000 counterparties |
| Merge latency (100 txns) | <2s p95 | TBD | Time to merge with 100 transactions |
| Alias search latency | <100ms p95 | TBD | GIN index search on aliases array |
| Data consistency | 100% | TBD | transaction_count matches actual COUNT(*) |

**Operational Maturity:**

| Metric | Target | Current |
|--------|--------|---------|
| API uptime | 99.9% | TBD |
| Merge error rate | <0.1% | TBD |
| User override rate | <10% | TBD |
| Duplicate suggestion accuracy | >85% | TBD |

---

## CROSS-CUTTING CONCERNS (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**

1. **User Isolation:**
   - Rule: Users can only access their own counterparties
   - Enforcement: All queries filtered by `user_id` from JWT token
   - Test: User A cannot GET /api/counterparties for User B

2. **Merge Authorization:**
   - Rule: Only owner can merge counterparties
   - Enforcement: Merge operation verifies all counterparties belong to user
   - Test: User A cannot merge User B's counterparties (returns 403 Forbidden)

**Input Validation:**

1. **SQL Injection Prevention:**
   - All inputs sanitized before SQL queries
   - Parameterized queries for alias array search
   - Example: `SELECT * FROM counterparties WHERE ? = ANY(aliases)` (parameterized)

2. **XSS Prevention:**
   - Canonical names and aliases sanitized on output
   - HTML tags stripped/escaped

**Data Privacy:**

1. **No PII Leakage:**
   - Counterparty names may contain personal information (e.g., "Diana de la Tejera")
   - Never log names in plain text
   - Redact in logs: `"canonical_name": "[REDACTED]"`

---

### 17. Performance Characteristics

**Database Queries:**

**Query 1: Find by Alias (Exact Match)**
```sql
SELECT * FROM counterparties
WHERE user_id = ? AND ? = ANY(aliases) AND merged_into IS NULL
LIMIT 1;
```
- **Index:** GIN index on aliases array
- **Performance:** <50ms (indexed array search)

**Query 2: Fuzzy Match (Top 10)**
```sql
SELECT counterparty_id, canonical_name,
       similarity(canonical_name, ?) AS score
FROM counterparties
WHERE user_id = ? AND merged_into IS NULL
ORDER BY score DESC
LIMIT 10;
```
- **Index:** Trigram index (pg_trgm extension) on canonical_name
- **Performance:** <500ms for 1000 counterparties

**Query 3: Merge (Migrate Transactions)**
```sql
-- Batch update in chunks of 100
UPDATE canonical_transactions
SET counterparty_id = ?
WHERE counterparty_id IN (?, ?, ...) -- Batch of 100
```
- **Performance:** <5 seconds for 1000 transactions (10 batches)

**Query 4: List with Search**
```sql
SELECT * FROM counterparties
WHERE user_id = ? AND merged_into IS NULL
  AND (canonical_name ILIKE ? OR ? = ANY(aliases))
ORDER BY canonical_name ASC
LIMIT 50 OFFSET ?;
```
- **Index:** idx_user, idx_canonical, GIN on aliases
- **Performance:** <100ms

**Caching Strategy:**

- **Cache Key:** `counterparties:{user_id}:active`
- **TTL:** 10 minutes (longer than Account due to larger dataset)
- **Invalidation:** On create/update/merge operation
- **Benefit:** Repeated GET /api/counterparties served from cache

**Performance Targets:**

| Operation | Target p95 Latency |
|-----------|--------------------|
| GET /api/counterparties | <100ms |
| POST /api/counterparties | <200ms |
| PUT /api/counterparties/{id} | <150ms |
| POST /api/counterparties/merge (100 txns) | <2s |
| GET /api/counterparties/suggest-duplicates | <1s |

---

### 18. Observability

**Metrics to Track:**

1. **Request Metrics:**
   - `counterparty.create.requests` (counter)
   - `counterparty.merge.requests` (counter)
   - `counterparty.fuzzy_match.requests` (counter)
   - `counterparty.merge.duration` (histogram)

2. **Counterparty Count Metrics:**
   - `counterparties.total` (gauge)
   - `counterparties.active` (gauge)
   - `counterparties.merged` (gauge)
   - `counterparties.per_user.avg` (gauge)

3. **Fuzzy Match Metrics:**
   - `counterparty.fuzzy_match.hits` (counter)
   - `counterparty.fuzzy_match.misses` (counter)
   - `counterparty.fuzzy_match.user_overrides` (counter)
   - `counterparty.fuzzy_match.score` (histogram)

4. **Merge Metrics:**
   - `counterparty.merge.transactions_migrated` (histogram)
   - `counterparty.merge.aliases_merged` (histogram)
   - `counterparty.merge.errors` (counter)

**Logs to Emit:**

```json
{
  "timestamp": "2025-05-20T10:00:00Z",
  "level": "info",
  "event": "counterparty.created",
  "user_id": "user_darwin",
  "counterparty_id": "cpty_openai_1",
  "canonical_name": "[REDACTED]",
  "type": "merchant",
  "aliases_count": 1,
  "source": "normalization"
}
```

**Dashboards:**

1. **Counterparty Operations**
   - Total counterparties created (last 7 days)
   - Active vs merged (pie chart)
   - Fuzzy match hit rate
   - User override rate (% of suggestions rejected)

2. **Merge Analytics**
   - Merges per day
   - Average transactions migrated per merge
   - Merge latency (p50, p95, p99)

3. **Duplicate Detection**
   - Duplicate suggestions presented
   - Duplicate suggestions accepted
   - False positive rate (user feedback)

**Alerts:**

1. **High User Override Rate:**
   - Condition: `counterparty.fuzzy_match.user_overrides > 20%`
   - Severity: Warning
   - Action: Review fuzzy matching threshold, tune algorithm

2. **Slow Merge Operation:**
   - Condition: `counterparty.merge.duration p95 > 10s`
   - Severity: Warning
   - Action: Check database performance, consider batch size optimization

3. **Transaction Count Drift:**
   - Condition: `ABS(transaction_count - actual_count) > 10%`
   - Severity: Critical
   - Action: Run reconciliation job, investigate drift cause

---

### 19. Testing Strategy

**Unit Tests:**

```python
# Test: CounterpartyStore.find_or_create()
def test_find_or_create_exact_match():
    """Exact alias match returns existing counterparty"""

def test_find_or_create_fuzzy_match_high_confidence():
    """Fuzzy match score > 0.90 auto-links to existing"""

def test_find_or_create_no_match():
    """No match creates new counterparty"""

# Test: CounterpartyMatcher.fuzzy_match()
def test_fuzzy_match_levenshtein():
    """'UBER EATS' matches 'Uber Eats' with score > 0.90"""

def test_fuzzy_match_token_based():
    """'UBER *1234' matches 'Uber' with score > 0.85"""

# Test: AliasMerger.merge()
def test_merge_two_counterparties():
    """Merge A + B → A, all B transactions migrated"""

def test_merge_with_alias_deduplication():
    """Merge with duplicate aliases de-duplicates"""

def test_merge_transaction_count_updated():
    """transaction_count = sum of merged counts"""
```

**Integration Tests:**

```python
def test_full_merge_flow():
    # Create 3 counterparties
    cpty1 = create_counterparty("OpenAI", ["OPENAI"])
    cpty2 = create_counterparty("OpenAI Inc", ["OPENAI INC"])
    cpty3 = create_counterparty("OPENAI*", ["OPENAI*"])

    # Create transactions
    create_transaction(counterparty=cpty1)  # 5 txns
    create_transaction(counterparty=cpty2)  # 3 txns
    create_transaction(counterparty=cpty3)  # 2 txns

    # Merge
    response = client.post("/api/counterparties/merge", json={
        "primary_id": cpty1.counterparty_id,
        "merge_ids": [cpty2.counterparty_id, cpty3.counterparty_id]
    })

    # Verify
    assert response.status_code == 200
    assert response.json["primary_counterparty"]["transaction_count"] == 10
    assert len(response.json["primary_counterparty"]["aliases"]) == 3
```

**E2E Tests:**

```typescript
test("User can merge duplicate counterparties", async () => {
  // Setup: Create 2 counterparties
  await createCounterparty({name: "OpenAI", type: "merchant"});
  await createCounterparty({name: "OpenAI Inc", type: "merchant"});

  // Navigate to counterparty list
  await page.goto("/counterparties");

  // Select both
  await page.click("input[type='checkbox'][value='cpty_openai_1']");
  await page.click("input[type='checkbox'][value='cpty_openai_inc_2']");

  // Click merge
  await page.click("button:has-text('Merge Selected')");

  // Confirm in dialog
  await page.click("button:has-text('Merge Counterparties')");

  // Verify success
  await expect(page.locator("text=Successfully merged 2 counterparties")).toBeVisible();
  await expect(page.locator("text=OpenAI Inc")).not.toBeVisible();
});
```

---

### 20. Operations Runbook

**Deployment:**

1. Run database migration: `migrate up 004_create_counterparties_table`
2. Add GIN index on aliases: `CREATE INDEX idx_aliases ON counterparties USING GIN(aliases);`
3. Add trigram extension: `CREATE EXTENSION IF NOT EXISTS pg_trgm;`
4. Deploy backend API
5. Deploy frontend UI
6. Monitor fuzzy match accuracy for 24 hours

**Common Issues:**

**Issue 1: Fuzzy Match Too Aggressive (False Positives)**
- **Symptom:** Users frequently override fuzzy match suggestions
- **Resolution:** Increase threshold from 0.90 to 0.95
- **Command:** `UPDATE config SET value = 0.95 WHERE key = 'fuzzy_match_threshold'`

**Issue 2: Slow Alias Search (GIN Index Not Used)**
- **Symptom:** Alias search takes >1s
- **Resolution:** Verify GIN index exists: `EXPLAIN SELECT * FROM counterparties WHERE 'UBER' = ANY(aliases)`
- **Expected:** Index Scan using idx_aliases

**Issue 3: Transaction Count Drift**
- **Symptom:** transaction_count doesn't match actual COUNT(*)
- **Resolution:** Run reconciliation: `UPDATE counterparties SET transaction_count = (SELECT COUNT(*) FROM canonical_transactions WHERE ...)`

**Scaling:**
- Current: <10,000 counterparties per user
- Future (1M users): Shard by user_id, add read replicas

---

**End of Vertical 3.2 Specification**

**Progress:** 8/23 verticals complete (35%)
**Next:** 3.3 Series Registry (recurring payments)
