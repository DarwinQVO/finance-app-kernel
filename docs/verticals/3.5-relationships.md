# Vertical 3.5: Relationships (Transaction-to-Transaction Linking)

> **Type:** Relationship Registry + Paired Record Linking System
> **Pattern:** Paired Record Linking + Confidence Scoring + Graph Traversal
> **Last Updated:** 2025-10-24

---

## 📋 Overview

The **Relationships** vertical provides a **transaction-to-transaction linking system** for detecting and managing relationships between paired records. While demonstrated in finance domain (transfers, FX conversions, reimbursements), the underlying primitives are domain-agnostic and apply to ANY paired record linking scenario.

**Key Characteristics:**
- **Auto-Detection:** Rule-based matching with confidence scoring (same amount ±5%, opposite signs, ±7 days)
- **Relationship Types:** 6 types (transfer, fx_conversion, reimbursement, split, correction, other)
- **Confidence Scoring:** 0.0-1.0 scale based on amount match, date proximity, account differences
- **Analytics Exclusion:** Prevent double-counting in reports (exclude transfers from income/expense totals)
- **FX Tracking:** Exchange rate calculation, gain/loss tracking, multi-currency support
- **Audit Trail:** Complete link/unlink history with provenance

**Finance Domain Examples:**
- **Transfers:** Moving money between own accounts (BofA Checking → Wise USD)
- **FX Conversions:** Currency exchanges (Wise USD $1,000 → Wise MXN $18,500, rate: 18.5)
- **Reimbursements:** Personal expense → employer reimbursement (different amounts allowed)
- **Splits:** Single bill split across multiple cards ($60 + $40 = $100 total)

**Multi-Domain Applicability:**
- **Healthcare:** Claim ↔ Payment linking, Referral ↔ Visit relationships, Prescription ↔ Refill chains
- **Legal:** Case ↔ Sub-case relationships, Document ↔ Amendment versions, Billing ↔ Payment reconciliation
- **Research:** Paper ↔ Citation networks, Dataset ↔ Derived dataset lineage, Experiment ↔ Replication chains
- **E-commerce:** Order ↔ Return linking, Refund ↔ Original payment, Order ↔ Split shipments

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Auto-detect transfer pairs (same amount, opposite accounts, ±7 days)
- FX conversion tracking with exchange rate calculation
- Manual relationship creation (6 types)
- Confidence scoring (0.0-1.0 scale)
- Analytics exclusion (prevent double-counting transfers)
- Relationship unlink operations
- Chain transfer visualization (BofA → Wise USD → Wise MXN → Scotia)
- Multiple candidate handling (3 matching transactions → user picks)
- Audit trail for all link/unlink operations

**Out of Scope:**
- Tax implications of transfers (covered in 3.4 Tax Categorization)
- Account balance reconciliation (covered in future 4.x Balance Engine)
- Multi-party transfers (user1 → user2, requires payment network)
- Blockchain transaction linking (different technical domain)
- Real-time transfer detection (batch processing only)

**Boundaries:**
- One transaction can be in at most ONE relationship (no overlapping links)
- Relationships are bidirectional (txn_1 ↔ txn_2, order doesn't matter)
- Confidence scoring is point-in-time (not re-calculated after creation)
- Deleted relationships are soft-deleted (deleted_at timestamp, preserved for audit)
- FX rates are user-transaction-specific (not global market rates)

---

### 2. User Flow (Real Usage)

**Scenario 1: Auto-detect transfer on bank statement upload**

User: "I uploaded my BofA statement showing a transfer to Wise, then uploaded my Wise statement"

System:
1. User uploads BofA statement (2025-10-15)
   - Parser extracts: `Date: 2025-10-15 | Account: BofA Checking | Amount: -$1,000 | Desc: "Transfer to Wise"`
2. Normalizer creates canonical transaction `txn_001` (vertical 1.3)
3. No relationships yet (only one side of transfer exists)
4. User uploads Wise statement (same day)
   - Parser extracts: `Date: 2025-10-15 | Account: Wise USD | Amount: +$1,000 | Desc: "Deposit from BofA"`
5. Normalizer creates `txn_002`
6. **TransferDetector.detect_on_upload(txn_002)** runs automatically
7. Finds candidate match:
   - ✅ Same amount ($1,000)
   - ✅ Opposite signs (- vs +)
   - ✅ Different accounts (BofA vs Wise)
   - ✅ Same user (user_darwin)
   - ✅ Same date (0 days apart)
   - **Confidence: 0.95** (very high)
8. User sees notification in UI:
   ```
   ┌─────────────────────────────────────────────────────────┐
   │ 🔗 Transfer Detected                                    │
   ├─────────────────────────────────────────────────────────┤
   │                                                         │
   │ From: BofA Checking  -$1,000  (2025-10-15)             │
   │ To:   Wise USD       +$1,000  (2025-10-15)             │
   │                                                         │
   │ Confidence: 95%                                         │
   │                                                         │
   │ [Link as Transfer]  [Dismiss]                          │
   └─────────────────────────────────────────────────────────┘
   ```
9. User clicks "Link as Transfer"
10. System creates relationship:
    ```json
    {
      "relationship_id": "rel_001",
      "user_id": "user_darwin",
      "txn_1_id": "txn_001",
      "txn_2_id": "txn_002",
      "type": "transfer",
      "confidence": 0.95,
      "detection_method": "auto",
      "linked_at": "2025-10-15T14:30:00Z"
    }
    ```
11. Both transactions now show "🔗 Linked Transfer" badge
12. Analytics exclude both from income/expense totals (prevent double-counting)

**Scenario 2: FX conversion with exchange rate tracking**

User: "I converted $1,000 USD to Mexican Pesos in my Wise account"

System:
1. User uploads Wise statement (2025-10-16)
   - Transaction 1: `Date: 2025-10-16 | Account: Wise USD | Amount: -$1,000 | Desc: "Convert to MXN"`
   - Transaction 2: `Date: 2025-10-16 | Account: Wise MXN | Amount: +$18,500 | Desc: "Converted from USD"`
2. Normalizer creates `txn_003` (USD) and `txn_004` (MXN)
3. **TransferDetector with FX mode** runs
4. Detects FX conversion:
   - ✅ Different currencies (USD vs MXN)
   - ✅ Same date (0 days apart)
   - ✅ Same institution (Wise)
   - ✅ Opposite signs (- vs +)
   - **Exchange rate calculated:** 18,500 / 1,000 = 18.5 MXN/USD
   - **Confidence: 0.98** (very high, same institution + same date)
5. User sees FX-specific suggestion:
   ```
   ┌─────────────────────────────────────────────────────────┐
   │ 💱 FX Conversion Detected                               │
   ├─────────────────────────────────────────────────────────┤
   │                                                         │
   │ From: Wise USD  -$1,000                                │
   │ To:   Wise MXN  +$18,500                               │
   │                                                         │
   │ Exchange Rate: 18.5 MXN/USD                            │
   │ Confidence: 98%                                         │
   │                                                         │
   │ [Link as FX Conversion]  [Dismiss]                     │
   └─────────────────────────────────────────────────────────┘
   ```
6. User clicks "Link as FX Conversion"
7. System creates relationship with FX details:
   ```json
   {
     "relationship_id": "rel_002",
     "user_id": "user_darwin",
     "txn_1_id": "txn_003",
     "txn_2_id": "txn_004",
     "type": "fx_conversion",
     "confidence": 0.98,
     "detection_method": "auto",
     "fx_details": {
       "from_currency": "USD",
       "to_currency": "MXN",
       "from_amount": 1000.00,
       "to_amount": 18500.00,
       "exchange_rate": 18.5,
       "rate_source": "calculated"
     },
     "linked_at": "2025-10-16T09:15:00Z"
   }
   ```
8. Transaction detail shows conversion:
   ```
   ┌─────────────────────────────────────────────────────────┐
   │ Transaction Detail: txn_003                             │
   ├─────────────────────────────────────────────────────────┤
   │                                                         │
   │ Date:     2025-10-16                                    │
   │ Account:  Wise USD                                      │
   │ Amount:   -$1,000.00                                    │
   │ Desc:     Convert to MXN                                │
   │                                                         │
   │ 💱 FX Conversion (18.5 MXN/USD)                         │
   │ ↓ Converted to: $18,500 MXN (txn_004)                  │
   │                                                         │
   └─────────────────────────────────────────────────────────┘
   ```

**Scenario 3: Manual link for reimbursement (different amounts)**

User: "I paid $47.32 for a client dinner, but my employer reimbursed me $50 (they round up)"

System:
1. User has two transactions:
   - txn_005: Personal Card -$47.32 (2025-10-10, "Client dinner - expense report")
   - txn_006: Business Checking +$50.00 (2025-10-20, "Expense reimbursement Oct")
2. **Auto-detection doesn't trigger** (amounts differ, 10-day delay)
3. User opens txn_005 detail → clicks "Link to Transaction" button
4. **TransferLinkDialog** opens:
   ```
   ┌─────────────────────────────────────────────────────────┐
   │ Link Transaction                                        │
   ├─────────────────────────────────────────────────────────┤
   │                                                         │
   │ Current Transaction:                                    │
   │ Personal Card  -$47.32  (2025-10-10)                   │
   │ "Client dinner - expense report"                        │
   │                                                         │
   │ Link to:                                                │
   │ ┌─────────────────────────────────────────────────┐    │
   │ │ Search transactions...                          │    │
   │ └─────────────────────────────────────────────────┘    │
   │                                                         │
   │ Relationship Type:                                      │
   │ ◉ Reimbursement                                         │
   │ ○ Transfer                                              │
   │ ○ FX Conversion                                         │
   │ ○ Split                                                 │
   │ ○ Other                                                 │
   │                                                         │
   │ Notes (optional):                                       │
   │ ┌─────────────────────────────────────────────────┐    │
   │ │ Employer rounds reimbursements to nearest $5    │    │
   │ └─────────────────────────────────────────────────┘    │
   │                                                         │
   │           [Cancel]  [Create Link]                       │
   └─────────────────────────────────────────────────────────┘
   ```
5. User searches "expense report" → finds txn_006
6. Selects "Reimbursement" type → adds notes → clicks "Create Link"
7. System creates relationship:
   ```json
   {
     "relationship_id": "rel_003",
     "user_id": "user_darwin",
     "txn_1_id": "txn_005",
     "txn_2_id": "txn_006",
     "type": "reimbursement",
     "confidence": null,
     "detection_method": "manual",
     "notes": "Employer rounds reimbursements to nearest $5",
     "linked_at": "2025-10-21T16:00:00Z",
     "linked_by": "user_darwin"
   }
   ```
8. Both transactions show link:
   - txn_005: "🔗 Reimbursed by txn_006"
   - txn_006: "🔗 Reimburses txn_005"

**Scenario 4: Unlink incorrect relationship**

User: "I accidentally linked the wrong transactions - need to unlink them"

System:
1. User opens transaction detail showing relationship
2. Clicks "Unlink" button in relationship card
3. Confirmation dialog appears:
   ```
   ┌─────────────────────────────────────────────────────────┐
   │ Unlink Transfer?                                        │
   ├─────────────────────────────────────────────────────────┤
   │                                                         │
   │ This will remove the transfer relationship between:     │
   │                                                         │
   │ • BofA Checking  -$1,000  (2025-10-15)                 │
   │ • Wise USD       +$1,000  (2025-10-15)                 │
   │                                                         │
   │ Both transactions will be counted separately in         │
   │ analytics again.                                        │
   │                                                         │
   │        [Cancel]  [Unlink Transactions]                  │
   └─────────────────────────────────────────────────────────┘
   ```
4. User confirms
5. System **soft deletes** relationship:
   ```json
   {
     "relationship_id": "rel_001",
     "deleted_at": "2025-10-22T10:00:00Z",
     "deleted_by": "user_darwin"
   }
   ```
6. Relationship removed from both transaction views
7. Analytics now count both transactions separately (no longer excluded)
8. Provenance ledger logs unlink operation for audit

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `RelationshipStore` - CRUD for transaction relationships (NEW - this vertical)
- `TransferDetector` - Auto-detect transfer pairs with confidence scoring (NEW - this vertical)
- `FXConverter` - Calculate exchange rates and FX gain/loss (NEW - this vertical)
- `RelationshipMatcher` - Fuzzy matching with configurable thresholds (NEW - this vertical)
- `TransactionStore` - Query transactions for matching (from 1.3)
- `ProvenanceLedger` - Log all link/unlink operations (from 1.1)
- `AccountStore` - Validate account ownership for transfer detection (from 3.1)

**Interaction Layer (IL):**
- `RelationshipPanel` - Display linked transactions in transaction detail (NEW - this vertical)
- `TransferLinkDialog` - Manual link creation dialog with search (NEW - this vertical)
- `FXConversionCard` - Display FX conversion details (rate, gain/loss) (NEW - this vertical)
- `TransactionList` - View transactions with relationship badges (from 2.1)
- `DrillDownPanel` - View relationship details in transaction drawer (from 2.2)

**Schemas:**
- `relationship.schema.json` - Relationship record definition (NEW - this vertical)
- `fx-details.schema.json` - FX conversion metadata (NEW - this vertical)
- `relationship-suggestion.schema.json` - Auto-detection suggestion (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# Get Relationships for Transaction
GET /api/transactions/{transaction_id}/relationships
Authorization: Bearer {token}

Response 200:
{
  "relationships": [
    {
      "relationship_id": "rel_001",
      "txn_1_id": "txn_001",
      "txn_2_id": "txn_002",
      "type": "transfer",
      "confidence": 0.95,
      "detection_method": "auto",
      "linked_at": "2025-10-15T14:30:00Z",
      "linked_transaction": {
        "transaction_id": "txn_002",
        "date": "2025-10-15",
        "account_name": "Wise USD",
        "amount": 1000.00,
        "description": "Deposit from BofA"
      }
    }
  ]
}
```

```http
# Suggest Relationship Candidates
POST /api/transactions/{transaction_id}/suggest-relationships
Authorization: Bearer {token}

Response 200:
{
  "suggestions": [
    {
      "candidate_txn_id": "txn_002",
      "suggested_type": "transfer",
      "confidence": 0.95,
      "reason": "Same amount, opposite signs, same date",
      "match_details": {
        "amount_match": 1.0,
        "date_diff_days": 0,
        "account_match": false
      },
      "candidate_transaction": {
        "date": "2025-10-15",
        "account_name": "Wise USD",
        "amount": 1000.00,
        "description": "Deposit from BofA"
      }
    },
    {
      "candidate_txn_id": "txn_003",
      "suggested_type": "transfer",
      "confidence": 0.80,
      "reason": "Similar amount (2% diff), 1-day delay",
      "match_details": {
        "amount_match": 0.98,
        "date_diff_days": 1,
        "account_match": false
      }
    }
  ],
  "total_suggestions": 2
}
```

```http
# Create Relationship (Manual Link)
POST /api/relationships
Authorization: Bearer {token}
Content-Type: application/json

{
  "txn_1_id": "txn_005",
  "txn_2_id": "txn_006",
  "type": "reimbursement",
  "notes": "Employer rounds reimbursements to nearest $5"
}

Response 201:
{
  "relationship_id": "rel_003",
  "user_id": "user_darwin",
  "txn_1_id": "txn_005",
  "txn_2_id": "txn_006",
  "type": "reimbursement",
  "confidence": null,
  "detection_method": "manual",
  "notes": "Employer rounds reimbursements to nearest $5",
  "linked_at": "2025-10-21T16:00:00Z",
  "linked_by": "user_darwin"
}

Response 400 (Already Linked):
{
  "error": "ALREADY_LINKED",
  "message": "Transaction txn_005 is already linked in relationship rel_002"
}

Response 400 (Same Transaction):
{
  "error": "INVALID_LINK",
  "message": "Cannot link transaction to itself"
}
```

```http
# Delete Relationship (Unlink)
DELETE /api/relationships/{relationship_id}
Authorization: Bearer {token}

Response 200:
{
  "relationship_id": "rel_001",
  "deleted_at": "2025-10-22T10:00:00Z",
  "deleted_by": "user_darwin",
  "message": "Relationship unlinked successfully"
}
```

```http
# Get Analytics with Transfer Exclusion
GET /api/analytics/transactions?
  date_from=2025-10-01&
  date_to=2025-10-31&
  exclude_transfers=true
Authorization: Bearer {token}

Response 200:
{
  "total_income": 5000.00,
  "total_expenses": 3000.00,
  "net": 2000.00,
  "excluded_transfers": 10,
  "excluded_transfer_volume": 8000.00
}
```

**Internal OL API:**

```python
class RelationshipStore:
    def create(
        self,
        user_id: str,
        txn_1_id: str,
        txn_2_id: str,
        type: RelationshipType,
        confidence: Optional[float] = None,
        detection_method: DetectionMethod = "manual",
        fx_details: Optional[FXDetails] = None,
        notes: Optional[str] = None
    ) -> Relationship:
        """
        Creates relationship between two transactions.

        Raises:
            AlreadyLinkedError: If either transaction already in relationship
            SameTransactionError: If txn_1_id == txn_2_id
            UnauthorizedError: If user doesn't own both transactions
            InvalidTypeError: If type not in supported types
        """

    def get(self, relationship_id: str) -> Optional[Relationship]:
        """Returns relationship by ID (None if deleted)."""

    def find_by_transaction(self, txn_id: str) -> List[Relationship]:
        """Returns all active relationships for transaction."""

    def unlink(self, relationship_id: str, user_id: str) -> None:
        """
        Soft deletes relationship.

        Raises:
            NotFoundError: If relationship doesn't exist
            UnauthorizedError: If user doesn't own relationship
        """

    def search(
        self,
        user_id: str,
        type: Optional[RelationshipType] = None,
        min_confidence: Optional[float] = None
    ) -> List[Relationship]:
        """Filters relationships by type and confidence."""


class TransferDetector:
    def detect_on_upload(self, txn_id: str) -> List[Candidate]:
        """
        Auto-detect transfer candidates for newly uploaded transaction.

        Algorithm:
        1. Query recent unlinked transactions (last 30 days)
        2. Filter by amount (within 5% of txn.amount)
        3. Filter by opposite sign (+ vs -)
        4. Filter by different account (same user)
        5. Calculate confidence for each candidate
        6. Return candidates with confidence >= 0.50

        Returns:
            List of Candidate objects sorted by confidence (descending)
        """

    def calculate_confidence(
        self,
        txn_1: Transaction,
        txn_2: Transaction
    ) -> float:
        """
        Calculate confidence score for transfer detection (0.0 to 1.0).

        Weights:
        - Amount match: 40% (0.40 for exact, 0.35 for 2% diff, 0.25 for 5% diff)
        - Date proximity: 30% (0.30 same day, 0.25 next day, 0.20 within 3 days)
        - Opposite signs: 20% (0.20 if opposite, 0.0 if same)
        - Account diff: 10% (0.10 if different accounts, 0.0 if same)

        Returns:
            Confidence score [0.0, 1.0]
        """

    def detect_batch(
        self,
        user_id: str,
        date_from: date,
        date_to: date
    ) -> Dict[str, List[Candidate]]:
        """Batch detection for historical transactions (background job)."""


class FXConverter:
    def calculate_rate(
        self,
        from_amount: Decimal,
        from_currency: str,
        to_amount: Decimal,
        to_currency: str
    ) -> Decimal:
        """
        Calculate exchange rate from transaction amounts.

        Example:
          from: $1,000 USD
          to:   $18,500 MXN
          rate: 18,500 / 1,000 = 18.5 MXN/USD

        Raises:
            ZeroAmountError: If from_amount == 0
        """

    def get_market_rate(
        self,
        date: date,
        from_currency: str,
        to_currency: str
    ) -> Optional[Decimal]:
        """
        Fetch market exchange rate from external API (e.g., Wise, ECB).

        Returns:
            Market rate on date, or None if unavailable
        """

    def calculate_fx_gain_loss(
        self,
        relationship: Relationship
    ) -> Optional[Decimal]:
        """
        Compare actual rate to market rate to calculate gain/loss.

        Example:
          Actual rate:  18.5 MXN/USD (from transaction)
          Market rate:  18.3 MXN/USD (from API on date)
          From amount:  $1,000 USD

          Expected:     1,000 * 18.3 = 18,300 MXN
          Actual:       18,500 MXN
          Gain:         +200 MXN ($10.93 USD)

        Returns:
            Gain/loss in to_currency, or None if market rate unavailable
        """


class RelationshipMatcher:
    def match(
        self,
        txn_1_id: str,
        txn_2_id: str,
        config: MatchConfig
    ) -> MatchResult:
        """
        Test if two transactions match based on configurable criteria.

        Config parameters:
        - amount_tolerance_pct: 0.05 (5%)
        - date_window_days: 7
        - min_confidence: 0.50
        - require_opposite_signs: True
        - require_different_accounts: True
        """

    def bulk_match(
        self,
        user_id: str,
        date_range: DateRange,
        config: MatchConfig
    ) -> List[MatchResult]:
        """Batch matching for bulk operations."""
```

---

### 5. Schemas / Tipos (Persistencia)

**Relationship Schema:**

```json
{
  "relationship_id": "rel_001",
  "user_id": "user_darwin",
  "txn_1_id": "txn_001",
  "txn_2_id": "txn_002",
  "type": "transfer",
  "confidence": 0.95,
  "detection_method": "auto",
  "fx_details": null,
  "notes": null,
  "linked_at": "2025-10-15T14:30:00Z",
  "linked_by": null,
  "deleted_at": null,
  "deleted_by": null
}
```

**FX Details Schema (embedded in Relationship when type = fx_conversion):**

```json
{
  "fx_details": {
    "from_currency": "USD",
    "to_currency": "MXN",
    "from_amount": 1000.00,
    "to_amount": 18500.00,
    "exchange_rate": 18.5,
    "rate_source": "calculated",
    "market_rate": 18.3,
    "fx_gain_loss": 200.00
  }
}
```

**Relationship Types:**
- `transfer` - Money moved between user's own accounts
- `fx_conversion` - Currency exchange with different amounts
- `reimbursement` - Expense paid personally, later reimbursed
- `split` - Single transaction split across multiple accounts
- `correction` - Adjustment or reversal of original transaction
- `other` - Custom relationship (requires notes)

**Detection Methods:**
- `auto` - Detected by TransferDetector (requires confidence score)
- `manual` - Created by user (confidence = null)

**Confidence Thresholds:**
- `≥0.90` - Auto-suggest with high confidence badge
- `0.70-0.89` - Auto-suggest with medium confidence badge
- `0.50-0.69` - Show in "Possible Matches" list
- `<0.50` - Don't suggest (manual link only)

---

### 6. Validaciones & Estados

**Create Relationship Validations:**
- txn_1_id != txn_2_id (cannot link transaction to itself)
- Both transactions exist and belong to user_id
- Neither transaction already in active relationship (1:1 constraint)
- Type must be valid (transfer, fx_conversion, reimbursement, split, correction, other)
- If type = fx_conversion, currencies must differ
- If detection_method = auto, confidence required (0.0-1.0)
- If detection_method = manual, confidence must be null
- Notes: max 500 chars

**Unlink Validations:**
- Relationship must exist
- User must own relationship (user_id match)
- Relationship not already deleted (deleted_at is null)

**Confidence Score Validation:**
- Must be [0.0, 1.0] if present
- Auto-detected links require confidence
- Manual links must have null confidence

**State Machine (Relationship Lifecycle):**
```
┌──────────────────────────────────────────────────────────┐
│                   Relationship States                    │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  [Suggested] ─────────────────────────────────┐         │
│       ↓                                        │         │
│       User accepts                             │         │
│       ↓                                        │         │
│  [Active] ────────────────────────────────────┼─────▶   │
│       ↓                                        │         │
│       User unlinks                             │         │
│       ↓                                        │         │
│  [Deleted] (soft delete, deleted_at != NULL)  │         │
│                                                │         │
│  Alternative: User dismisses suggestion ───────┘         │
│  (no record created, log dismissal)                      │
└──────────────────────────────────────────────────────────┘
```

**State Transitions:**

| From State | Action | To State | Side Effects |
|------------|--------|----------|--------------|
| **None** | Auto-detection finds match | **Suggested** | Show UI notification |
| **Suggested** | User accepts | **Active** | Create relationship record, update both txn views, log to provenance |
| **Suggested** | User dismisses | **None** | Log dismissal (prevent re-suggesting same pair) |
| **Active** | User unlinks | **Deleted** | Soft delete (deleted_at), update both txn views, log to provenance |

---

### 7. Edge Cases

**EC1: Amount mismatch due to transfer fees**
- **Problem:** BofA -$1,000 vs Wise +$998 (Wise fee $2)
- **Detection:** Amount differs by 2% → Confidence: 0.80 (still suggested)
- **UI Warning:** "⚠️ Amount Mismatch ($2 difference) - This may be due to transfer fees"
- **User Actions:**
  - Option 1: Link anyway (most common)
  - Option 2: Create separate fee transaction (advanced users)

**EC2: Delayed transfers (processing time)**
- **Problem:** BofA transfer on 10/15, Wise deposit on 10/19 (4-day delay)
- **Detection:** Date diff: 4 days (within 7-day window) → Confidence: 0.85
- **Still auto-suggested** (many banks have 3-5 day processing)
- **UI Note:** "4-day delay detected (common for international transfers)"

**EC3: Multiple candidates (3 matching transactions)**
- **Problem:** Three $100 transactions on same day
- **Detection:** Finds all 3 as candidates
- **UI:** Show list with radio buttons:
  ```
  🔗 Potential Transfers Found

  BofA Checking  -$100  (2025-10-15)

  Could be linked to:
  ☐ Wise USD       +$100  (2025-10-15)  Confidence: 95%
  ☐ Chase Savings  +$100  (2025-10-15)  Confidence: 95%
  ☐ Venmo         +$100  (2025-10-15)  Confidence: 90%

  [Link Selected] [Dismiss]
  ```
- **User picks correct one** (system can't auto-determine)

**EC4: Chain transfers (multi-hop)**
- **Problem:** BofA → Wise USD → Wise MXN → Scotia (4 transactions)
- **Solution:** Create relationships pairwise:
  - rel_001: BofA ↔ Wise USD (transfer)
  - rel_002: Wise USD ↔ Wise MXN (fx_conversion)
  - rel_003: Wise MXN ↔ Scotia (transfer)
- **UI Visualization:**
  ```
  Transfer Chain:
  BofA Checking ──▶ Wise USD ──▶ Wise MXN ──▶ Scotia MXN
    $1,000          $1,000       $18,500        $18,500
                              (rate: 18.5)
  ```

**EC5: Split transactions (multiple cards)**
- **Problem:** Dinner bill split: Personal Card -$60 + Work Visa -$40 = -$100 total
- **Solution:** Create "split" type relationship with multiple transaction IDs
- **Schema Extension:**
  ```json
  {
    "relationship_id": "rel_004",
    "type": "split",
    "txn_ids": ["txn_007", "txn_008"],
    "total_amount": 100.00,
    "notes": "Split dinner bill 60/40"
  }
  ```
- **Validation:** Sum of all transaction amounts must equal total_amount

**EC6: Already linked (prevent duplicate links)**
- **Problem:** Transaction already in relationship, user tries to link again
- **Validation:**
  ```python
  def validate_link(txn_id: str) -> None:
      existing = db.query("""
          SELECT * FROM relationships
          WHERE (txn_1_id = :txn_id OR txn_2_id = :txn_id)
            AND deleted_at IS NULL
      """, txn_id=txn_id)

      if existing:
          raise AlreadyLinkedException(
              f"Transaction {txn_id} already linked in relationship {existing.relationship_id}"
          )
  ```
- **Error Message:**
  ```
  ❌ Cannot Link Transaction

  This transaction is already linked:
  • Existing: Transfer to Wise USD (rel_001)

  Unlink the existing relationship first.
  ```

**EC7: Factura amount doesn't match transaction (finance-specific)**
- **Problem:** Partial transfers or rounding differences
- **Solution:** Allow link with warning if variance < 5%
- **UI:** "⚠️ Amount variance: $2.00 (0.2%) - Link anyway?"

**EC8: FX conversion with missing market rate**
- **Problem:** External API unavailable to fetch market rate
- **Fallback:** Use calculated rate from transaction amounts
- **UI:** "ℹ️ Market rate unavailable - using transaction rate (18.5 MXN/USD)"

---

### 8. Acceptance Criteria (Definition of Done)

**Auto-Detection:**
- [ ] System detects transfer pairs on transaction upload (same amount ±5%, opposite signs, ±7 days)
- [ ] System calculates confidence score (0.0-1.0) based on amount match, date proximity, account diff
- [ ] System suggests candidates with confidence ≥ 0.50
- [ ] User sees notification with "Link as Transfer" / "Dismiss" options
- [ ] Auto-detection runs asynchronously (doesn't block normalization)

**Manual Linking:**
- [ ] User can manually link any two transactions (regardless of confidence)
- [ ] User can select relationship type (transfer, fx_conversion, reimbursement, split, correction, other)
- [ ] User can add notes to relationship (max 500 chars)
- [ ] User can search for transaction to link (by date, amount, description)
- [ ] System validates: not same transaction, not already linked, user owns both

**FX Conversion:**
- [ ] System detects FX conversions (different currencies, opposite signs, same date)
- [ ] System calculates exchange rate (to_amount / from_amount)
- [ ] System stores rate in fx_details JSONB field
- [ ] User can view exchange rate in transaction detail
- [ ] System fetches market rate from external API (optional)
- [ ] System calculates FX gain/loss by comparing actual vs market rate

**Unlinking:**
- [ ] User can unlink relationship from either transaction
- [ ] System soft deletes relationship (deleted_at timestamp)
- [ ] Both transactions revert to unlinked state
- [ ] Analytics re-include transactions after unlink
- [ ] System logs unlink operation to provenance ledger

**Analytics Integration:**
- [ ] Dashboard excludes transfers by default (exclude_transfers=true)
- [ ] User can toggle "Include Transfers" in dashboard settings
- [ ] System provides separate "Transfers" report widget
- [ ] Exclusion query filters: `WHERE type NOT IN ('transfer', 'fx_conversion')`

**Multi-Domain:**
- [ ] Pattern applies to Healthcare (Claim ↔ Payment linking, confidence scoring)
- [ ] Pattern applies to Legal (Case ↔ Sub-case relationships, document version linking)
- [ ] Pattern applies to Research (Paper ↔ Citation networks, dataset lineage)
- [ ] Pattern applies to E-commerce (Order ↔ Return linking, refund tracking)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "relationship_created",
  "relationship_id": "rel_001",
  "user_id": "user_darwin",
  "txn_1_id": "txn_001",
  "txn_2_id": "txn_002",
  "type": "transfer",
  "detection_method": "auto",
  "confidence": 0.95,
  "timestamp": "2025-10-15T14:30:00Z"
}
```

```json
{
  "event": "relationship_suggested",
  "txn_id": "txn_002",
  "candidate_txn_id": "txn_001",
  "suggested_type": "transfer",
  "confidence": 0.95,
  "user_id": "user_darwin",
  "timestamp": "2025-10-15T14:28:00Z"
}
```

```json
{
  "event": "relationship_deleted",
  "relationship_id": "rel_001",
  "user_id": "user_darwin",
  "deleted_by": "user_darwin",
  "reason": "user_initiated",
  "timestamp": "2025-10-22T10:00:00Z"
}
```

```json
{
  "event": "fx_conversion_detected",
  "relationship_id": "rel_002",
  "from_currency": "USD",
  "to_currency": "MXN",
  "exchange_rate": 18.5,
  "from_amount": 1000.00,
  "to_amount": 18500.00,
  "timestamp": "2025-10-16T09:15:00Z"
}
```

**Provenance Chain:**
```
Transaction Normalized (1.3)
  ↓
TransferDetector.detect_on_upload() (3.5)
  ↓
Candidate Suggestions Generated
  ↓
User Reviews Suggestion (IL)
  ↓
User Accepts → RelationshipStore.create() (OL)
  ↓
Relationship Record Created
  ↓
ProvenanceLedger.append() (1.1)
  ↓
Analytics Queries Updated (exclude transfers)
```

**Audit Trail:**
- All link operations logged with user_id + timestamp
- All unlink operations logged with reason
- All suggestion accept/dismiss events logged
- Complete history preserved even after soft delete (deleted_at != null)

---

### 10. Risks & Deferred

**Risks:**
- **R1: False positive suggestions** - Auto-detect links unrelated transactions
  - **Mitigation:** Confidence threshold (≥0.70 for auto-suggest), user can dismiss/ignore
- **R2: Performance degradation** - Candidate search expensive for users with 10,000+ transactions
  - **Mitigation:** Limit search window (30 days), index on (user_id, date, amount), background jobs
- **R3: Multi-party transfers** - User sends money to another user (not own accounts)
  - **Mitigation:** Out of scope for now (requires payment network integration), defer to v2

**Deferred:**
- **D1: Real-time detection** - Current: batch processing on upload, Future: websocket notifications
- **D2: ML-based matching** - Current: rule-based only, Future: train model on user accept/dismiss patterns
- **D3: Multi-transaction splits** - Current: binary relationships (2 transactions), Future: N-way splits
- **D4: Blockchain linking** - Crypto wallet transactions, requires external API integration

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 4 new primitives:**

1. **RelationshipStore** - CRUD for transaction relationships
   - File: `docs/primitives/ol/RelationshipStore.md`
   - Methods: create, get, find_by_transaction, unlink, search
   - Responsibilities: Relationship persistence, validation, soft delete
   - Storage: PostgreSQL table `relationships`

2. **TransferDetector** - Auto-detect transfer pairs
   - File: `docs/primitives/ol/TransferDetector.md`
   - Methods: detect_on_upload, detect_batch, calculate_confidence
   - Responsibilities: Candidate matching, confidence scoring, suggestion generation
   - Algorithm: Amount match (40%), date proximity (30%), opposite signs (20%), account diff (10%)

3. **FXConverter** - Calculate exchange rates and FX gain/loss
   - File: `docs/primitives/ol/FXConverter.md`
   - Methods: calculate_rate, get_market_rate, calculate_fx_gain_loss
   - Responsibilities: Exchange rate calculation, market rate fetching, gain/loss tracking
   - External API: Wise, ECB, or user-configured rate provider

4. **RelationshipMatcher** - Fuzzy matching with configurable thresholds
   - File: `docs/primitives/ol/RelationshipMatcher.md`
   - Methods: match, bulk_match
   - Responsibilities: Configurable matching criteria, batch operations
   - Configuration: MatchConfig (amount_tolerance_pct, date_window_days, min_confidence)

**Interaction Layer (IL) - 3 new components:**

5. **RelationshipPanel** - Display linked transactions in detail view
   - File: `docs/primitives/il/RelationshipPanel.md`
   - Features: Relationship type icon (🔗 transfer, 💱 FX, 💰 reimburse), linked txn summary, confidence score, unlink button
   - Responsibilities: Relationship visualization, navigation to linked transaction

6. **TransferLinkDialog** - Manual link creation dialog
   - File: `docs/primitives/il/TransferLinkDialog.md`
   - Features: Transaction search, relationship type selector, notes field, preview, validation
   - Responsibilities: Manual link UI, search interface, validation feedback

7. **FXConversionCard** - Display FX conversion details
   - File: `docs/primitives/il/FXConversionCard.md`
   - Features: Exchange rate display, from/to currencies, market rate comparison, FX gain/loss
   - Responsibilities: FX-specific visualization, rate comparison

**Schemas - 3 new:**

8. **relationship.schema.json** - Relationship record definition
9. **fx-details.schema.json** - FX conversion metadata (embedded in relationship)
10. **relationship-suggestion.schema.json** - Auto-detection suggestion

**Reused Primitives from Previous Verticals:**
- **ProvenanceLedger** (1.1) - Log all link/unlink operations
- **CanonicalStore** (1.3) - Query transactions for matching
- **AccountStore** (3.1) - Validate account ownership
- **CounterpartyStore** (3.2) - Not directly used, but relationships can link transactions with same counterparty

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **1.1 Provenance** - Log all link/unlink operations
- **1.3 Normalization** - Transactions must be normalized before detection
- **2.1 Transaction List** - Relationship badges shown in transaction list
- **3.1 Account Registry** - Validate account ownership for transfer detection

**Used By:**
- **2.2 Query Builder** - Filter by relationship type (show only transfers)
- **2.3 Finance Dashboard** - Exclude transfers from income/expense totals
- **4.2 Forecast** - FX conversion history used for currency exchange predictions
- **Future: 4.x Balance Engine** - Account balance reconciliation across linked transfers

**Data Flow:**
```
Transaction Normalized (1.3)
  ↓
TransferDetector checks for candidates (3.5)
  ├─ Query AccountStore (3.1) - validate ownership
  └─ Query CanonicalStore (1.3) - find matching transactions
  ↓
Suggestion presented via RelationshipPanel (IL)
  ↓
User accepts/rejects
  ↓
RelationshipStore.create() (OL)
  ↓
ProvenanceLedger.append() (1.1)
  ↓
Dashboard excludes transfers (2.3)
```

**Circular Dependencies:**
- None (3.5 is leaf node in dependency graph)

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Paired Record Linking + Confidence Scoring**

This pattern applies to **any domain with related record pairs that need linking**:

**Finance (this vertical):**
- Entity Pairs: Transaction ↔ Transaction
- Relationship Types: Transfer, FX conversion, Reimbursement, Split
- Matching Criteria: Amount (±5%), Date (±7 days), Opposite signs, Different accounts
- Confidence Scoring: Amount match (40%), Date proximity (30%), Opposite signs (20%), Account diff (10%)
- Use Case: Transfer detection, FX tracking, double-counting prevention

**Healthcare:**
- Entity Pairs: Claim ↔ Payment, Referral ↔ Visit, Prescription ↔ Refill
- Relationship Types: Reimbursement, Referral, Refill, Denial
- Matching Criteria: Claim ID, Patient ID, Date range (±60 days), Amount match (±10%)
- Confidence Scoring: ID match (50%), Amount match (30%), Date proximity (20%)
- Use Case: Insurance claim tracking, referral networks, prescription refill chains

**Legal:**
- Entity Pairs: Case ↔ Sub-case, Document ↔ Amendment, Billing ↔ Payment
- Relationship Types: Parent-child, Version, Payment
- Matching Criteria: Case number, Client ID, Date filed, Fee amount
- Confidence Scoring: ID match (60%), Date proximity (20%), Amount match (20%)
- Use Case: Case hierarchy, document version control, billing reconciliation

**Research:**
- Entity Pairs: Paper ↔ Cited Paper, Dataset ↔ Derived Dataset, Experiment ↔ Replication
- Relationship Types: Citation, Lineage, Replication, Derivative
- Matching Criteria: DOI, Author overlap, Publication date, Topic similarity
- Confidence Scoring: DOI match (70%), Author overlap (15%), Topic similarity (15%)
- Use Case: Citation networks, dataset lineage tracking, reproducibility analysis

**E-commerce:**
- Entity Pairs: Order ↔ Return, Refund ↔ Original Payment, Order ↔ Shipment
- Relationship Types: Return, Refund, Shipment, Exchange
- Matching Criteria: Order ID, Customer ID, Amount match (±10%), Date range (±30 days)
- Confidence Scoring: Order ID match (60%), Amount match (25%), Date proximity (15%)
- Use Case: Return processing, refund tracking, split shipment management

**Key Abstraction:**
```python
class PairedRecordLinker:
    """
    Universal pattern for linking related records with confidence scoring.

    Generic enough to apply across:
    - Finance: Transaction ↔ Transaction (transfers, FX)
    - Healthcare: Claim ↔ Payment (insurance reimbursement)
    - Legal: Case ↔ Sub-case (case hierarchy)
    - Research: Paper ↔ Citation (citation networks)
    - E-commerce: Order ↔ Return (return processing)
    """
    entity_1: Entity
    entity_2: Entity
    relationship_type: str
    confidence: float  # [0.0, 1.0]
    detection_method: str  # "auto" or "manual"
    metadata: Optional[dict]  # Type-specific details (FX rate, claim ID, etc.)

    def calculate_confidence(
        self,
        match_criteria: List[Criterion]
    ) -> float:
        """
        Calculate confidence based on weighted criteria.

        Example criteria:
        - Amount match: weight=0.40, score=1.0 (exact match)
        - Date proximity: weight=0.30, score=0.90 (1 day apart)
        - ID match: weight=0.50, score=1.0 (exact match)
        """

    def detect_candidates(
        self,
        entity: Entity,
        search_window: DateRange,
        match_config: MatchConfig
    ) -> List[Candidate]:
        """Find potential matches within search window."""

    def link(self, entity_1_id: str, entity_2_id: str) -> Relationship:
        """Create relationship between entities."""

    def unlink(self, relationship_id: str) -> None:
        """Soft delete relationship."""
```

**Domain-Agnostic Components:**
- **MatchConfig** - Configurable thresholds (amount_tolerance, date_window, min_confidence)
- **Candidate** - Potential match with confidence score and match details
- **Relationship** - Link between two entities with type and metadata
- **ConfidenceCalculator** - Weighted scoring based on multiple criteria

---

### 14. Pattern Abstraction

**Pattern Name:** Paired Record Linking + Confidence Scoring

**Problem Statement:**
Systems need to detect and manage relationships between paired records (transfers, reimbursements, citations, returns) with varying degrees of certainty. Manual linking is time-consuming; auto-detection must balance accuracy (high confidence threshold) with coverage (low threshold).

**Solution Architecture:**

1. **Auto-Detection with Confidence Scoring**
   - Define matching criteria (amount, date, IDs, etc.)
   - Assign weights to each criterion (e.g., amount=40%, date=30%)
   - Calculate confidence score [0.0, 1.0]
   - Suggest candidates above threshold (e.g., ≥0.70)

2. **Manual Override**
   - Allow users to link any two records (regardless of confidence)
   - Store detection_method = "manual" (confidence = null)
   - Support custom relationship types

3. **Graph Traversal**
   - Support chains (A → B → C → D)
   - Visualize relationship networks
   - Prevent cycles (A → B → A)

4. **Soft Delete + Audit Trail**
   - Never hard delete relationships (compliance requirement)
   - Log all link/unlink operations
   - Track who linked and when

**Components:**

- **Detector** - Auto-detect candidate pairs based on matching criteria
- **ConfidenceCalculator** - Score candidates using weighted criteria
- **RelationshipStore** - Persist relationships with metadata
- **Matcher** - Configurable fuzzy matching (thresholds, tolerances)
- **GraphTraverser** - Navigate relationship chains

**When to Use:**
- ✅ Need to link related records (transfers, claims, citations, returns)
- ✅ Uncertainty in matching (confidence scoring needed)
- ✅ Both auto-detection and manual override required
- ✅ Audit trail for compliance
- ✅ Analytics need to exclude linked pairs (prevent double-counting)
- ❌ Simple foreign key relationships (use database constraints)
- ❌ Always 100% certain matches (no confidence needed)
- ❌ One-to-many relationships (use foreign key)

**Performance Considerations:**
- Index on matching fields (amount, date, IDs)
- Limit search window (e.g., last 30 days)
- Background jobs for batch detection
- Cache relationship lookups (TTL: 5 minutes)

---

### 15. Métricas de Madurez

**Coverage Metrics:**
- % of eligible transaction pairs linked (target: >70%)
- % of transfers excluded from analytics (target: 100%)
- % of FX conversions with calculated rates (target: >90%)
- Manual link ratio (target: <10% of total links)

**Quality Metrics:**
- Auto-detection accuracy (user acceptance rate, target: >70%)
- False positive rate (dismissed suggestions / total suggestions, target: <10%)
- Confidence score distribution (should cluster >0.80 and <0.60, not 0.60-0.80)
- Unlink rate (unlinks / total links, target: <5%)

**Performance Metrics:**
- Auto-detect latency (target: <200ms p95)
- Manual link creation latency (target: <150ms p95)
- Relationship query latency (target: <50ms p95)
- Analytics exclusion query latency (target: <300ms p95)

**User Engagement:**
- % users who accept auto-suggestions (target: >60%)
- Avg suggestions per upload (target: 0.5-1.0, indicates good detection)
- % users who manually link (target: >20%, indicates power user adoption)
- Avg time to accept suggestion (target: <30 seconds, indicates clear UI)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All operations require valid bearer token
- Users can only link their own transactions (user_id validation)
- Relationships are user-scoped (cannot link transactions across users)
- Soft delete preserves audit trail (deleted relationships still query-able by admins)

**Input Validation:**
- txn_1_id format: `txn_[a-zA-Z0-9]{8,}`
- txn_2_id format: `txn_[a-zA-Z0-9]{8,}`
- Type: must be in `[transfer, fx_conversion, reimbursement, split, correction, other]`
- Confidence: [0.0, 1.0] if detection_method = "auto", null if "manual"
- Notes: max 500 chars, sanitize HTML (prevent XSS)

**SQL Injection Prevention:**
```python
# ✅ CORRECT: Parameterized queries
db.execute("""
    SELECT * FROM relationships
    WHERE user_id = :user_id AND type = :type
""", user_id=user_id, type=rel_type)

# ❌ WRONG: String concatenation
db.execute(f"SELECT * FROM relationships WHERE user_id = '{user_id}'")
```

**Trust Construction Elements:**
- **Ownership verification:** All relationships checked against user_id
- **Audit trail:** All link/unlink operations logged with user_id + timestamp
- **Soft delete:** Never hard delete relationships (compliance requirement)
- **Confidence transparency:** Show confidence score to user (build trust in auto-suggestions)
- **Rate limiting:** Detect: 100 per minute, Create: 50 per minute, Unlink: 20 per minute

**Data Privacy:**
- Relationship notes may contain sensitive info (e.g., "Reimbursement for meeting with ABC Corp")
- Do not log notes in external systems (Sentry, third-party analytics)
- Redact PII in error messages

**Attack Vectors:**
- **Link spam:** User creates 10,000 fake links → Rate limiting (50 per minute)
- **Unlink spam:** User repeatedly unlinks/relinks → Rate limiting (20 per minute)
- **Cross-user linking:** User tries to link another user's transactions → Authorization check (user_id validation)

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `POST /api/transactions/{id}/suggest-relationships` (auto-detect): <200ms
- `POST /api/relationships` (create link): <150ms
- `DELETE /api/relationships/{id}` (unlink): <100ms
- `GET /api/transactions/{id}/relationships` (query): <50ms
- `GET /api/analytics/transactions?exclude_transfers=true`: <300ms

**Scalability:**
- Relationships per user: 1,000 typical, 10,000 max
- Candidates per detection: 10 typical, 50 max
- Transactions per user: 10,000 typical, 100,000 max
- Background job queue depth: <100 pending (alert if >1000)

**Database Indexes:**
```sql
-- Relationships table
CREATE INDEX idx_relationships_txn_1 ON relationships(txn_1_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_txn_2 ON relationships(txn_2_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_user ON relationships(user_id, type) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_confidence ON relationships(confidence DESC) WHERE deleted_at IS NULL AND detection_method = 'auto';

-- For analytics exclusion query
CREATE INDEX idx_relationships_analytics ON relationships(txn_1_id, txn_2_id, type) WHERE deleted_at IS NULL;

-- For candidate search (on transactions table)
CREATE INDEX idx_transactions_transfer_lookup ON canonical_transactions(user_id, date, amount) WHERE deleted_at IS NULL;
```

**Query Optimization:**

```sql
-- Candidate search (optimized)
SELECT * FROM canonical_transactions
WHERE user_id = :user_id
  AND date >= :txn_date - INTERVAL '30 days'  -- Limit search window
  AND date <= :txn_date + INTERVAL '30 days'
  AND ABS(ABS(amount) - ABS(:amount)) <= :amount * 0.05  -- Within 5%
  AND SIGN(amount) != SIGN(:amount)  -- Opposite signs
  AND account_id != :account_id  -- Different accounts
  AND txn_id NOT IN (
      SELECT txn_1_id FROM relationships WHERE deleted_at IS NULL
      UNION
      SELECT txn_2_id FROM relationships WHERE deleted_at IS NULL
  )
ORDER BY ABS(date - :txn_date), ABS(ABS(amount) - ABS(:amount))
LIMIT 10;
```

**Caching Strategy:**
- Cache relationship lookups per transaction (TTL: 5 minutes)
- Cache user's active relationships (TTL: 5 minutes, invalidate on create/unlink)
- Cache transfer exclusion filter results (TTL: 1 minute)
- Invalidation: On create/unlink, purge related transaction caches

**Background Jobs:**
- **On transaction upload:** Enqueue `detect_on_upload` job (priority: low, timeout: 30s)
- **Hourly:** Batch detection for uncategorized transactions (1000 at a time)
- **Daily:** Re-calculate confidence scores for low-confidence links (< 0.60)

---

### 18. Observability

**Metrics:**
```
# Detection metrics
relationships.detected.count (counter, labels: user_id, type)
relationships.suggested.count (counter, labels: confidence_range)
relationships.accepted.count (counter, labels: type, detection_method)
relationships.dismissed.count (counter, labels: confidence_range)

# Creation metrics
relationships.created.count (counter, labels: type, detection_method)
relationships.deleted.count (counter, labels: type)
relationships.active.total (gauge, labels: type)

# Performance metrics
relationships.detect.latency (histogram, labels: user_id)
relationships.create.latency (histogram)
relationships.query.latency (histogram)

# Quality metrics
relationships.confidence.distribution (histogram, buckets: [0.5, 0.6, 0.7, 0.8, 0.9, 1.0])
relationships.acceptance_rate (gauge)  # accepted / (accepted + dismissed)
relationships.unlink_rate (gauge)  # unlinked / total_created
```

**Structured Logs:**
```json
{
  "event": "relationship_detected",
  "txn_id": "txn_002",
  "candidate_txn_id": "txn_001",
  "type": "transfer",
  "confidence": 0.95,
  "match_details": {
    "amount_match": 1.0,
    "date_diff_days": 0,
    "opposite_signs": true,
    "account_diff": true
  },
  "user_id": "user_darwin",
  "timestamp": "2025-10-15T14:28:00Z"
}
```

```json
{
  "event": "relationship_accepted",
  "relationship_id": "rel_001",
  "suggested_confidence": 0.95,
  "user_id": "user_darwin",
  "timestamp": "2025-10-15T14:30:00Z"
}
```

```json
{
  "event": "fx_conversion_created",
  "relationship_id": "rel_002",
  "from_currency": "USD",
  "to_currency": "MXN",
  "exchange_rate": 18.5,
  "market_rate": 18.3,
  "fx_gain_loss": 200.00,
  "user_id": "user_darwin",
  "timestamp": "2025-10-16T09:15:00Z"
}
```

**Dashboards:**

**Dashboard 1: Transfer Detection Health**
- Candidate detection rate (suggestions per upload)
- Suggestion acceptance rate (target: >70%)
- Average confidence score (should be >0.85 for auto-suggestions)
- P95 detection latency (target: <200ms)
- False positive rate (dismissals / total suggestions, target: <10%)

**Dashboard 2: User Adoption**
- % transactions linked (target: >70% of eligible pairs)
- Manual vs auto link ratio (target: <10% manual)
- Most common relationship types (expect: 70% transfer, 20% FX, 10% other)
- Avg links per user per month (target: 10-50)

**Dashboard 3: Performance**
- Query latency by operation (detect, create, unlink, query)
- Cache hit rate (target: >80%)
- Background job queue depth (target: <100 pending)
- Database query execution time (slow query log)

**Alerts:**

| Alert | Condition | Severity |
|-------|-----------|----------|
| Low Accept Rate | <50% suggestions accepted for 24h | Warning |
| High Latency | P95 detection latency >500ms | Warning |
| Validation Errors | >10 validation errors/hour | Critical |
| Background Queue | Queue depth >1000 jobs | Critical |
| Cache Miss Rate | <60% cache hits for 1h | Warning |
| Unlink Spike | >20% unlink rate for 24h | Warning |

**Tracing:**
- Trace auto-detection flow: txn upload → detect_on_upload → candidate search → confidence calc → suggestion
- Include: txn_id, candidate_txn_id, confidence, match_details, decision (suggest/dismiss)
- Distributed tracing: Link to upstream normalization span (1.3)

---

### 19. Testing Strategy

**Unit Tests:**

```python
# TransferDetector tests
def test_calculate_transfer_confidence_perfect_match():
    txn_1 = Transaction(amount=-1000.00, date="2025-10-15", account_id="acc_bofa", user_id="user_1")
    txn_2 = Transaction(amount=+1000.00, date="2025-10-15", account_id="acc_wise", user_id="user_1")

    confidence = TransferDetector.calculate_confidence(txn_1, txn_2)

    assert confidence == 1.0  # Perfect match (40% + 30% + 20% + 10%)

def test_calculate_confidence_with_fee():
    txn_1 = Transaction(amount=-1000.00, date="2025-10-15", account_id="acc_bofa")
    txn_2 = Transaction(amount=+998.00, date="2025-10-15", account_id="acc_wise")  # $2 fee

    confidence = TransferDetector.calculate_confidence(txn_1, txn_2)

    assert 0.85 <= confidence <= 0.95  # High but not perfect (2% amount diff)

def test_calculate_confidence_delayed():
    txn_1 = Transaction(amount=-1000.00, date="2025-10-15", account_id="acc_bofa")
    txn_2 = Transaction(amount=+1000.00, date="2025-10-19", account_id="acc_wise")  # 4-day delay

    confidence = TransferDetector.calculate_confidence(txn_1, txn_2)

    assert 0.80 <= confidence <= 0.90  # Lower due to delay

def test_detect_on_upload_no_candidates():
    txn = Transaction(amount=-50.00, date="2025-10-15", account_id="acc_bofa")
    # No matching transactions in database

    candidates = TransferDetector.detect_on_upload(txn.txn_id)

    assert len(candidates) == 0

def test_detect_on_upload_multiple_candidates():
    # Setup: 3 matching transactions
    txn_1 = create_transaction(amount=-100.00, date="2025-10-15", account_id="acc_bofa")
    txn_2 = create_transaction(amount=+100.00, date="2025-10-15", account_id="acc_wise")
    txn_3 = create_transaction(amount=+100.00, date="2025-10-15", account_id="acc_chase")
    txn_4 = create_transaction(amount=+100.00, date="2025-10-15", account_id="acc_venmo")

    candidates = TransferDetector.detect_on_upload(txn_1.txn_id)

    assert len(candidates) == 3
    assert {c.txn_id for c in candidates} == {txn_2.txn_id, txn_3.txn_id, txn_4.txn_id}
    # Sorted by confidence descending
    assert candidates[0].confidence >= candidates[1].confidence >= candidates[2].confidence


# FXConverter tests
def test_calculate_fx_rate():
    rate = FXConverter.calculate_rate(
        from_amount=Decimal("1000.00"),
        from_currency="USD",
        to_amount=Decimal("18500.00"),
        to_currency="MXN"
    )

    assert rate == Decimal("18.5000")

def test_calculate_fx_rate_zero_amount():
    with pytest.raises(ZeroAmountError):
        FXConverter.calculate_rate(
            from_amount=Decimal("0.00"),
            from_currency="USD",
            to_amount=Decimal("18500.00"),
            to_currency="MXN"
        )

def test_calculate_fx_gain_loss():
    relationship = Relationship(
        fx_details={
            "from_amount": Decimal("1000.00"),
            "to_amount": Decimal("18500.00"),
            "from_currency": "USD",
            "to_currency": "MXN",
            "exchange_rate": Decimal("18.5")
        },
        date="2025-10-16"
    )

    # Mock market rate API
    with mock.patch('FXConverter.get_market_rate', return_value=Decimal("18.3")):
        gain_loss = FXConverter.calculate_fx_gain_loss(relationship)

    assert gain_loss == Decimal("200.00")  # 18500 - (1000 * 18.3)


# RelationshipStore tests
def test_create_relationship():
    rel = RelationshipStore.create(
        user_id="user_1",
        txn_1_id="txn_001",
        txn_2_id="txn_002",
        type="transfer",
        confidence=0.95,
        detection_method="auto"
    )

    assert rel.relationship_id.startswith("rel_")
    assert rel.type == "transfer"
    assert rel.confidence == 0.95
    assert rel.detection_method == "auto"

def test_create_relationship_same_transaction():
    with pytest.raises(SameTransactionError):
        RelationshipStore.create(
            user_id="user_1",
            txn_1_id="txn_001",
            txn_2_id="txn_001",  # Same as txn_1_id
            type="transfer"
        )

def test_create_relationship_already_linked():
    # Create first link
    RelationshipStore.create(user_id="user_1", txn_1_id="txn_001", txn_2_id="txn_002", type="transfer")

    # Attempt duplicate
    with pytest.raises(AlreadyLinkedError):
        RelationshipStore.create(user_id="user_1", txn_1_id="txn_001", txn_2_id="txn_003", type="transfer")

def test_unlink_relationship():
    rel = RelationshipStore.create(user_id="user_1", txn_1_id="txn_001", txn_2_id="txn_002", type="transfer")

    RelationshipStore.unlink(rel.relationship_id, user_id="user_1")

    unlinked = RelationshipStore.get(rel.relationship_id)
    assert unlinked.deleted_at is not None
    assert unlinked.deleted_by == "user_1"
```

**Integration Tests:**

```python
def test_end_to_end_transfer_detection():
    # Setup: Create first transaction
    txn_1 = create_transaction(
        user_id="user_test",
        account_id="acc_bofa",
        amount=-1000.00,
        date="2025-10-15",
        description="Transfer to Wise"
    )

    # Upload second transaction (matching transfer)
    txn_2 = create_transaction(
        user_id="user_test",
        account_id="acc_wise",
        amount=+1000.00,
        date="2025-10-15",
        description="Deposit from BofA"
    )

    # Auto-detection should run
    candidates = TransferDetector.detect_on_upload(txn_2.txn_id)

    assert len(candidates) == 1
    assert candidates[0].txn_id == txn_1.txn_id
    assert candidates[0].confidence >= 0.90

    # User accepts suggestion
    rel = RelationshipStore.create(
        user_id="user_test",
        txn_1_id=txn_1.txn_id,
        txn_2_id=txn_2.txn_id,
        type="transfer",
        confidence=candidates[0].confidence,
        detection_method="auto"
    )

    # Verify relationship created
    assert rel.type == "transfer"
    assert rel.confidence >= 0.90

    # Verify both transactions show link
    txn_1_rels = RelationshipStore.find_by_transaction(txn_1.txn_id)
    txn_2_rels = RelationshipStore.find_by_transaction(txn_2.txn_id)
    assert len(txn_1_rels) == 1
    assert len(txn_2_rels) == 1
    assert txn_1_rels[0].relationship_id == rel.relationship_id

def test_manual_link_creation():
    # Setup: Two unrelated transactions
    txn_1 = create_transaction(user_id="user_test", amount=-47.32, date="2025-10-10")
    txn_2 = create_transaction(user_id="user_test", amount=+50.00, date="2025-10-20")

    # User manually links as reimbursement
    rel = RelationshipStore.create(
        user_id="user_test",
        txn_1_id=txn_1.txn_id,
        txn_2_id=txn_2.txn_id,
        type="reimbursement",
        confidence=None,  # Manual link
        detection_method="manual",
        notes="Employer rounds to $5"
    )

    # Verify manual link
    assert rel.type == "reimbursement"
    assert rel.confidence is None
    assert rel.detection_method == "manual"
    assert rel.notes == "Employer rounds to $5"

def test_analytics_exclude_transfers():
    # Setup: 2 transactions + 1 transfer
    txn_1 = create_transaction(user_id="user_test", amount=-100.00, description="Groceries")
    txn_2 = create_transaction(user_id="user_test", amount=-1000.00, description="Transfer out")
    txn_3 = create_transaction(user_id="user_test", amount=+1000.00, description="Transfer in")

    # Link transfer
    RelationshipStore.create(user_id="user_test", txn_1_id=txn_2.txn_id, txn_2_id=txn_3.txn_id, type="transfer")

    # Query with exclusion
    response = client.get("/api/analytics/transactions?exclude_transfers=true")

    assert response.json()["total_expenses"] == 100.00  # Only groceries
    assert response.json()["excluded_transfer_volume"] == 1000.00
```

**Multi-Domain Tests:**

```python
def test_healthcare_claim_payment_linking():
    # Insurance claim submission
    claim = create_record(
        entity_type="claim",
        amount=-500.00,
        date="2025-09-01",
        description="Doctor visit claim"
    )

    # Insurance reimbursement (60 days later, 90% reimbursed)
    payment = create_record(
        entity_type="payment",
        amount=+450.00,
        date="2025-11-01",
        description="Insurance reimbursement"
    )

    # Manual link (amounts differ, large delay)
    rel = RelationshipStore.create(
        user_id="user_test",
        record_1_id=claim.record_id,
        record_2_id=payment.record_id,
        type="reimbursement",
        confidence=None,
        detection_method="manual"
    )

    assert rel.type == "reimbursement"

def test_research_citation_network():
    # Paper A cites Paper B
    paper_a = create_record(entity_type="paper", title="Machine Learning Study", doi="10.1234/abc")
    paper_b = create_record(entity_type="paper", title="Neural Networks", doi="10.5678/xyz")

    # Link citation
    rel = RelationshipStore.create(
        user_id="user_test",
        record_1_id=paper_a.record_id,
        record_2_id=paper_b.record_id,
        type="citation",
        confidence=1.0,  # DOI match
        detection_method="auto",
        metadata={"doi_match": True}
    )

    assert rel.type == "citation"
```

**Edge Case Tests:**

```python
def test_prevent_duplicate_link():
    txn_1 = create_transaction(amount=-1000.00)
    txn_2 = create_transaction(amount=+1000.00)

    # Create first link
    rel_1 = RelationshipStore.create("user_test", txn_1.txn_id, txn_2.txn_id, "transfer")

    # Attempt duplicate
    with pytest.raises(AlreadyLinkedError):
        RelationshipStore.create("user_test", txn_1.txn_id, txn_2.txn_id, "transfer")

def test_chain_transfers():
    # BofA → Wise USD → Wise MXN → Scotia
    txn_1 = create_transaction(account="BofA", amount=-1000.00, currency="USD")
    txn_2 = create_transaction(account="Wise USD", amount=+1000.00, currency="USD")
    txn_3 = create_transaction(account="Wise USD", amount=-1000.00, currency="USD")
    txn_4 = create_transaction(account="Wise MXN", amount=+18500.00, currency="MXN")
    txn_5 = create_transaction(account="Wise MXN", amount=-18500.00, currency="MXN")
    txn_6 = create_transaction(account="Scotia", amount=+18500.00, currency="MXN")

    # Create relationships
    rel_1 = RelationshipStore.create("user_test", txn_1.txn_id, txn_2.txn_id, "transfer")
    rel_2 = RelationshipStore.create("user_test", txn_3.txn_id, txn_4.txn_id, "fx_conversion")
    rel_3 = RelationshipStore.create("user_test", txn_5.txn_id, txn_6.txn_id, "transfer")

    # Query chain
    chain = get_relationship_chain(txn_1.txn_id)
    assert len(chain) == 3
    assert chain == [rel_1, rel_2, rel_3]
```

---

### 20. Operations Runbook

**Deployment:**

1. **Database Migration:**
```sql
-- migrations/202510_create_relationships.sql

BEGIN;

CREATE TABLE relationships (
    relationship_id TEXT PRIMARY KEY DEFAULT ('rel_' || gen_random_uuid()::text),
    user_id TEXT NOT NULL,
    txn_1_id TEXT NOT NULL,
    txn_2_id TEXT NOT NULL,
    type TEXT NOT NULL CHECK (type IN ('transfer', 'fx_conversion', 'reimbursement', 'split', 'correction', 'other')),
    confidence DECIMAL(3,2) CHECK (confidence IS NULL OR (confidence >= 0 AND confidence <= 1)),
    detection_method TEXT NOT NULL CHECK (detection_method IN ('auto', 'manual')),
    fx_details JSONB,
    notes TEXT CHECK (LENGTH(notes) <= 500),
    linked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    linked_by TEXT,
    deleted_at TIMESTAMPTZ,
    deleted_by TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY (txn_1_id) REFERENCES canonical_transactions(txn_id) ON DELETE CASCADE,
    FOREIGN KEY (txn_2_id) REFERENCES canonical_transactions(txn_id) ON DELETE CASCADE,
    FOREIGN KEY (linked_by) REFERENCES users(user_id),
    FOREIGN KEY (deleted_by) REFERENCES users(user_id),
    CHECK (txn_1_id != txn_2_id),
    CHECK ((detection_method = 'auto' AND confidence IS NOT NULL) OR (detection_method = 'manual' AND confidence IS NULL))
);

-- Indexes for fast lookups
CREATE INDEX idx_relationships_txn_1 ON relationships(txn_1_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_txn_2 ON relationships(txn_2_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_user ON relationships(user_id, type) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_confidence ON relationships(confidence DESC) WHERE deleted_at IS NULL AND detection_method = 'auto';

-- Index for analytics exclusion query
CREATE INDEX idx_relationships_analytics ON relationships(txn_1_id, txn_2_id, type) WHERE deleted_at IS NULL;

-- Index for candidate search (on transactions table)
CREATE INDEX idx_transactions_transfer_lookup ON canonical_transactions(user_id, date, amount) WHERE deleted_at IS NULL;

COMMIT;
```

2. **Background Worker Configuration:**
```yaml
# workers/transfer_detection.yml
name: transfer_detection
queue: background
concurrency: 5
max_retries: 3
timeout: 30s

jobs:
  - name: detect_on_upload
    handler: TransferDetector.detect_on_upload
    priority: low
    schedule: null  # Triggered by transaction upload event

  - name: detect_batch
    handler: TransferDetector.detect_batch
    schedule: "0 2 * * *"  # Daily at 2 AM
    priority: low
    batch_size: 1000
```

3. **Feature Flags:**
```python
# Enable/disable auto-detection
FEATURE_AUTO_TRANSFER_DETECTION = env.bool("FEATURE_AUTO_TRANSFER_DETECTION", default=True)

# Confidence threshold for auto-suggestions
TRANSFER_CONFIDENCE_THRESHOLD = env.float("TRANSFER_CONFIDENCE_THRESHOLD", default=0.50)

# Date window for candidate search (days)
TRANSFER_DATE_WINDOW_DAYS = env.int("TRANSFER_DATE_WINDOW_DAYS", default=7)

# Enable FX conversion tracking
FEATURE_FX_CONVERSION = env.bool("FEATURE_FX_CONVERSION", default=True)

# External API for market rates (Wise, ECB, etc.)
FX_MARKET_RATE_PROVIDER = env.str("FX_MARKET_RATE_PROVIDER", default="wise")
```

**Rollout Strategy:**

**Phase 1: Dark Launch (Week 1)**
- Deploy relationship table and primitives
- Run auto-detection in background (don't show suggestions)
- Monitor metrics: detection rate, confidence distribution, false positives
- Goal: Validate detection accuracy before user exposure

**Phase 2: Beta Launch (Week 2-3)**
- Enable suggestions for 10% of users (feature flag)
- Collect accept/dismiss rates
- Gather user feedback (in-app survey)
- Goal: Identify edge cases, tune confidence threshold

**Phase 3: Full Launch (Week 4)**
- Enable for all users
- Monitor performance (latency, queue depth)
- Iterate based on feedback
- Goal: 70% acceptance rate, <10% false positives

**Monitoring Checklist:**

Pre-launch:
- ✅ Database migration successful (test on staging)
- ✅ Indexes created (verify EXPLAIN plans)
- ✅ Background workers running (check queue depth)
- ✅ Metrics dashboard deployed (Grafana/Datadog)
- ✅ Alerts configured (PagerDuty)

Post-launch:
- ✅ Monitor accept rate (target: ≥70%)
- ✅ Monitor false positive rate (target: <10%)
- ✅ Monitor query performance (target: p95 <200ms)
- ✅ Monitor background job queue (target: <100 pending)
- ✅ Monitor unlink rate (target: <5%)

**Common Issues:**

**Issue 1: Auto-detection not working**
- **Symptom:** No suggestions appearing for transactions
- **Debug:**
  1. Check if user has recent transactions (need at least 2 for pairing)
  2. Verify candidate search query (check indexes, EXPLAIN plan)
  3. Check confidence threshold (TRANSFER_CONFIDENCE_THRESHOLD)
  4. Verify background worker running (check queue depth)
- **Fix:**
  - Lower threshold temporarily (0.50 → 0.40)
  - Force batch detection: `python scripts/force_batch_detect.py --user-id=user_123`

**Issue 2: High false positive rate**
- **Symptom:** Users dismissing >20% of suggestions
- **Debug:**
  1. Query dismissed suggestions (analyze common patterns)
  2. Check confidence distribution (should cluster >0.80, not 0.60-0.70)
  3. Identify problem criteria (amount mismatch? date delay?)
- **Fix:**
  - Increase confidence threshold (0.50 → 0.70)
  - Adjust weight of problematic criterion (e.g., date proximity: 30% → 40%)

**Issue 3: Performance degradation (high latency)**
- **Symptom:** Auto-detect latency >500ms p95
- **Debug:**
  1. Check candidate search query performance (EXPLAIN ANALYZE)
  2. Verify indexes exist and being used
  3. Check database load (CPU, connections)
  4. Check search window (should be ≤30 days)
- **Fix:**
  - Reduce search window (7 days → 3 days)
  - Add composite index: `(user_id, date, amount, account_id)`
  - Enable query result caching

**Issue 4: Analytics not excluding transfers**
- **Symptom:** Income/expense totals include transfer amounts (double-counting)
- **Debug:**
  1. Verify exclusion query includes `WHERE type NOT IN ('transfer', 'fx_conversion')`
  2. Check if relationships soft-deleted (deleted_at != NULL)
  3. Verify default `exclude_transfers=true` in dashboard API
- **Fix:**
  - Update dashboard query to default `exclude_transfers=true`
  - Add exclusion logic to all analytics endpoints

**Incident Response:**

```bash
# Query recent relationships
SELECT relationship_id, type, confidence, detection_method, linked_at
FROM relationships
WHERE user_id = 'user_123'
  AND deleted_at IS NULL
ORDER BY linked_at DESC
LIMIT 50;

# Force unlink relationship
curl -X DELETE /api/relationships/{relationship_id} \
  -H "Authorization: Bearer TOKEN"

# Bulk re-detect for user
python scripts/bulk_detect.py --user-id=user_123 --date-from=2025-10-01 --date-to=2025-10-31

# Check background job queue
SELECT queue, job_name, COUNT(*) as pending_count
FROM background_jobs
WHERE status = 'pending'
GROUP BY queue, job_name;

# Manually trigger batch detection
python scripts/force_batch_detect.py --user-id=user_123
```

**Rollback Plan:**

If critical issues arise:

1. **Disable auto-detection:**
   ```python
   # Set feature flag
   FEATURE_AUTO_TRANSFER_DETECTION = False
   ```

2. **Keep manual linking enabled:**
   - Users can still manually link transactions
   - Existing relationships remain intact

3. **Fix and re-deploy:**
   - Auto-detection re-enabled after fix
   - Re-process recent transactions if needed
   - Gradual rollout (10% → 50% → 100%)

---

## 💻 Tech Stack (Finance-App Implementation)

**Scale Target:** 15 inter-account transfers/month, ~50 total transactions/month from 6 accounts (BofA, Apple Card, Scotia, Wise, Stripe, BofA Credit)

### Backend

**RelationshipStore Implementation:**
- **Database:** SQLite
  - Table: `relationships`
  - Columns: `id`, `from_transaction_id`, `to_transaction_id`, `relationship_type`, `confidence`, `exchange_rate`, `metadata`, `created_at`, `created_by`, `deleted_at`
  - Indexes: `(from_transaction_id)`, `(to_transaction_id)`, `(relationship_type)`
- **Storage:** Local SQLite file (~10KB for 15 relationships/month = 120KB/year)
- **Pattern:** Soft-delete (set `deleted_at` timestamp, preserve audit trail)

**EntityLinkDetector (renamed from TransferDetector) Implementation:**
- **Algorithm:** Rule-based matching with weighted scoring
- **Criteria Weights:**
  - Amount match (40%): `abs(txn_a.amount + txn_b.amount) < 1.00` (within $1)
  - Date proximity (30%): `abs(date_a - date_b) <= 7 days`
  - Opposite signs (20%): `txn_a.amount * txn_b.amount < 0`
  - Different accounts (10%): `txn_a.account != txn_b.account`
- **Confidence Threshold:**
  - Auto-suggest: ≥ 0.70 (show notification to user)
  - Auto-link: ≥ 0.95 (optional, disabled by default)
- **Performance:** O(n) scan through unlinked transactions (50 tx/month = instant)
- **Libraries:** Python `decimal.Decimal` for amount comparison, `datetime` for date proximity

**FXConverter (Finance-Specific - NOT a primitive):**
- **Implementation:** Simple rate calculator in finance-app utils
- **Formula:** `exchange_rate = abs(txn_b.amount / txn_a.amount)`
- **Example:** $1,000 USD → $18,500 MXN = rate 18.5
- **Storage:** Store rate in `relationships.exchange_rate` column (Decimal)
- **Note:** User-transaction-specific rates, NOT global market rates from APIs

**RelationshipMatcher Implementation:**
- **Similarity Algorithms:**
  - **Levenshtein distance** for description matching (python-Levenshtein library)
  - **Jaro-Winkler** for fuzzy name matching (weight: 0.2)
- **Use case:** Match descriptions like "Transfer to Wise" ↔ "Deposit from BofA"
- **Performance:** <10ms for 50 transactions

### Frontend

**RelationshipPanel (IL Component):**
- **Framework:** React + TypeScript
- **UI Library:** shadcn/ui (Card, Badge, Button)
- **State Management:** React Context (TransactionContext)
- **Features:**
  - Display linked transaction pairs with confidence badges
  - Show relationship type (Transfer, FX, Reimbursement, etc.)
  - Unlink button with confirmation dialog
  - Chain visualization for multi-hop transfers (BofA → Wise USD → Wise MXN → Scotia)

**TransferLinkDialog (IL Component):**
- **Framework:** React + TypeScript
- **UI Library:** shadcn/ui (Dialog, Select, Input, Button)
- **Features:**
  - Transaction selector (from/to dropdowns)
  - Relationship type picker (6 types)
  - Confidence display (auto-calculated)
  - Manual exchange rate input for FX conversions
  - Validation: prevent linking same transaction, detect amount mismatches

**FXConversionCard (Finance-Specific IL):**
- **Framework:** React + TypeScript
- **UI Library:** shadcn/ui (Card, Badge)
- **Features:**
  - Display FX details (USD → MXN, rate: 18.5, gain/loss: $0)
  - Show both transaction amounts with currencies
  - Highlight exchange rate with badge
  - Link to original transactions

### API Endpoints

**POST /api/relationships**
- **Purpose:** Create manual relationship between two transactions
- **Auth:** User session (user_id from JWT)
- **Body:** `{ from_transaction_id, to_transaction_id, relationship_type, notes }`
- **Response:** `{ relationship_id, confidence, exchange_rate }`
- **Latency:** <100ms (single SQLite insert + confidence calculation)

**DELETE /api/relationships/:id**
- **Purpose:** Soft-delete relationship (set `deleted_at`)
- **Auth:** User session (only owner can unlink)
- **Response:** `{ success: true }`
- **Latency:** <50ms (single UPDATE query)

**GET /api/relationships/suggestions**
- **Purpose:** Get auto-detected transfer suggestions for unlinked transactions
- **Auth:** User session
- **Response:** `[ { candidate_pairs: [...], confidence, reasons: [...] } ]`
- **Latency:** <200ms (scan 50 unlinked tx, score 10-15 candidates)
- **Caching:** Not needed (500 tx/mes = low volume)

### Database Schema

```sql
CREATE TABLE relationships (
    id TEXT PRIMARY KEY,  -- rel_xxxxx
    from_transaction_id TEXT NOT NULL REFERENCES canonical_transactions(canonical_id),
    to_transaction_id TEXT NOT NULL REFERENCES canonical_transactions(canonical_id),
    relationship_type TEXT NOT NULL,  -- transfer | fx_conversion | reimbursement | split | correction | other
    confidence REAL NOT NULL,  -- 0.0-1.0
    exchange_rate TEXT,  -- Decimal string (e.g., "18.50" for USD→MXN)
    metadata TEXT,  -- JSON (notes, auto_detected: true/false, detection_reason)
    created_at TEXT NOT NULL,  -- ISO 8601
    created_by TEXT NOT NULL,  -- user_id or "system"
    deleted_at TEXT,  -- ISO 8601 (soft delete)
    version INTEGER NOT NULL DEFAULT 1  -- Optimistic locking
);

-- Indexes for query performance
CREATE INDEX idx_relationships_from ON relationships(from_transaction_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_to ON relationships(to_transaction_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_relationships_type ON relationships(relationship_type) WHERE deleted_at IS NULL;
CREATE UNIQUE INDEX idx_relationships_transaction_pair ON relationships(from_transaction_id, to_transaction_id) WHERE deleted_at IS NULL;
```

### Testing

**Unit Tests:**
- EntityLinkDetector confidence scoring (weighted criteria)
- FXConverter rate calculation (handle zero/negative amounts)
- RelationshipStore uniqueness validation (no duplicate links)
- Soft-delete behavior (deleted relationships don't appear in queries)

**Integration Tests:**
- Auto-detection on transaction upload (trigger detection after normalization)
- Manual link creation via API
- Unlink operation (soft-delete + audit trail)
- Analytics exclusion (transfers excluded from income/expense reports)

**E2E Tests:**
- Upload BofA statement → Upload Wise statement → See transfer suggestion → Accept link
- Create FX conversion manually → Verify exchange rate stored → View in FXConversionCard
- Unlink relationship → Verify both transactions become unlinked → Check audit trail

### Performance Characteristics

**Latency Targets:**
- Auto-detection: <200ms for 50 unlinked transactions
- Manual link creation: <100ms (p95)
- Relationship query: <50ms (p95)
- Suggestion API: <300ms (p95)

**Scalability:**
- Current: 15 transfers/month = 180/year = 900 relationships in 5 years (trivial for SQLite)
- Max: 10K relationships/user (SQLite handles easily)
- No need for: Redis caching, PostgreSQL, queue-based processing

**Storage:**
- Relationship record: ~500 bytes (JSON metadata)
- 15 relationships/month = 7.5KB/month = 90KB/year
- 5-year projection: 450KB total (negligible)

---

## 🎯 Summary

Vertical 3.5 delivers a **paired record linking system** with:

✅ **4 OL Primitives** (RelationshipStore, TransferDetector, FXConverter, RelationshipMatcher)
✅ **3 IL Components** (RelationshipPanel, TransferLinkDialog, FXConversionCard)
✅ **3 Schemas** (relationship, fx-details, relationship-suggestion)
✅ **20 Complete Sections** (Product, Machinery, Cross-Cutting)
✅ **Multi-Domain Pattern** (Finance → Transfers, Healthcare → Claim-Payment, Legal → Case hierarchy, Research → Citation networks, E-commerce → Order-Return)

**Finance Instantiation:**
- Auto-detect transfers (same amount ±5%, opposite signs, ±7 days)
- FX conversion tracking with exchange rates
- 6 relationship types (transfer, fx_conversion, reimbursement, split, correction, other)
- Confidence scoring (0.0-1.0 scale, weighted criteria)
- Analytics exclusion (prevent double-counting)

**Universal Pattern: Paired Record Linking + Confidence Scoring**
- Auto-detection with confidence scoring (weighted criteria)
- Manual override (user can link any pair)
- Graph traversal (chain relationships)
- Soft delete + audit trail (compliance)
- Analytics integration (exclude linked pairs)

**Next:** 3.6 Unit (currency/date normalization) or 4.x Analysis Layer (reporting, forecasting)
