# Vertical 3.8: Cluster Rules (Merchant Normalization & Transaction Clustering)

> **Type:** Text Normalization & Fuzzy Matching System
> **Pattern:** Rule Engine + Fuzzy Matching + Clustering
> **Last Updated:** 2025-10-24

---

## 📋 Overview

The **Cluster Rules** vertical provides a **text normalization and fuzzy matching system** for standardizing merchant names, grouping similar transactions, and managing normalization rules. While demonstrated in finance domain (merchant name cleanup), the underlying primitives are domain-agnostic and apply to ANY text normalization and entity deduplication scenario.

**Key Characteristics:**
- **Rule-Based Normalization:** Exact match, regex, and fuzzy rules for text transformation
- **Fuzzy Matching:** Multiple algorithms (Levenshtein, Jaro-Winkler, Soundex, Metaphone)
- **Clustering Engine:** Group similar entities using DBSCAN, hierarchical clustering
- **Rule Precedence:** Priority-based execution (exact > regex > fuzzy > default)
- **Batch Processing:** Normalize historical data in bulk
- **User-Defined Rules:** Create custom normalization patterns

**Finance Domain Examples:**
- Normalize merchant names: "UBER EATS PENDING" → "Uber Eats"
- Cluster variants: "AMZN MKTP US", "Amazon.com", "AMAZON PRIME" → "Amazon"
- Fuzzy match: "MCDONALDS #1234" matches "McDonald's" with confidence 0.92
- Rule types: Exact ("SQ *COFFEE SHOP" → "Coffee Shop"), Regex ("UBER.*" → "Uber"), Fuzzy (similarity threshold 0.85)

**Multi-Domain Applicability:**
- Healthcare: Provider name normalization ("ST MARY'S HOSP" → "St. Mary's Hospital"), medication name deduplication
- Legal: Case name normalization ("DOE V. SMITH" → "Doe v. Smith"), party name standardization
- Research: Institution normalization ("MIT CSAIL" → "MIT Computer Science and AI Lab"), author name deduplication
- E-commerce: Company name normalization for vendor deduplication, product name variants
- HR: Employee name standardization across systems

---

## Product Layer (Sections 1-10)

### 1. Scope & Boundaries

**In Scope:**
- Merchant name normalization with user-defined rules
- Fuzzy string matching with multiple algorithms (Levenshtein, Jaro-Winkler, Soundex, Metaphone)
- Transaction clustering based on similarity
- Rule precedence and priority management (exact > regex > fuzzy)
- Batch normalization for historical transactions
- Rule testing and preview before applying
- Cluster merge/split operations
- Audit trail for all normalization changes
- User-defined rule templates
- Similarity threshold configuration

**Out of Scope:**
- Natural language processing (NLP) for semantic understanding
- Address normalization (covered in separate vertical)
- Multi-language translation (localization)
- Merchant logo/image matching
- Real-time streaming normalization (batch only)
- Machine learning-based entity resolution (future enhancement)

**Boundaries:**
- Rules are user-scoped (each user maintains their own ruleset)
- Normalization is non-destructive (original text preserved)
- One entity can match multiple rules (highest priority wins)
- Clusters are suggestions (user confirms merge)
- Fuzzy matching confidence threshold: 0.70 minimum (configurable)

---

### 2. User Flow (Real Usage)

**Scenario 1: User creates exact match rule for common merchant**

User: "All my Uber transactions show different names - I want them all normalized to 'Uber'"

System:
1. User views transaction list and sees variants:
   - "UBER EATS PENDING"
   - "UBER *RIDE"
   - "Uber Technologies"
2. User opens NormalizationRuleManager
3. Clicks "Create Rule"
4. RuleEditorDialog appears with form:
   - Pattern Type: Regex
   - Pattern: `UBER.*`
   - Replacement: "Uber"
   - Priority: 90 (high)
5. User clicks "Test Rule" button
6. System shows preview:
   - "UBER EATS PENDING" → "Uber" ✅
   - "UBER *RIDE" → "Uber" ✅
   - "Uber Technologies" → "Uber" ✅
   - Matches: 47 transactions
7. User confirms and saves
8. System creates NormalizationRule:
   ```json
   {
     "rule_id": "rule_uber_all",
     "pattern": "UBER.*",
     "replacement": "Uber",
     "rule_type": "regex",
     "priority": 90,
     "user_id": "user_darwin",
     "created_at": "2025-10-24T10:00:00Z",
     "enabled": true
   }
   ```
9. System batch-normalizes 47 existing transactions
10. User sees notification: "✅ Normalized 47 transactions to 'Uber'"

**Scenario 2: System suggests cluster based on fuzzy matching**

Background: System detects similar merchant names

System:
1. ClusteringEngine runs nightly job
2. Finds similar merchant names:
   - "AMAZON.COM"
   - "AMZN MKTP US"
   - "AMAZON PRIME"
   - "Amazon Web Services"
3. Calculates pairwise similarity:
   - "AMAZON.COM" ↔ "AMZN MKTP US": 0.78 (Jaro-Winkler)
   - "AMAZON.COM" ↔ "AMAZON PRIME": 0.85
   - "AMAZON PRIME" ↔ "AMZN MKTP US": 0.72
4. Creates cluster with canonical name "Amazon":
   ```json
   {
     "cluster_id": "cluster_amazon_1",
     "canonical_name": "Amazon",
     "variants": [
       {"raw_name": "AMAZON.COM", "frequency": 23, "similarity_to_canonical": 0.92},
       {"raw_name": "AMZN MKTP US", "frequency": 45, "similarity_to_canonical": 0.78},
       {"raw_name": "AMAZON PRIME", "frequency": 12, "similarity_to_canonical": 0.88},
       {"raw_name": "Amazon Web Services", "frequency": 8, "similarity_to_canonical": 0.65}
     ],
     "similarity_score": 0.81,
     "transaction_count": 88
   }
   ```
5. User opens ClusterViewer and sees suggestion
6. User reviews cluster:
   - Canonical: "Amazon"
   - Variants: 4 names
   - Transactions affected: 88
7. User clicks "Accept Merge"
8. System creates normalization rule automatically:
   - Pattern type: Exact (for each variant)
   - Replacement: "Amazon"
   - Priority: 80 (auto-generated)
9. System batch-normalizes 88 transactions
10. User sees consolidated merchant "Amazon" in transaction list

**Scenario 3: User tests fuzzy matching before creating rule**

User: "I want to normalize all McDonald's variations, but I'm not sure how many formats exist"

System:
1. User opens RuleEditorDialog
2. Selects "Fuzzy Match" type
3. Enters template: "McDonald's"
4. Sets similarity threshold: 0.80
5. Clicks "Test Rule" (without saving)
6. System scans all merchant names using FuzzyMatcher
7. Finds matches:
   - "MCDONALDS #1234" → 0.87 similarity ✅
   - "MCDONALD'S" → 0.95 similarity ✅
   - "MC DONALDS" → 0.82 similarity ✅
   - "McDONALD S" → 0.78 similarity ❌ (below 0.80)
   - "BURGER KING" → 0.12 similarity ❌
8. Preview shows:
   - 23 transactions would be normalized to "McDonald's"
   - 3 variants matched
9. User adjusts threshold to 0.75 and re-tests
10. Now "McDONALD S" included (0.78 > 0.75)
11. User saves rule with threshold 0.75

**Scenario 4: User splits incorrectly merged cluster**

User: "The system merged 'Amazon' and 'Amazon Web Services' but they should be separate"

System:
1. User views ClusterViewer
2. Sees cluster "Amazon" with 4 variants
3. Clicks cluster to expand detail view
4. Sees:
   - "AMAZON.COM" (23 txns) - General purchases
   - "AMZN MKTP US" (45 txns) - General purchases
   - "AMAZON PRIME" (12 txns) - Subscription
   - "Amazon Web Services" (8 txns) - Cloud hosting
5. User selects "Amazon Web Services" variant
6. Clicks "Split into New Cluster"
7. System confirms: "Create new cluster for 'Amazon Web Services'? This will affect 8 transactions."
8. User confirms
9. System:
   - Removes "Amazon Web Services" from original cluster
   - Creates new cluster_aws with canonical "Amazon Web Services"
   - Updates affected transactions
10. User now sees 2 clusters:
    - "Amazon" (80 transactions, 3 variants)
    - "Amazon Web Services" (8 transactions, 1 variant)

---

### 3. Primitives Touched

**Objective Layer (OL):**
- `MerchantNormalizer` - Normalize raw merchant names using rules (NEW - this vertical)
- `ClusteringEngine` - Cluster similar transactions/entities (NEW - this vertical)
- `NormalizationRuleStore` - CRUD for normalization rules (NEW - this vertical)
- `FuzzyMatcher` - Calculate text similarity scores (NEW - this vertical)
- `TransactionStore` - Update transaction with normalized_merchant (from 1.3)
- `CounterpartyStore` - Reference merchant for normalization (from 3.2)

**Interaction Layer (IL):**
- `MerchantRulesManager` - Full CRUD UI for managing normalization rules (NEW - this vertical)
- `ClusterViewer` - Display clusters of similar entities (NEW - this vertical)
- `RuleEditorDialog` - Dialog for creating/editing normalization rule (NEW - this vertical)
- `TransactionList` - View transactions with normalized merchant names (from 2.1)
- `DrillDownPanel` - View normalization provenance in transaction detail (from 2.2)

**Schemas:**
- `normalization-rule.schema.json` - Normalization rule definition (NEW - this vertical)
- `merchant-cluster.schema.json` - Merchant cluster with variants (NEW - this vertical)
- `rule-execution-log.schema.json` - Rule execution audit trail (NEW - this vertical)

---

### 4. Contracts (API + Internal)

**REST API:**

```http
# Get Normalization Rules for User
GET /api/normalization-rules?user_id={user_id}&enabled=true
Authorization: Bearer {token}

Response 200:
{
  "rules": [
    {
      "rule_id": "rule_uber_all",
      "pattern": "UBER.*",
      "replacement": "Uber",
      "rule_type": "regex",
      "priority": 90,
      "user_id": "user_darwin",
      "created_at": "2025-10-24T10:00:00Z",
      "enabled": true,
      "match_count": 47
    },
    {
      "rule_id": "rule_amazon_exact",
      "pattern": "AMZN MKTP US",
      "replacement": "Amazon",
      "rule_type": "exact",
      "priority": 95,
      "user_id": "user_darwin",
      "created_at": "2025-10-23T15:30:00Z",
      "enabled": true,
      "match_count": 45
    }
  ],
  "total": 2
}
```

```http
# Create Normalization Rule
POST /api/normalization-rules
Authorization: Bearer {token}
Content-Type: application/json

{
  "pattern": "MCDONALDS.*",
  "replacement": "McDonald's",
  "rule_type": "regex",
  "priority": 85,
  "enabled": true
}

Response 201:
{
  "rule_id": "rule_mcdonalds_1",
  "pattern": "MCDONALDS.*",
  "replacement": "McDonald's",
  "rule_type": "regex",
  "priority": 85,
  "user_id": "user_darwin",
  "created_at": "2025-10-24T11:00:00Z",
  "enabled": true
}
```

```http
# Test Rule (Preview Without Saving)
POST /api/normalization-rules/test
Authorization: Bearer {token}
Content-Type: application/json

{
  "pattern": "McDonald's",
  "rule_type": "fuzzy",
  "similarity_threshold": 0.80
}

Response 200:
{
  "matches": [
    {
      "raw_name": "MCDONALDS #1234",
      "normalized_name": "McDonald's",
      "similarity": 0.87,
      "transaction_count": 15
    },
    {
      "raw_name": "MCDONALD'S",
      "normalized_name": "McDonald's",
      "similarity": 0.95,
      "transaction_count": 8
    }
  ],
  "total_matches": 2,
  "total_transactions": 23
}
```

```http
# Get Merchant Clusters
GET /api/merchant-clusters?min_similarity=0.70&min_transactions=5
Authorization: Bearer {token}

Response 200:
{
  "clusters": [
    {
      "cluster_id": "cluster_amazon_1",
      "canonical_name": "Amazon",
      "variants": [
        {"raw_name": "AMAZON.COM", "frequency": 23, "similarity_to_canonical": 0.92},
        {"raw_name": "AMZN MKTP US", "frequency": 45, "similarity_to_canonical": 0.78}
      ],
      "similarity_score": 0.81,
      "transaction_count": 68,
      "status": "pending"
    }
  ],
  "total": 1
}
```

```http
# Accept Cluster Merge
POST /api/merchant-clusters/{cluster_id}/accept
Authorization: Bearer {token}

Response 200:
{
  "cluster_id": "cluster_amazon_1",
  "rules_created": [
    {"rule_id": "rule_auto_amazon_1", "pattern": "AMAZON.COM", "replacement": "Amazon"},
    {"rule_id": "rule_auto_amazon_2", "pattern": "AMZN MKTP US", "replacement": "Amazon"}
  ],
  "transactions_normalized": 68
}
```

```http
# Split Cluster
POST /api/merchant-clusters/{cluster_id}/split
Authorization: Bearer {token}
Content-Type: application/json

{
  "variants_to_extract": ["Amazon Web Services"],
  "new_canonical_name": "Amazon Web Services"
}

Response 200:
{
  "original_cluster_id": "cluster_amazon_1",
  "new_cluster_id": "cluster_aws_1",
  "transactions_moved": 8
}
```

```http
# Batch Normalize Transactions
POST /api/normalization/batch
Authorization: Bearer {token}
Content-Type: application/json

{
  "transaction_ids": ["txn_1", "txn_2", "txn_3"],
  "force_reprocess": false
}

Response 200:
{
  "normalized_count": 3,
  "rules_applied": [
    {"rule_id": "rule_uber_all", "transaction_count": 2},
    {"rule_id": "rule_amazon_exact", "transaction_count": 1}
  ]
}
```

**Internal OL API:**

```python
class MerchantNormalizer:
    def normalize(self, raw_name: str, user_id: str) -> NormalizedResult:
        """
        Normalizes raw merchant name using user's rules.

        Process:
        1. Load all enabled rules for user (ordered by priority desc)
        2. Try exact match first
        3. Try regex match
        4. Try fuzzy match (if threshold met)
        5. Return original if no match

        Returns:
            NormalizedResult with normalized_name, rule_id, confidence
        """

    def batch_normalize(self, raw_names: List[str], user_id: str) -> Dict[str, NormalizedResult]:
        """Batch normalization for performance."""

    def add_rule(self, user_id: str, pattern: str, replacement: str,
                 rule_type: RuleType, priority: int) -> NormalizationRule:
        """
        Creates normalization rule.

        Raises:
            DuplicatePatternError: If pattern exists for user
            InvalidPriorityError: If priority not in [0, 100]
            InvalidRegexError: If pattern invalid for regex type
        """

class ClusteringEngine:
    def create_clusters(self, items: List[str], similarity_threshold: float = 0.70,
                        algorithm: str = "dbscan") -> List[Cluster]:
        """
        Clusters similar items using specified algorithm.

        Algorithms:
        - dbscan: Density-based clustering (default)
        - hierarchical: Agglomerative clustering
        - simple: Threshold-based grouping

        Returns:
            List of clusters with canonical name and variants
        """

    def suggest_merge(self, cluster_id: str, user_id: str) -> MergeSuggestion:
        """Suggests merge with normalization rules."""

    def split_cluster(self, cluster_id: str, variants: List[str],
                      new_canonical: str) -> Tuple[Cluster, Cluster]:
        """Splits cluster into two by extracting variants."""

class NormalizationRuleStore:
    def create_rule(self, user_id: str, pattern: str, replacement: str,
                    rule_type: RuleType, priority: int) -> NormalizationRule:
        """
        Creates normalization rule.

        Validates:
        - Pattern not empty
        - Replacement not empty
        - Priority in [0, 100]
        - Regex valid if rule_type=regex
        """

    def find_matching_rules(self, text: str, user_id: str) -> List[NormalizationRule]:
        """Returns all rules that match text, ordered by priority."""

    def execute_rules(self, text: str, rules: List[NormalizationRule]) -> Optional[str]:
        """Executes rules in priority order, returns first match."""

class FuzzyMatcher:
    def calculate_similarity(self, text1: str, text2: str,
                            algorithm: str = "jaro_winkler") -> float:
        """
        Calculates similarity score [0.0, 1.0].

        Algorithms:
        - levenshtein: Edit distance (character insertions/deletions)
        - jaro_winkler: String similarity (prefix weighting)
        - soundex: Phonetic matching
        - metaphone: Phonetic matching (improved)
        """

    def find_best_matches(self, text: str, candidates: List[str],
                          threshold: float = 0.70) -> List[Match]:
        """Returns candidates above similarity threshold, sorted by score."""
```

---

### 5. Schemas / Tipos (Persistencia)

**NormalizationRule Schema:**

```json
{
  "rule_id": "rule_uber_all",
  "user_id": "user_darwin",
  "pattern": "UBER.*",
  "replacement": "Uber",
  "rule_type": "regex",
  "priority": 90,
  "similarity_threshold": null,
  "enabled": true,
  "created_at": "2025-10-24T10:00:00Z",
  "updated_at": "2025-10-24T10:00:00Z",
  "match_count": 47
}
```

**MerchantCluster Schema:**

```json
{
  "cluster_id": "cluster_amazon_1",
  "user_id": "user_darwin",
  "canonical_name": "Amazon",
  "variants": [
    {
      "raw_name": "AMAZON.COM",
      "frequency": 23,
      "similarity_to_canonical": 0.92
    },
    {
      "raw_name": "AMZN MKTP US",
      "frequency": 45,
      "similarity_to_canonical": 0.78
    }
  ],
  "similarity_score": 0.81,
  "transaction_count": 68,
  "status": "pending",
  "created_at": "2025-10-24T02:00:00Z"
}
```

**RuleExecutionLog Schema:**

```json
{
  "log_id": "log_12345",
  "rule_id": "rule_uber_all",
  "user_id": "user_darwin",
  "input_text": "UBER EATS PENDING",
  "output_text": "Uber",
  "match_type": "regex",
  "confidence": 1.0,
  "executed_at": "2025-10-24T10:05:00Z"
}
```

**Rule Types:**
- `exact` - Exact string match (case-insensitive)
- `regex` - Regular expression pattern
- `fuzzy` - Fuzzy string matching with threshold
- `soundex` - Phonetic matching

**Cluster Status:**
- `pending` - Awaiting user review
- `accepted` - User accepted merge
- `rejected` - User rejected merge
- `split` - Cluster was split

---

### 6. Validaciones & Estados

**Create Rule Validations:**
- Pattern: 1-500 chars, not empty
- Replacement: 1-200 chars, not empty
- Rule Type: Must be valid enum (exact, regex, fuzzy, soundex)
- Priority: [0, 100]
- Regex: Must be valid regex if rule_type=regex
- Fuzzy Threshold: [0.0, 1.0] if rule_type=fuzzy
- User: Cannot create duplicate pattern (case-insensitive)

**Normalization Validations:**
- Input text: Max 500 chars
- Rules executed in priority order (highest first)
- First matching rule wins
- If no match, return original text
- Log all executions for audit

**Cluster Validations:**
- Min similarity: [0.0, 1.0], default 0.70
- Min transactions per cluster: 2
- Canonical name: 1-200 chars
- Variants: At least 2 distinct raw names
- Cannot cluster already normalized names

**State Machine (Cluster):**
```
┌─────────┐
│ pending │──user accepts──▶│ accepted │──create rules──▶│ normalized │
└─────────┘                  └──────────┘                 └────────────┘
     │
     │ user rejects
     │
     ▼
│ rejected │
└──────────┘
     │
     │ user splits
     │
     ▼
│  split   │──create 2 new clusters──▶│ pending │
└──────────┘                           └─────────┘
```

---

### 7. Edge Cases

**EC1: Conflicting rules with same priority**
- Problem: Two rules match same text with priority 90
- **Solution:** Use creation timestamp as tiebreaker (older rule wins)
- Log warning: "Multiple rules matched with same priority"

**EC2: Rule creates circular normalization**
- Problem: Rule A: "Uber" → "Uber Eats", Rule B: "Uber Eats" → "Uber"
- **Solution:** Detect cycles during rule creation, reject if circular
- Validation: Simulate normalization chain, max depth 5

**EC3: Fuzzy match too broad**
- Problem: Threshold 0.50 matches "Apple" to "App Store"
- **Solution:** Enforce minimum threshold 0.70, warn if 0.70-0.75
- Preview shows all matches before saving

**EC4: Cluster with outlier variant**
- Problem: "Amazon", "AMZN", "Amazon Locker" clustered, but "Locker" is different service
- **Solution:** Show per-variant similarity to canonical in UI
- User can split outliers into separate cluster

**EC5: Batch normalization conflicts with user edits**
- Problem: User manually changed merchant name, batch job tries to overwrite
- **Solution:** Track user_edited flag, skip in batch if manually edited
- Log skipped transactions

**EC6: Rule disabled after transactions normalized**
- Problem: User disables rule, but 100 transactions still show normalized name
- **Solution:** Normalization is point-in-time (preserved)
- User can batch-reprocess to revert (applies current active rules)

**EC7: Regex catastrophic backtracking**
- Problem: Pattern `(a+)+b` on long string causes timeout
- **Solution:** Timeout regex execution at 100ms
- Validate common backtracking patterns on rule creation

**EC8: Multiple fuzzy matches with close scores**
- Problem: "MCDON" matches "McDonald's" (0.82) and "McDonnell" (0.80)
- **Solution:** Only normalize if highest score - second highest > 0.10 (confidence gap)
- Otherwise, no match (ambiguous)

---

### 8. Acceptance Criteria (Definition of Done)

**Rule Management:**
- [ ] User can create normalization rules (exact, regex, fuzzy, soundex)
- [ ] User can set rule priority [0, 100]
- [ ] User can test rule before saving (preview matches)
- [ ] User can enable/disable rules
- [ ] User can delete rules (soft delete if used)
- [ ] System enforces unique patterns per user
- [ ] System validates regex patterns

**Normalization:**
- [ ] System normalizes merchant names using rules (priority order)
- [ ] User sees normalized name in transaction list
- [ ] User can view original + normalized in drill-down
- [ ] System logs all normalization executions (audit trail)
- [ ] User can batch-normalize historical transactions
- [ ] System preserves original raw name (non-destructive)

**Clustering:**
- [ ] System auto-detects similar merchant names (nightly job)
- [ ] User can view cluster suggestions in ClusterViewer
- [ ] User can accept cluster merge (creates rules automatically)
- [ ] User can reject cluster suggestion
- [ ] User can split cluster into separate clusters
- [ ] System shows similarity scores for each variant
- [ ] User can configure similarity threshold [0.70, 1.0]

**Fuzzy Matching:**
- [ ] System supports Levenshtein distance algorithm
- [ ] System supports Jaro-Winkler algorithm
- [ ] System supports Soundex phonetic matching
- [ ] System supports Metaphone phonetic matching
- [ ] User can choose algorithm per rule
- [ ] User can set similarity threshold per fuzzy rule

**Multi-Domain:**
- [ ] Pattern applies to Healthcare (provider name normalization)
- [ ] Pattern applies to Legal (case/party name normalization)
- [ ] Pattern applies to Research (institution/author name normalization)

---

### 9. Logs & Provenance

**Structured Logs:**

```json
{
  "event": "rule_created",
  "rule_id": "rule_uber_all",
  "pattern": "UBER.*",
  "replacement": "Uber",
  "rule_type": "regex",
  "priority": 90,
  "user_id": "user_darwin",
  "timestamp": "2025-10-24T10:00:00Z"
}
```

```json
{
  "event": "merchant_normalized",
  "transaction_id": "txn_12345",
  "raw_name": "UBER EATS PENDING",
  "normalized_name": "Uber",
  "rule_id": "rule_uber_all",
  "match_type": "regex",
  "confidence": 1.0,
  "user_id": "user_darwin",
  "timestamp": "2025-10-24T10:05:00Z"
}
```

```json
{
  "event": "cluster_accepted",
  "cluster_id": "cluster_amazon_1",
  "canonical_name": "Amazon",
  "variants_count": 4,
  "transactions_affected": 68,
  "rules_created": 4,
  "user_id": "user_darwin",
  "timestamp": "2025-10-24T11:00:00Z"
}
```

```json
{
  "event": "cluster_split",
  "original_cluster_id": "cluster_amazon_1",
  "new_cluster_id": "cluster_aws_1",
  "variants_extracted": ["Amazon Web Services"],
  "transactions_moved": 8,
  "user_id": "user_darwin",
  "timestamp": "2025-10-24T12:00:00Z"
}
```

**Provenance Chain:**
```
Transaction Ingested (1.1)
  ↓
Raw Merchant Name Extracted (1.3)
  ↓
MerchantNormalizer.normalize() (3.8)
  ↓
Rules Applied (Priority Order)
  ↓
Normalized Name Stored
  ↓
Audit Trail Updated (RuleExecutionLog)
```

---

### 10. Risks & Deferred

**Risks:**
- **R1: Regex complexity** - Users may create inefficient patterns (catastrophic backtracking)
  - **Mitigation:** Timeout regex at 100ms, validate common bad patterns
- **R2: False positive fuzzy matches** - Low threshold matches unrelated names
  - **Mitigation:** Enforce min threshold 0.70, require confidence gap 0.10
- **R3: Cluster outliers** - Clustering algorithm groups dissimilar items
  - **Mitigation:** Show per-variant similarity, allow split operation
- **R4: Rule conflicts** - Multiple rules match same text
  - **Mitigation:** Strict priority ordering, tiebreak by creation time

**Deferred:**
- **D1: ML-based entity resolution** - Neural network for semantic matching (v2)
- **D2: Multi-language support** - Normalization across languages (v2)
- **D3: Streaming normalization** - Real-time processing (v2, batch only in v1)
- **D4: Global ruleset** - Share rules across users (v2)

---

## Machinery Layer (Sections 11-15)

### 11. Primitives Introduced

**Objective Layer (OL) - 4 new primitives:**

1. **MerchantNormalizer** - Normalize raw merchant names using rules
   - File: `docs/primitives/ol/MerchantNormalizer.md`
   - Methods: normalize, batch_normalize, add_rule, test_rule
   - Responsibilities: Rule execution, priority ordering, normalization logic

2. **ClusteringEngine** - Cluster similar transactions/entities
   - File: `docs/primitives/ol/ClusteringEngine.md`
   - Methods: create_clusters, suggest_merge, split_cluster, calculate_similarity
   - Responsibilities: DBSCAN/hierarchical clustering, similarity calculation

3. **NormalizationRuleStore** - Store and manage normalization rules
   - File: `docs/primitives/ol/NormalizationRuleStore.md`
   - Methods: create_rule, find_matching_rules, execute_rules, soft_delete
   - Responsibilities: Rule persistence, pattern matching, priority ordering

4. **FuzzyMatcher** - Calculate text similarity scores
   - File: `docs/primitives/ol/FuzzyMatcher.md`
   - Methods: calculate_similarity, find_best_matches, get_algorithm
   - Responsibilities: Levenshtein, Jaro-Winkler, Soundex, Metaphone algorithms

**Interaction Layer (IL) - 3 new components:**

5. **MerchantRulesManager** - Full CRUD UI for managing normalization rules
   - File: `docs/primitives/il/MerchantRulesManager.md`
   - Features: Rule list, create/edit/delete, priority management, enable/disable toggle
   - Responsibilities: Rule CRUD UI, test preview

6. **ClusterViewer** - Display clusters of similar entities
   - File: `docs/primitives/il/ClusterViewer.md`
   - Features: Cluster list, similarity heatmap, accept/reject/split actions
   - Responsibilities: Cluster visualization, merge/split UI

7. **RuleEditorDialog** - Dialog for creating/editing normalization rule
   - File: `docs/primitives/il/RuleEditorDialog.md`
   - Features: Pattern input, rule type selector, priority slider, test preview
   - Responsibilities: Rule creation UI, validation feedback

**Schemas - 3 new:**

8. **normalization-rule.schema.json** - Normalization rule definition
9. **merchant-cluster.schema.json** - Merchant cluster with variants
10. **rule-execution-log.schema.json** - Rule execution audit trail

---

### 12. Interlocks with Other Verticals

**Depends On:**
- **1.3 Normalization** - Raw merchant names extracted from transactions
- **3.2 Counterparty Registry** - Merchant entities for normalization
- **2.1 Transaction List** - Display normalized names in UI

**Used By:**
- **3.4 Tax Categorization** - Auto-classify based on normalized merchant name
- **2.3 Finance Dashboard** - Group spending by normalized merchant
- **4.2 Forecast** - Predict spending by merchant (normalized)

**Data Flow:**
```
Transaction Normalized (1.3)
  ↓
Raw Merchant Name Extracted
  ↓
MerchantNormalizer checks rules (3.8)
  ↓
Normalized Merchant Stored
  ↓
TaxCategoryClassifier uses normalized name (3.4)
  ↓
Dashboard groups by normalized merchant (2.3)
```

---

### 13. Reusability (Multi-Domain Generalization)

**Pattern: Text Normalization + Fuzzy Matching + Clustering**

This pattern applies to **any domain with text standardization and entity deduplication needs**:

**Finance:**
- Entity Type: Merchant names
- Normalization: "UBER EATS PENDING" → "Uber Eats"
- Clustering: Group transaction variants
- Use Case: Spending analysis by merchant

**Healthcare:**
- Entity Type: Provider names, medication names
- Normalization: "ST MARY'S HOSP" → "St. Mary's Hospital"
- Clustering: Deduplicate provider records
- Use Case: Provider network management

**Legal:**
- Entity Type: Case names, party names
- Normalization: "DOE V. SMITH" → "Doe v. Smith"
- Clustering: Group related cases
- Use Case: Case management system

**Research:**
- Entity Type: Institution names, author names
- Normalization: "MIT CSAIL" → "MIT Computer Science and AI Lab"
- Clustering: Deduplicate author affiliations
- Use Case: Citation management

**E-commerce:**
- Entity Type: Company names, product names
- Normalization: "AMZN" → "Amazon"
- Clustering: Vendor deduplication
- Use Case: Supplier consolidation

**HR:**
- Entity Type: Employee names across systems
- Normalization: "Smith, John" → "John Smith"
- Clustering: Deduplicate employee records
- Use Case: HR system integration

**Key Abstraction:**
```python
class TextNormalizer[TInput, TOutput]:
    """
    Universal pattern for text normalization and entity deduplication.

    Generic enough to apply across:
    - Finance: Merchant names
    - Healthcare: Provider/medication names
    - Legal: Case/party names
    - Research: Institution/author names
    - Any domain: Entity name standardization
    """
    rule_store: RuleStore[TRule]
    fuzzy_matcher: FuzzyMatcher[TText]
    clustering_engine: ClusterEngine[TItem]

    def normalize(self, raw_text: TInput) -> TOutput:
        """Apply normalization rules in priority order."""

    def cluster_similar(self, items: List[TInput], threshold: float) -> List[Cluster]:
        """Group similar items using fuzzy matching."""
```

---

### 14. Pattern Abstraction

**Pattern Name:** Text Normalization + Fuzzy Matching + Rule Engine

**Problem Statement:**
Users need to standardize inconsistent text data (merchant names, provider names, case names) to enable accurate grouping, analysis, and reporting. Manual normalization is time-consuming and error-prone.

**Solution Architecture:**

1. **Rule Engine** - User-defined rules with priority ordering (exact > regex > fuzzy)
2. **Fuzzy Matching** - Multiple algorithms for string similarity (Levenshtein, Jaro-Winkler, Soundex)
3. **Clustering** - Auto-detect similar entities using DBSCAN/hierarchical clustering
4. **Batch Processing** - Normalize historical data efficiently
5. **Audit Trail** - Log all normalization executions for provenance

**Components:**
- **TextNormalizer** - Apply normalization rules to raw text
- **FuzzyMatcher** - Calculate similarity scores between strings
- **ClusterEngine** - Group similar items using clustering algorithms
- **RuleStore** - Persist and execute normalization rules

**When to Use:**
- ✅ Need to standardize inconsistent text data
- ✅ Have recurring patterns (e.g., same merchant, different formats)
- ✅ Want user-defined normalization rules
- ✅ Need fuzzy matching for variations
- ✅ Want to auto-detect similar entities
- ❌ Text is already standardized (no normalization needed)
- ❌ Semantic understanding required (use NLP instead)

**Generic Pattern:**
```
1. Ingest raw text (transaction, record, document)
2. Load user's normalization rules (priority order)
3. Try exact match → regex match → fuzzy match
4. Apply first matching rule (highest priority)
5. If no match, keep original text
6. Log execution for audit trail
7. Periodically cluster similar entities
8. Suggest merge/normalization rules to user
```

---

### 15. Métricas de Madurez

**Coverage Metrics:**
- % of transactions with normalized merchant (target: >80%)
- % of merchants with at least 1 rule (target: >60%)
- % of suggested clusters accepted (target: >50%)

**Quality Metrics:**
- Normalization accuracy (user edits/total, target: <5%)
- Fuzzy match precision (false positives, target: <10%)
- Cluster purity (outliers per cluster, target: <15%)

**Performance Metrics:**
- Normalization latency (target: <50ms p95)
- Batch normalization throughput (target: >1000 txns/sec)
- Clustering job runtime (target: <5 min for 10k merchants)

**User Engagement:**
- Avg rules per user (target: >10)
- % users with at least 1 custom rule (target: >70%)
- % clusters reviewed (target: >60%)

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**
- All operations require valid bearer token
- Users can only manage their own rules (user_id scoped)
- Rules are user-private (no cross-user access)
- Cluster suggestions are user-scoped

**Input Validation:**
- Pattern: Max 500 chars, validate regex syntax
- Replacement: Max 200 chars, sanitize for XSS
- Priority: Range [0, 100]
- Fuzzy threshold: Range [0.0, 1.0]

**Regex Injection Prevention:**
- Timeout regex execution at 100ms (prevent ReDoS)
- Validate common catastrophic backtracking patterns
- Example blocked: `(a+)+b`, `(a*)*`, `(a|a)*`

**SQL Injection Prevention:**
- Use parameterized queries for all database operations
- Example: `SELECT * FROM rules WHERE user_id = ? AND pattern ILIKE ?`

**Trust Construction Elements:**
- **Ownership verification:** All rules checked against user_id
- **Audit trail:** All normalizations logged with rule_id + timestamp
- **Non-destructive:** Original text always preserved
- **Undo support:** User can disable rule to revert
- **Rate limiting:** Create rule: 100 per hour, Normalize: 10k per hour

**Data Privacy:**
- Merchant names may contain sensitive info (e.g., medical providers)
- Do not log full merchant names in external systems
- Redact in error messages: "Failed to normalize merchant 'MC***'"

---

### 17. Performance Characteristics

**Target Latencies (p95):**
- `POST /api/normalization-rules/test` (preview): <200ms
- `MerchantNormalizer.normalize()` (single): <10ms
- `MerchantNormalizer.batch_normalize()` (1000 items): <500ms
- `ClusteringEngine.create_clusters()` (1000 items): <3s

**Scalability:**
- Rules per user: Unlimited (typical: 10-100)
- Transactions per batch normalization: 10,000 max
- Clustering job: Up to 50,000 unique merchants

**Database Indexes:**
```sql
-- Normalization rules
CREATE INDEX idx_rules_user_priority ON normalization_rules(user_id, enabled, priority DESC);
CREATE INDEX idx_rules_pattern ON normalization_rules(user_id, pattern);

-- Rule execution logs
CREATE INDEX idx_execution_logs_rule ON rule_execution_logs(rule_id, executed_at DESC);
CREATE INDEX idx_execution_logs_user ON rule_execution_logs(user_id, executed_at DESC);

-- Merchant clusters
CREATE INDEX idx_clusters_user_status ON merchant_clusters(user_id, status);
CREATE INDEX idx_clusters_similarity ON merchant_clusters(similarity_score DESC);
```

**Caching Strategy:**
- Cache user's rules (TTL: 5 minutes, invalidate on create/update/delete)
- Cache normalized names (TTL: 1 hour, invalidate on rule change)
- Cache cluster suggestions (TTL: 24 hours, regenerate nightly)

**Background Jobs:**
- **Nightly:** Generate cluster suggestions (scan all merchants)
- **Hourly:** Batch normalize new transactions
- **Weekly:** Archive old execution logs (>90 days)

**Optimization:**
- Index rules by pattern prefix for fast exact match lookup
- Use trie structure for regex pattern matching
- Cache compiled regex patterns (avoid recompilation)
- Parallelize fuzzy matching across candidates

---

### 18. Observability

**Metrics:**
```
normalization.rules.created.count (counter, labels: user_id, rule_type)
normalization.executions.count (counter, labels: rule_id, match_type)
normalization.latency (histogram, labels: batch_size)
clustering.suggestions.count (counter, labels: user_id)
clustering.accepted.count (counter, labels: user_id)
clustering.runtime (histogram, labels: item_count)
fuzzy.match.latency (histogram, labels: algorithm)
```

**Structured Logs:**
- All rule creations (user_id, pattern, rule_type)
- All normalizations (transaction_id, rule_id, confidence)
- All cluster operations (cluster_id, action, variants_count)
- Regex timeouts (pattern, execution_time)

**Dashboards:**
- Normalization coverage % (trend over time)
- Top 10 rules by usage (bar chart)
- Clustering acceptance rate (gauge, target >50%)
- Fuzzy match latency by algorithm (line chart)

**Alerts:**
- Normalization latency >100ms p95 (investigate database performance)
- Clustering job runtime >10 min (investigate data size)
- Regex timeout rate >1% (investigate malicious patterns)
- Cluster acceptance rate <30% (investigate clustering quality)

**Tracing:**
- Trace normalization flow: raw_text → rule_match → normalized_text
- Include transaction_id, rule_id, match_type, confidence in trace
- Trace clustering flow: items → similarity_matrix → clusters

---

### 19. Testing Strategy

**Unit Tests:**

```python
# MerchantNormalizer tests
def test_normalize_exact_match():
    normalizer = MerchantNormalizer(user_id="user_123")
    normalizer.add_rule(pattern="UBER EATS", replacement="Uber Eats", rule_type="exact", priority=90)
    result = normalizer.normalize("UBER EATS")
    assert result.normalized_name == "Uber Eats"
    assert result.rule_id == "rule_uber_eats_1"
    assert result.confidence == 1.0

def test_normalize_regex_match():
    normalizer.add_rule(pattern="UBER.*", replacement="Uber", rule_type="regex", priority=85)
    result = normalizer.normalize("UBER EATS PENDING")
    assert result.normalized_name == "Uber"

def test_normalize_fuzzy_match():
    normalizer.add_rule(pattern="McDonald's", replacement="McDonald's", rule_type="fuzzy", priority=80, threshold=0.80)
    result = normalizer.normalize("MCDONALDS #1234")
    assert result.normalized_name == "McDonald's"
    assert result.confidence >= 0.80

def test_normalize_priority_order():
    # Exact match (priority 95) should win over regex (priority 85)
    normalizer.add_rule(pattern="UBER EATS", replacement="Uber Eats", rule_type="exact", priority=95)
    normalizer.add_rule(pattern="UBER.*", replacement="Uber", rule_type="regex", priority=85)
    result = normalizer.normalize("UBER EATS")
    assert result.normalized_name == "Uber Eats"  # Exact match wins

# FuzzyMatcher tests
def test_levenshtein_distance():
    matcher = FuzzyMatcher()
    score = matcher.calculate_similarity("kitten", "sitting", algorithm="levenshtein")
    assert 0.55 <= score <= 0.65  # 3 edits out of 7 chars

def test_jaro_winkler():
    matcher = FuzzyMatcher()
    score = matcher.calculate_similarity("MARTHA", "MARHTA", algorithm="jaro_winkler")
    assert score >= 0.90  # High similarity (transposition)

# ClusteringEngine tests
def test_create_clusters_dbscan():
    engine = ClusteringEngine()
    items = ["AMAZON.COM", "AMZN MKTP US", "AMAZON PRIME", "WALMART"]
    clusters = engine.create_clusters(items, similarity_threshold=0.70, algorithm="dbscan")
    assert len(clusters) == 2  # Amazon cluster + Walmart cluster
    amazon_cluster = [c for c in clusters if c.canonical_name == "Amazon"][0]
    assert len(amazon_cluster.variants) == 3

def test_split_cluster():
    engine = ClusteringEngine()
    original = create_cluster(["AMAZON.COM", "Amazon Web Services"])
    cluster1, cluster2 = engine.split_cluster(original.cluster_id, ["Amazon Web Services"], "AWS")
    assert len(cluster1.variants) == 1  # AMAZON.COM
    assert len(cluster2.variants) == 1  # Amazon Web Services
```

**Integration Tests:**

```python
def test_end_to_end_normalization():
    # 1. Create rule
    response = client.post("/api/normalization-rules", json={
        "pattern": "UBER.*",
        "replacement": "Uber",
        "rule_type": "regex",
        "priority": 90
    })
    assert response.status_code == 201
    rule_id = response.json()["rule_id"]

    # 2. Create transaction
    transaction = create_transaction(merchant="UBER EATS PENDING")

    # 3. Normalize
    response = client.post("/api/normalization/batch", json={
        "transaction_ids": [transaction.transaction_id]
    })
    assert response.status_code == 200
    assert response.json()["normalized_count"] == 1

    # 4. Verify
    txn = client.get(f"/api/transactions/{transaction.transaction_id}")
    assert txn.json()["normalized_merchant"] == "Uber"

def test_cluster_accept_flow():
    # 1. Generate cluster
    cluster = create_cluster(["AMAZON.COM", "AMZN MKTP US"])

    # 2. Accept
    response = client.post(f"/api/merchant-clusters/{cluster.cluster_id}/accept")
    assert response.status_code == 200
    assert len(response.json()["rules_created"]) == 2

    # 3. Verify rules exist
    rules = client.get("/api/normalization-rules")
    assert len([r for r in rules.json()["rules"] if r["replacement"] == "Amazon"]) == 2
```

**Multi-Domain Tests:**
- Finance: Normalize merchant name ("UBER EATS" → "Uber")
- Healthcare: Normalize provider name ("ST MARY'S" → "St. Mary's Hospital")
- Legal: Normalize case name ("DOE V. SMITH" → "Doe v. Smith")
- Research: Normalize institution ("MIT CSAIL" → "MIT")

---

### 20. Operations Runbook

**Deployment:**

1. **Database Migrations:**
```sql
-- Create normalization_rules table
CREATE TABLE normalization_rules (
    rule_id VARCHAR(100) PRIMARY KEY,
    user_id UUID NOT NULL,
    pattern VARCHAR(500) NOT NULL,
    replacement VARCHAR(200) NOT NULL,
    rule_type VARCHAR(20) NOT NULL CHECK (rule_type IN ('exact', 'regex', 'fuzzy', 'soundex')),
    priority INTEGER NOT NULL CHECK (priority >= 0 AND priority <= 100),
    similarity_threshold DECIMAL(3,2),
    enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    match_count INTEGER DEFAULT 0,
    UNIQUE(user_id, pattern)
);

-- Create merchant_clusters table
CREATE TABLE merchant_clusters (
    cluster_id VARCHAR(100) PRIMARY KEY,
    user_id UUID NOT NULL,
    canonical_name VARCHAR(200) NOT NULL,
    variants JSONB NOT NULL,
    similarity_score DECIMAL(3,2) NOT NULL,
    transaction_count INTEGER NOT NULL,
    status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'accepted', 'rejected', 'split')),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Create rule_execution_logs table
CREATE TABLE rule_execution_logs (
    log_id VARCHAR(100) PRIMARY KEY,
    rule_id VARCHAR(100) NOT NULL,
    user_id UUID NOT NULL,
    input_text VARCHAR(500) NOT NULL,
    output_text VARCHAR(200) NOT NULL,
    match_type VARCHAR(20) NOT NULL,
    confidence DECIMAL(3,2),
    executed_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (rule_id) REFERENCES normalization_rules(rule_id)
);

-- Add normalized_merchant to transactions table
ALTER TABLE transactions ADD COLUMN normalized_merchant VARCHAR(200);
ALTER TABLE transactions ADD COLUMN normalization_rule_id VARCHAR(100);
```

2. **Indexes:**
```sql
CREATE INDEX idx_rules_user_priority ON normalization_rules(user_id, enabled, priority DESC);
CREATE INDEX idx_rules_pattern ON normalization_rules(user_id, pattern);
CREATE INDEX idx_clusters_user_status ON merchant_clusters(user_id, status);
CREATE INDEX idx_execution_logs_rule ON rule_execution_logs(rule_id, executed_at DESC);
```

**Monitoring:**

- **Health Check:** `GET /api/health/normalization` - Returns OK if MerchantNormalizer can normalize
- **Metric Alerts:**
  - Normalization latency >100ms p95 → investigate database performance
  - Regex timeout rate >1% → investigate malicious patterns
  - Clustering job runtime >10 min → investigate data size

**Common Issues:**

**Issue 1: Regex timeout**
- **Symptom:** Rule execution fails with "Regex timeout"
- **Debug:**
  1. Check pattern for catastrophic backtracking: `(a+)+`, `(a*)*`
  2. Test pattern with sample data
  3. Check execution time metrics
- **Fix:** Rewrite pattern to avoid backtracking, or use exact match

**Issue 2: Fuzzy match too broad**
- **Symptom:** Unrelated merchants normalized together (e.g., "Apple" → "App Store")
- **Debug:**
  1. Check similarity threshold (should be >=0.70)
  2. Review fuzzy match logs for false positives
  3. Test with different thresholds
- **Fix:** Increase threshold to 0.80, or switch to exact/regex rule

**Issue 3: Cluster suggestions not appearing**
- **Symptom:** ClusterViewer shows no suggestions
- **Debug:**
  1. Check clustering job logs (runs nightly)
  2. Verify min_similarity threshold (default 0.70)
  3. Check if enough merchants (need at least 2 similar)
- **Fix:** Lower threshold to 0.65, or manually run clustering job

**Issue 4: Rule not applying**
- **Symptom:** Transaction not normalized despite matching rule
- **Debug:**
  1. Check rule enabled status
  2. Verify rule priority (higher priority rules may override)
  3. Check rule execution logs
- **Fix:** Increase priority, or check for conflicting rules

**Incident Response:**

```bash
# Query rules for user
SELECT rule_id, pattern, replacement, rule_type, priority, enabled, match_count
FROM normalization_rules
WHERE user_id = 'user_darwin'
ORDER BY priority DESC;

# Force normalize transaction
curl -X POST /api/normalization/batch \
  -H "Authorization: Bearer TOKEN" \
  -d '{"transaction_ids": ["txn_123"], "force_reprocess": true}'

# Test rule without saving
curl -X POST /api/normalization-rules/test \
  -H "Authorization: Bearer TOKEN" \
  -d '{"pattern": "UBER.*", "rule_type": "regex"}'

# Regenerate clusters
python /app/scripts/generate_clusters.py --user-id=user_darwin --min-similarity=0.70

# Archive old logs (>90 days)
DELETE FROM rule_execution_logs WHERE executed_at < NOW() - INTERVAL '90 days';
```

---

## 🎯 Summary

Vertical 3.8 delivers a **text normalization and fuzzy matching system** with:

✅ **4 OL Primitives** (MerchantNormalizer, ClusteringEngine, NormalizationRuleStore, FuzzyMatcher)
✅ **3 IL Components** (MerchantRulesManager, ClusterViewer, RuleEditorDialog)
✅ **3 Schemas** (normalization-rule, merchant-cluster, rule-execution-log)
✅ **20 Complete Sections** (Product, Machinery, Cross-Cutting)
✅ **Multi-Domain Pattern** (Finance → Merchant names, Healthcare → Provider names, Legal → Case names, Research → Institution names)

**Finance Instantiation:**
- Normalize merchant names: "UBER EATS PENDING" → "Uber"
- Cluster variants: "AMZN MKTP US", "Amazon.com" → "Amazon"
- Fuzzy matching with confidence scores
- User-defined normalization rules

**Universal Pattern: Text Normalization + Fuzzy Matching**
- Rule engine with priority ordering
- Multiple fuzzy matching algorithms (Levenshtein, Jaro-Winkler, Soundex)
- Clustering for auto-detection of similar entities
- Batch processing for historical data

**Next:** 3.9 Custom Fields (user-defined metadata, dynamic schema extension)
