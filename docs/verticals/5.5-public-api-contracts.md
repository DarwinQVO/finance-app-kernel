# Vertical 5.5: Public API Contracts

**Status:** ✅ Complete
**Last Updated:** 2025-10-25

Complete specification for public REST API contracts, webhook system, versioning strategy, rate limiting, and authentication for external integrations.

---

## Product Layer (Sections 1-10)

### 1. User Story

**As an** external developer integrating with the Truth Construction system,
**I want** a stable, versioned REST API with comprehensive documentation,
**So that** I can programmatically upload documents, retrieve observations, manage entities, and receive real-time notifications via webhooks without tight coupling to internal implementation details.

**Acceptance Criteria:**
- REST API with OpenAPI 3.0 specification
- Webhook system for real-time event notifications
- API versioning (v1, v2) with clear deprecation policy
- Rate limiting (per-tenant, per-endpoint)
- Multiple authentication methods (API keys, OAuth2)
- Comprehensive error responses with troubleshooting guidance
- Sandbox environment for testing

---

### 2. Business Context

**Why This Matters:**

External integrations are critical for adoption:
- **SaaS Partners:** Embed document processing into their workflows
- **Enterprise Customers:** Integrate with existing ERP/CRM systems
- **Developers:** Build custom applications on top of our primitives
- **Compliance:** Provide audit trail for all external API access

**Without Public API:**
- ❌ Customers forced to use UI manually (doesn't scale)
- ❌ No programmatic access to observations/entities
- ❌ Integration requires custom one-off solutions
- ❌ No real-time notifications for workflow automation

**With Public API:**
- ✅ Self-service integration via REST API
- ✅ Real-time webhooks for event-driven workflows
- ✅ Stable contracts with versioning (backward compatibility)
- ✅ Developer ecosystem and third-party integrations

---

### 3. Scope

**In Scope:**

1. **REST API Endpoints:**
   - Upload Management: POST /v1/uploads, GET /v1/uploads/:id
   - Observations: GET /v1/observations, GET /v1/observations/:id
   - Entities: GET /v1/entities, POST /v1/entities, PATCH /v1/entities/:id
   - Reconciliation: GET /v1/reconciliations, POST /v1/reconciliations/trigger
   - Audit Logs: GET /v1/audit-logs (for compliance users)

2. **Webhook System:**
   - Event types: upload.completed, observation.created, entity.resolved, reconciliation.completed
   - Webhook registration: POST /v1/webhooks, DELETE /v1/webhooks/:id
   - Retry logic (exponential backoff, max 5 retries)
   - Signature verification (HMAC-SHA256)

3. **API Versioning:**
   - v1 (stable), v2 (future migrations)
   - Deprecation policy (6-month notice, 12-month sunset)
   - Version negotiation via URL path (/v1/, /v2/) and Accept header

4. **Rate Limiting:**
   - Per-tenant limits (1000 req/hour for starter, 10000 req/hour for enterprise)
   - Per-endpoint limits (burst protection for expensive operations)
   - Rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)

5. **Authentication:**
   - API Keys (simple, recommended for server-to-server)
   - OAuth2 (for user-delegated access, third-party apps)
   - Tenant isolation (API key scoped to tenant_id)

**Out of Scope:**
- GraphQL API (future consideration)
- WebSocket/streaming API (use webhooks for real-time)
- SDK libraries (focus on REST API, SDKs can be built on top)

---

### 4. Core Workflow

**End-to-End API Integration Flow:**

```
1. Developer Registration
   ├─ Sign up for account
   ├─ Navigate to API Settings → "API Keys"
   └─ Generate API Key (automatic tenant_id scoping)

2. Test in Sandbox
   ├─ Use sandbox API key (sandbox.api.truthconstruction.com)
   ├─ Upload test document: POST /v1/uploads
   ├─ Poll for completion: GET /v1/uploads/:id (status=parsed)
   └─ Retrieve observations: GET /v1/observations?upload_id=:id

3. Setup Webhooks (Optional)
   ├─ Register webhook: POST /v1/webhooks
   │  { "url": "https://example.com/webhook", "events": ["upload.completed"] }
   ├─ Verify webhook signature (HMAC-SHA256)
   └─ Handle events: { "event": "upload.completed", "upload_id": "..." }

4. Production Integration
   ├─ Generate production API key
   ├─ Implement error handling (retry logic, rate limit backoff)
   ├─ Monitor API usage: GET /v1/usage (requests, rate limits, errors)
   └─ Set up alerting for webhook failures

5. Ongoing Maintenance
   ├─ Subscribe to API changelog (email notifications)
   ├─ Handle deprecation notices (6-month advance warning)
   └─ Migrate to v2 before v1 sunset (12-month window)
```

---

### 5. User Interface Requirements

**API Developer Portal (Web UI):**

1. **API Keys Management Page:**
   - List all API keys (name, created_at, last_used_at, scopes)
   - "Generate New Key" button → modal with scopes selection (read, write, admin)
   - Revoke key button (with confirmation dialog)
   - Copy to clipboard button for keys

2. **Webhooks Management Page:**
   - List all webhooks (url, events, status=active/failed, last_delivery_at)
   - "Add Webhook" button → form (URL, event types, secret)
   - Test webhook button (send test event)
   - View delivery logs (timestamp, status_code, response_time, retry_count)

3. **API Usage Dashboard:**
   - Request count chart (last 7 days, by endpoint)
   - Rate limit usage gauge (current/limit, resets in X minutes)
   - Error rate chart (4xx, 5xx errors by endpoint)
   - Latency histogram (p50, p95, p99)

4. **API Documentation Page:**
   - Embedded OpenAPI/Swagger UI (interactive API explorer)
   - Authentication guide (API key vs OAuth2)
   - Code examples (curl, Python, JavaScript)
   - Webhook event reference (payload schemas)

**No UI for:**
- API requests themselves (programmatic only via REST)
- Webhook delivery (automatic, background process)

---

### 6. Data Requirements

**API Request/Response:**

Every API call requires:
- **Authentication:** API key in `Authorization: Bearer <api_key>` header OR OAuth2 token
- **Tenant Isolation:** API key automatically scopes to tenant_id (no cross-tenant access)
- **Content-Type:** application/json for POST/PATCH requests

**Webhook Event Payload:**

Every webhook delivery includes:
- **Event Type:** upload.completed, observation.created, entity.resolved, reconciliation.completed
- **Timestamp:** ISO 8601 UTC timestamp when event occurred
- **Resource ID:** upload_id, observation_id, entity_id, etc.
- **Signature:** X-Webhook-Signature header (HMAC-SHA256 of payload with secret)
- **Retry Count:** X-Webhook-Retry header (0 for first attempt, 1-5 for retries)

**Rate Limit Data:**

Every API response includes headers:
- **X-RateLimit-Limit:** Max requests allowed in window (e.g., 1000)
- **X-RateLimit-Remaining:** Requests remaining in current window (e.g., 847)
- **X-RateLimit-Reset:** Unix timestamp when limit resets (e.g., 1730000000)

When rate limit exceeded:
- **HTTP 429 Too Many Requests**
- **Retry-After:** Seconds to wait before retrying (e.g., 300)

---

### 7. Business Rules

**BR-5.5-1: API Key Scoping**
- API keys are scoped to tenant_id (cannot access other tenants' data)
- API keys have permission scopes: read, write, admin (cannot escalate privileges)
- API keys can be time-limited (expires_at optional, for temporary access)

**BR-5.5-2: Rate Limiting Tiers**
- Starter: 1000 req/hour (burst: 50 req/min)
- Professional: 5000 req/hour (burst: 200 req/min)
- Enterprise: 10000 req/hour (burst: 500 req/min)
- Expensive endpoints (POST /v1/uploads, POST /v1/reconciliations/trigger) have lower limits

**BR-5.5-3: Webhook Retry Policy**
- Retry on HTTP 5xx or timeout (not 4xx)
- Exponential backoff: 5s, 25s, 125s, 625s, 3125s (max 5 retries)
- After 5 failed retries, mark webhook as "failed" and email admin
- Manual "Resume" button to re-enable failed webhook

**BR-5.5-4: API Versioning & Deprecation**
- New endpoints default to latest stable version (v1 currently)
- Breaking changes require new version (v2)
- Deprecation notice: 6 months advance warning (email + changelog)
- Sunset period: 12 months after deprecation notice (then v1 returns HTTP 410 Gone)

**BR-5.5-5: Webhook Signature Verification**
- Every webhook includes X-Webhook-Signature: sha256=<hmac>
- HMAC computed with webhook secret (user-provided during webhook registration)
- Consumer MUST verify signature before processing (prevent spoofing)

---

### 8. Edge Cases

**EC-5.5-1: API Key Leaked**
- **Scenario:** Developer accidentally commits API key to public GitHub repo
- **Detection:** Monitor for unusual request patterns (new IPs, high volume, unexpected endpoints)
- **Response:** Email alert to tenant admin, UI banner "Suspicious API activity detected, review API keys"
- **Remediation:** Admin revokes compromised key, generates new one

**EC-5.5-2: Webhook Endpoint Down**
- **Scenario:** Consumer's webhook endpoint returns HTTP 503 for 2 hours
- **Behavior:** System retries 5 times with exponential backoff, then marks webhook as "failed"
- **Notification:** Email to webhook owner with delivery logs
- **Recovery:** Consumer fixes endpoint, clicks "Resume" button in UI → system resumes deliveries

**EC-5.5-3: Rate Limit Exceeded During Bulk Upload**
- **Scenario:** Developer uploads 500 documents in tight loop, hits rate limit after 50
- **Response:** HTTP 429 with Retry-After: 60 (wait 1 minute)
- **Best Practice:** Use batch endpoints (POST /v1/uploads/batch) to reduce request count

**EC-5.5-4: API Version Sunset**
- **Scenario:** v1 deprecated 6 months ago, sunset date is today
- **Behavior:** All v1 endpoints return HTTP 410 Gone with message "API v1 has been sunset, please migrate to v2: https://docs.example.com/v2-migration"
- **Notification:** Emails sent at 6 months (deprecation), 3 months, 1 month, 1 week before sunset

**EC-5.5-5: Webhook Signature Mismatch**
- **Scenario:** Consumer receives webhook but signature verification fails (attacker spoofing)
- **Response:** Consumer's code rejects webhook, logs security incident
- **Investigation:** Consumer contacts support → check webhook secret rotation, ensure HTTPS

**EC-5.5-6: OAuth2 Token Expired Mid-Request**
- **Scenario:** OAuth2 access token expires during long-running API call
- **Response:** HTTP 401 Unauthorized with error: "access_token_expired"
- **Remediation:** Consumer uses refresh_token to get new access_token, retries request

---

### 9. Success Metrics

**API Adoption (Product Metrics):**
- **Active API Keys:** 500 active keys within 6 months of launch (target)
- **API Request Volume:** 1M requests/month across all tenants (target)
- **Webhook Registrations:** 200 active webhooks within 6 months
- **Integration Partners:** 10 SaaS partners integrate via API (target)

**API Quality (Engineering Metrics):**
- **API Uptime:** 99.9% uptime (SLA for production API)
- **API Latency:** p95 < 500ms for read endpoints, p95 < 2s for write endpoints
- **Error Rate:** < 1% of requests return 5xx errors
- **Webhook Delivery Success:** > 95% of webhooks delivered on first attempt

**Developer Experience (UX Metrics):**
- **Time to First API Call:** < 10 minutes (from signup to successful API call)
- **Documentation Completeness:** 100% of endpoints documented in OpenAPI spec
- **Error Message Clarity:** < 5% of API errors result in support tickets (clear error messages reduce friction)

**Security Metrics:**
- **API Key Rotation Rate:** 50% of keys rotated within 12 months (security best practice)
- **Failed Auth Attempts:** < 0.1% of requests (indicates low brute-force attacks)
- **Webhook Signature Verification:** 100% of webhooks include signature (security requirement)

---

### 10. Open Questions & Decisions

**OQ-5.5-1: GraphQL API?**
- **Question:** Should we also provide a GraphQL API for flexible querying?
- **Decision:** ❌ NOT in v1. Focus on REST API first, evaluate GraphQL based on customer demand. REST is simpler, more widely understood, and sufficient for 90% of use cases.

**OQ-5.5-2: SDK Libraries?**
- **Question:** Should we provide official SDKs (Python, JavaScript, Go)?
- **Decision:** ⏸️ DEFER. REST API with OpenAPI spec is sufficient for v1. SDKs can be auto-generated or community-built. Focus on excellent REST API design first.

**OQ-5.5-3: Bulk Operations?**
- **Question:** Should we provide batch endpoints (e.g., POST /v1/uploads/batch)?
- **Decision:** ✅ YES. Add batch endpoints for uploads, observations retrieval, and entity updates to reduce rate limit friction.

**OQ-5.5-4: Webhook Event Filtering?**
- **Question:** Should webhooks support filtering (e.g., only upload.completed for specific parser types)?
- **Decision:** ✅ YES. Add optional `filters` field to webhook registration: `{ "filters": { "parser_type": "bank_statement" } }`.

**OQ-5.5-5: API Playground?**
- **Question:** Should we provide an interactive API playground (beyond Swagger UI)?
- **Decision:** ✅ YES. Embed Swagger UI in documentation portal with "Try It Out" feature. Provide sandbox API keys for testing.

---

## Machinery Layer (Sections 11-15)

### 11. System Architecture

**High-Level Architecture:**

```
┌────────────────────────────────────────────────────────────────┐
│                        Public API Layer                        │
│  (REST API, Webhooks, Rate Limiting, Authentication)          │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                      API Gateway (Kong/Nginx)                  │
│  - Rate limiting (Redis counters)                              │
│  - Authentication (API key validation, OAuth2 token verify)    │
│  - Request logging (audit trail)                               │
│  - CORS handling                                               │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                      API Service (Node.js/Go)                  │
│  - Route handlers (OpenAPI 3.0 spec)                           │
│  - Request validation (JSON schema)                            │
│  - Response serialization (JSON)                               │
│  - Error normalization (RFC 7807 Problem Details)              │
└────────────────────────────────────────────────────────────────┘
                              │
                    ┌─────────┴─────────┐
                    ▼                   ▼
┌──────────────────────────┐  ┌──────────────────────────┐
│   Business Logic Layer   │  │   Webhook Service        │
│  (Upload, Observations,  │  │  - Event queue (Kafka)   │
│   Entities, Reconcile)   │  │  - Delivery worker       │
└──────────────────────────┘  │  - Retry logic           │
            │                 │  - Signature generation  │
            ▼                 └──────────────────────────┘
┌──────────────────────────┐
│   Data Access Layer      │
│  (Database queries,      │
│   ProvenanceLedger)      │
└──────────────────────────┘
```

**Key Components:**

1. **APIGateway (OL Primitive):**
   - Handles authentication, rate limiting, CORS, request logging
   - Implemented as middleware (Kong Gateway or custom Node.js middleware)
   - Uses RateLimiter primitive for request throttling

2. **APIRouter (OL Primitive):**
   - Maps HTTP requests to business logic handlers
   - Validates requests against OpenAPI schema
   - Serializes responses to JSON

3. **WebhookDispatcher (OL Primitive):**
   - Listens for events (upload.completed, observation.created, etc.)
   - Queues webhook deliveries (Kafka/Redis)
   - Retries failed deliveries with exponential backoff

4. **APIKeyValidator (OL Primitive):**
   - Validates API keys against database
   - Checks tenant_id scoping, permission scopes, expiration
   - Logs authentication attempts for audit trail

5. **OAuth2Provider (OL Primitive):**
   - Issues access tokens, refresh tokens
   - Validates tokens on each request
   - Handles token expiration, revocation

---

### 12. Data Model

**APIKey (Database Table):**

```sql
CREATE TABLE api_keys (
  api_key_id UUID PRIMARY KEY,
  tenant_id VARCHAR(255) NOT NULL,
  key_hash VARCHAR(255) NOT NULL, -- bcrypt hash of actual key
  key_prefix VARCHAR(16) NOT NULL, -- e.g., "tc_live_abc123" (for UI display)
  scopes TEXT[] NOT NULL, -- ['read', 'write', 'admin']
  expires_at TIMESTAMP NULL, -- NULL = never expires
  last_used_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  revoked_at TIMESTAMP NULL,
  revoked_by VARCHAR(255) NULL,
  metadata JSONB -- { "name": "Production Key", "created_by": "usr_admin" }
);

CREATE INDEX idx_api_keys_tenant ON api_keys(tenant_id);
CREATE INDEX idx_api_keys_hash ON api_keys(key_hash);
```

**Webhook (Database Table):**

```sql
CREATE TABLE webhooks (
  webhook_id UUID PRIMARY KEY,
  tenant_id VARCHAR(255) NOT NULL,
  url TEXT NOT NULL,
  secret VARCHAR(255) NOT NULL, -- HMAC secret for signature
  events TEXT[] NOT NULL, -- ['upload.completed', 'observation.created']
  filters JSONB, -- { "parser_type": "bank_statement" }
  status VARCHAR(50) DEFAULT 'active', -- active, failed, disabled
  last_delivery_at TIMESTAMP NULL,
  failure_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP
);

CREATE INDEX idx_webhooks_tenant ON webhooks(tenant_id);
```

**WebhookDelivery (Database Table):**

```sql
CREATE TABLE webhook_deliveries (
  delivery_id UUID PRIMARY KEY,
  webhook_id UUID NOT NULL REFERENCES webhooks(webhook_id),
  event_type VARCHAR(100) NOT NULL,
  payload JSONB NOT NULL,
  signature VARCHAR(255) NOT NULL, -- HMAC-SHA256 signature
  status VARCHAR(50) NOT NULL, -- pending, success, failed
  status_code INTEGER, -- HTTP status code from webhook endpoint
  response_time_ms INTEGER,
  retry_count INTEGER DEFAULT 0,
  next_retry_at TIMESTAMP, -- NULL if no retry needed
  delivered_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_webhook_deliveries_webhook ON webhook_deliveries(webhook_id);
CREATE INDEX idx_webhook_deliveries_next_retry ON webhook_deliveries(next_retry_at) WHERE status = 'pending';
```

**APIUsageLog (Database Table / Timeseries):**

```sql
CREATE TABLE api_usage_logs (
  log_id UUID PRIMARY KEY,
  tenant_id VARCHAR(255) NOT NULL,
  api_key_id UUID NULL, -- NULL for OAuth2 tokens
  endpoint VARCHAR(255) NOT NULL, -- e.g., "GET /v1/uploads/:id"
  http_method VARCHAR(10) NOT NULL,
  http_status INTEGER NOT NULL,
  response_time_ms INTEGER NOT NULL,
  ip_address VARCHAR(45) NOT NULL,
  user_agent TEXT,
  timestamp TIMESTAMP DEFAULT NOW()
);

-- Partition by month for performance
CREATE INDEX idx_api_usage_logs_tenant_time ON api_usage_logs(tenant_id, timestamp DESC);
```

---

### 13. Implementation Details

**13.1. API Key Generation (APIKeyValidator Primitive):**

```python
import secrets
import bcrypt

class APIKeyValidator:
    def generate_key(self, tenant_id: str, scopes: list[str], expires_at: datetime = None):
        """Generate new API key with cryptographically secure random bytes."""

        # Generate random key (32 bytes = 256 bits)
        key_bytes = secrets.token_bytes(32)
        key_b64 = base64.urlsafe_b64encode(key_bytes).decode('utf-8')

        # Format: sk_{env}_{random}
        env = "live" if is_production() else "test"
        api_key = f"sk_{env}_{key_b64}"

        # Hash for storage (NEVER store plaintext key)
        key_hash = bcrypt.hashpw(api_key.encode('utf-8'), bcrypt.gensalt())

        # Store in database
        db.execute("""
            INSERT INTO api_keys (api_key_id, tenant_id, key_hash, key_prefix, scopes, expires_at)
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (uuid4(), tenant_id, key_hash, api_key[:16], scopes, expires_at))

        # Return plaintext key ONCE (user must save it, can't retrieve later)
        return api_key

    def validate_key(self, api_key: str) -> Optional[dict]:
        """Validate API key and return tenant_id, scopes if valid."""

        # Look up by hash (constant-time comparison via bcrypt)
        result = db.query("""
            SELECT api_key_id, tenant_id, scopes, expires_at, revoked_at
            FROM api_keys
            WHERE key_hash = crypt(%s, key_hash)
        """, (api_key,))

        if not result:
            return None  # Invalid key

        # Check expiration
        if result['expires_at'] and result['expires_at'] < now():
            return None  # Expired

        # Check revocation
        if result['revoked_at']:
            return None  # Revoked

        # Update last_used_at (async, don't block request)
        async_update_last_used(result['api_key_id'])

        return {
            'tenant_id': result['tenant_id'],
            'scopes': result['scopes']
        }
```

**13.2. Rate Limiting (RateLimiter Primitive):**

```python
import redis
from datetime import datetime, timedelta

class RateLimiter:
    def __init__(self, redis_client):
        self.redis = redis_client

    def check_rate_limit(self, tenant_id: str, endpoint: str, tier: str) -> dict:
        """Check rate limit using sliding window algorithm."""

        # Get tier limits
        limits = {
            'starter': {'hourly': 1000, 'burst_per_min': 50},
            'professional': {'hourly': 5000, 'burst_per_min': 200},
            'enterprise': {'hourly': 10000, 'burst_per_min': 500}
        }
        limit_config = limits[tier]

        now = datetime.utcnow()
        hour_window = now.replace(minute=0, second=0, microsecond=0)
        minute_window = now.replace(second=0, microsecond=0)

        # Redis keys
        hour_key = f"ratelimit:hourly:{tenant_id}:{hour_window.isoformat()}"
        minute_key = f"ratelimit:burst:{tenant_id}:{endpoint}:{minute_window.isoformat()}"

        # Increment counters (atomic)
        pipe = self.redis.pipeline()
        pipe.incr(hour_key)
        pipe.expire(hour_key, 3600)  # TTL 1 hour
        pipe.incr(minute_key)
        pipe.expire(minute_key, 60)  # TTL 1 minute
        results = pipe.execute()

        hourly_count = results[0]
        burst_count = results[2]

        # Check limits
        if hourly_count > limit_config['hourly']:
            reset_at = hour_window + timedelta(hours=1)
            return {
                'allowed': False,
                'limit': limit_config['hourly'],
                'remaining': 0,
                'reset': int(reset_at.timestamp())
            }

        if burst_count > limit_config['burst_per_min']:
            reset_at = minute_window + timedelta(minutes=1)
            return {
                'allowed': False,
                'limit': limit_config['burst_per_min'],
                'remaining': 0,
                'reset': int(reset_at.timestamp())
            }

        # Allowed
        reset_at = hour_window + timedelta(hours=1)
        return {
            'allowed': True,
            'limit': limit_config['hourly'],
            'remaining': limit_config['hourly'] - hourly_count,
            'reset': int(reset_at.timestamp())
        }
```

**13.3. Webhook Delivery (WebhookDispatcher Primitive):**

```python
import hmac
import hashlib
import requests
from datetime import datetime, timedelta

class WebhookDispatcher:
    def dispatch_event(self, event_type: str, payload: dict):
        """Dispatch event to all registered webhooks."""

        # Find matching webhooks
        webhooks = db.query("""
            SELECT webhook_id, tenant_id, url, secret, filters
            FROM webhooks
            WHERE status = 'active' AND %s = ANY(events)
        """, (event_type,))

        for webhook in webhooks:
            # Apply filters
            if webhook['filters'] and not self._matches_filters(payload, webhook['filters']):
                continue

            # Queue delivery
            self._queue_delivery(webhook, event_type, payload)

    def _queue_delivery(self, webhook: dict, event_type: str, payload: dict):
        """Queue webhook delivery for async processing."""

        # Generate signature
        payload_json = json.dumps(payload)
        signature = hmac.new(
            webhook['secret'].encode('utf-8'),
            payload_json.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        # Insert delivery record
        delivery_id = uuid4()
        db.execute("""
            INSERT INTO webhook_deliveries (delivery_id, webhook_id, event_type, payload, signature, status)
            VALUES (%s, %s, %s, %s, %s, 'pending')
        """, (delivery_id, webhook['webhook_id'], event_type, payload, f"sha256={signature}"))

        # Send to Kafka/Redis queue for worker processing
        queue.publish('webhook_deliveries', {'delivery_id': str(delivery_id)})

    def deliver_webhook(self, delivery_id: str):
        """Worker function to deliver webhook (called by background worker)."""

        # Load delivery record
        delivery = db.query("""
            SELECT wd.*, w.url, w.secret
            FROM webhook_deliveries wd
            JOIN webhooks w ON wd.webhook_id = w.webhook_id
            WHERE wd.delivery_id = %s
        """, (delivery_id,))

        start_time = datetime.utcnow()

        try:
            # HTTP POST to webhook URL
            response = requests.post(
                delivery['url'],
                json=delivery['payload'],
                headers={
                    'Content-Type': 'application/json',
                    'X-Webhook-Signature': delivery['signature'],
                    'X-Webhook-Retry': str(delivery['retry_count'])
                },
                timeout=10  # 10 second timeout
            )

            response_time_ms = (datetime.utcnow() - start_time).total_seconds() * 1000

            # Success (2xx status)
            if 200 <= response.status_code < 300:
                db.execute("""
                    UPDATE webhook_deliveries
                    SET status = 'success', status_code = %s, response_time_ms = %s, delivered_at = NOW()
                    WHERE delivery_id = %s
                """, (response.status_code, response_time_ms, delivery_id))

                # Update webhook last_delivery_at
                db.execute("""
                    UPDATE webhooks SET last_delivery_at = NOW(), failure_count = 0
                    WHERE webhook_id = %s
                """, (delivery['webhook_id'],))

            # Retriable error (5xx)
            elif response.status_code >= 500:
                self._schedule_retry(delivery_id, delivery['retry_count'], response.status_code, response_time_ms)

            # Non-retriable error (4xx)
            else:
                db.execute("""
                    UPDATE webhook_deliveries
                    SET status = 'failed', status_code = %s, response_time_ms = %s
                    WHERE delivery_id = %s
                """, (response.status_code, response_time_ms, delivery_id))

        except requests.exceptions.Timeout:
            self._schedule_retry(delivery_id, delivery['retry_count'], None, None)

        except Exception as e:
            logger.error(f"Webhook delivery error: {e}")
            self._schedule_retry(delivery_id, delivery['retry_count'], None, None)

    def _schedule_retry(self, delivery_id: str, retry_count: int, status_code: int, response_time_ms: int):
        """Schedule retry with exponential backoff."""

        # Max 5 retries
        if retry_count >= 5:
            db.execute("""
                UPDATE webhook_deliveries
                SET status = 'failed', status_code = %s, response_time_ms = %s
                WHERE delivery_id = %s
            """, (status_code, response_time_ms, delivery_id))

            # Mark webhook as failed
            db.execute("""
                UPDATE webhooks
                SET status = 'failed', failure_count = failure_count + 1
                WHERE webhook_id = (SELECT webhook_id FROM webhook_deliveries WHERE delivery_id = %s)
            """, (delivery_id,))

            # Email admin
            self._send_webhook_failure_email(delivery_id)
            return

        # Exponential backoff: 5s, 25s, 125s, 625s, 3125s
        backoff_seconds = 5 * (5 ** retry_count)
        next_retry_at = datetime.utcnow() + timedelta(seconds=backoff_seconds)

        db.execute("""
            UPDATE webhook_deliveries
            SET retry_count = %s, next_retry_at = %s, status_code = %s, response_time_ms = %s
            WHERE delivery_id = %s
        """, (retry_count + 1, next_retry_at, status_code, response_time_ms, delivery_id))
```

---

### 14. Primitives Used

**OL Primitives (5 new):**

1. **APIGateway** (`docs/primitives/ol/APIGateway.md`)
   - Entry point for all API requests
   - Handles authentication, rate limiting, CORS, logging
   - Wraps APIRouter + RateLimiter + APIKeyValidator

2. **APIRouter** (`docs/primitives/ol/APIRouter.md`)
   - Maps HTTP routes to business logic handlers
   - Validates requests against OpenAPI schema
   - Serializes responses to JSON (RFC 7807 for errors)

3. **WebhookDispatcher** (`docs/primitives/ol/WebhookDispatcher.md`)
   - Listens for system events
   - Queues webhook deliveries
   - Retries failed deliveries with exponential backoff

4. **APIKeyValidator** (`docs/primitives/ol/APIKeyValidator.md`)
   - Generates cryptographically secure API keys
   - Validates API keys (bcrypt hash comparison)
   - Checks tenant scoping, expiration, revocation

5. **OAuth2Provider** (`docs/primitives/ol/OAuth2Provider.md`)
   - Issues access tokens, refresh tokens
   - Validates OAuth2 tokens on each request
   - Handles token expiration, revocation, scope validation

**Reused OL Primitives:**

- **RateLimiter** (from 5.3 Rule Performance) - Used for API rate limiting
- **AuditLogger** (from 5.4 Security) - Logs all API requests for audit trail
- **TenantIsolator** (from 5.4 Security) - Ensures API key can't access other tenants' data

---

### 15. Dependencies

**External Dependencies:**

- **Kong Gateway** (or Nginx + Lua): API gateway for rate limiting, authentication, logging
- **Redis**: Rate limit counters (sliding window), webhook queue
- **Kafka**: Event stream for webhook dispatching
- **PostgreSQL**: API keys, webhooks, webhook deliveries, usage logs
- **OpenAPI 3.0**: API specification format
- **Swagger UI**: Interactive API documentation

**Internal Dependencies:**

- **Upload Flow (1.1)**: POST /v1/uploads creates new upload
- **Extraction (1.2)**: GET /v1/observations retrieves parsed observations
- **Normalization (1.3)**: GET /v1/observations includes normalized fields
- **Entity Resolution (2.1-2.3)**: GET /v1/entities retrieves resolved entities
- **Reconciliation (3.1-3.9)**: POST /v1/reconciliations/trigger starts reconciliation
- **Security (5.4)**: Access policies enforced by API gateway

**Dependency Flow:**

```
API Request → APIGateway → APIKeyValidator → TenantIsolator → APIRouter → Business Logic
                ↓
           RateLimiter (check limits, increment counters)
                ↓
           AuditLogger (log request for compliance)
```

---

## Cross-Cutting Concerns (Sections 16-20)

### 16. Security Considerations

**SEC-5.5-1: API Key Storage**
- **Threat:** API keys stored in plaintext → database breach exposes all keys
- **Mitigation:** Hash keys with bcrypt before storing (same pattern as passwords). NEVER store plaintext keys. Display only key prefix in UI (tc_live_abc***).

**SEC-5.5-2: Webhook Signature Verification**
- **Threat:** Attacker spoofs webhooks to consumer endpoints (inject fake events)
- **Mitigation:** HMAC-SHA256 signature in X-Webhook-Signature header. Consumer MUST verify signature before processing. Documentation includes verification examples.

**SEC-5.5-3: Rate Limit Bypass**
- **Threat:** Attacker distributes requests across multiple API keys (same tenant) to bypass rate limits
- **Mitigation:** Rate limits apply per-tenant (not per-API-key). Aggregate all keys for same tenant_id. Monitor for distributed attacks.

**SEC-5.5-4: API Key Leakage**
- **Threat:** Developer commits API key to public GitHub repo
- **Mitigation:**
  - Key format includes "tc_live_" prefix (easy to detect in GitHub scans)
  - Monitor for unusual request patterns (new IPs, high volume)
  - Email alerts for suspicious activity
  - UI banner "Rotate your key immediately if leaked"

**SEC-5.5-5: OAuth2 Token Theft**
- **Threat:** Attacker steals OAuth2 access token (XSS, man-in-the-middle)
- **Mitigation:**
  - Short-lived access tokens (15-minute expiration)
  - Refresh tokens (longer-lived, can be revoked)
  - HTTPS enforced for all API requests
  - Token revocation endpoint (POST /v1/oauth/revoke)

**SEC-5.5-6: Webhook URL Manipulation**
- **Threat:** Attacker registers webhook pointing to internal service (SSRF attack)
- **Mitigation:**
  - Validate webhook URLs (must be HTTPS, no localhost/private IPs)
  - Timeout webhooks after 10 seconds (prevent slowloris attacks)
  - Blocklist known malicious domains

---

### 17. Performance Characteristics

**Performance Targets:**

| Endpoint Type | p95 Latency Target | p99 Latency Target | Throughput Target |
|---------------|-------------------|-------------------|------------------|
| Read (GET /v1/observations) | < 200ms | < 500ms | 1000 req/s |
| Write (POST /v1/uploads) | < 1s | < 2s | 500 req/s |
| Webhook Delivery | < 10s (including remote endpoint) | < 30s | 500 events/s |
| Rate Limit Check | < 5ms (Redis lookup) | < 10ms | 10000 req/s |
| API Key Validation | < 20ms (bcrypt + DB) | < 50ms | 5000 req/s |

**Performance Optimizations:**

1. **Redis Caching for API Keys:**
   - Cache validated API keys in Redis (TTL 5 minutes)
   - Reduces database load (validation happens on every request)
   - Invalidate cache on key revocation

2. **Async Webhook Delivery:**
   - Queue webhook deliveries in Kafka/Redis
   - Background workers process queue (doesn't block API response)
   - Parallel workers (10 workers = 10x throughput)

3. **Database Indexes:**
   - `api_keys(key_hash)` - Fast API key lookup
   - `webhooks(tenant_id)` - Fast webhook lookup
   - `webhook_deliveries(next_retry_at)` - Fast retry queue scan

4. **Rate Limit Sliding Window:**
   - Redis INCR (atomic, O(1) complexity)
   - No database round-trip on every request

**Load Test Scenarios:**

```yaml
# Scenario 1: Read-Heavy Workload
- Endpoint: GET /v1/observations?upload_id=:id
- Concurrent users: 100
- Duration: 5 minutes
- Expected: p95 < 200ms, 0% errors

# Scenario 2: Write-Heavy Workload
- Endpoint: POST /v1/uploads (10MB PDF)
- Concurrent users: 50
- Duration: 5 minutes
- Expected: p95 < 2s, 0% errors

# Scenario 3: Rate Limit Stress Test
- Endpoint: Mixed (read + write)
- Concurrent users: 200 (exceed rate limits)
- Duration: 5 minutes
- Expected: HTTP 429 returned correctly, no crashes

# Scenario 4: Webhook Delivery Stress Test
- Event type: upload.completed
- Event rate: 1000 events/s
- Webhook endpoints: 100 unique URLs
- Expected: > 95% deliveries succeed within 10s
```

---

### 18. Observability

**18.1. Metrics (Prometheus/Grafana)**

| Metric Name | Type | Description | Alert Threshold |
|-------------|------|-------------|-----------------|
| `api_requests_total` | Counter | Total API requests by endpoint, status | N/A |
| `api_request_duration_seconds` | Histogram | Request latency by endpoint | p95 > 2s (write), p95 > 500ms (read) |
| `api_errors_total` | Counter | Errors by endpoint, status code | 5xx errors > 1% |
| `api_rate_limit_exceeded_total` | Counter | Rate limit rejections by tenant | > 100/hour for single tenant |
| `webhook_deliveries_total` | Counter | Webhook deliveries by status (success, failed) | N/A |
| `webhook_delivery_duration_seconds` | Histogram | Webhook delivery time | p95 > 10s |
| `webhook_retries_total` | Counter | Webhook retries by webhook_id | > 50 retries/hour for single webhook |
| `api_keys_active` | Gauge | Number of active API keys | N/A |
| `webhooks_active` | Gauge | Number of active webhooks | N/A |
| `rate_limiter_redis_errors_total` | Counter | Redis errors in rate limiter | > 0 (indicates Redis outage) |

**18.2. Alerts**

| Alert Name | Condition | Severity | Action |
|------------|-----------|----------|--------|
| `APILatencyHigh` | p95 latency > 2s for 5 minutes | Warning | Investigate slow endpoints, check database queries |
| `APIErrorRateHigh` | 5xx error rate > 1% for 5 minutes | Critical | Check logs, database connectivity, external dependencies |
| `RateLimitRedisDown` | Redis errors > 0 | Critical | Restart Redis, failover to backup, API gateway may reject all requests |
| `WebhookDeliveryFailures` | Webhook success rate < 90% for 10 minutes | Warning | Check consumer endpoints, network connectivity |
| `APIKeyValidationSlow` | API key validation p95 > 100ms | Warning | Check database load, consider read replica |

**18.3. Structured Logs**

Every API request logs:
```json
{
  "timestamp": "2025-10-25T10:15:23.456Z",
  "level": "info",
  "event": "api_request",
  "tenant_id": "tenant_acme",
  "api_key_id": "key_123",
  "endpoint": "GET /v1/observations",
  "http_status": 200,
  "response_time_ms": 145,
  "ip_address": "203.0.113.42",
  "user_agent": "axios/1.3.0",
  "rate_limit_remaining": 847
}
```

Every webhook delivery logs:
```json
{
  "timestamp": "2025-10-25T10:15:25.123Z",
  "level": "info",
  "event": "webhook_delivered",
  "webhook_id": "wh_abc123",
  "delivery_id": "del_xyz789",
  "event_type": "upload.completed",
  "status": "success",
  "status_code": 200,
  "response_time_ms": 342,
  "retry_count": 0
}
```

**18.4. Dashboards**

1. **API Overview Dashboard:**
   - Request rate chart (by endpoint, last 24 hours)
   - Error rate chart (4xx, 5xx)
   - Latency histogram (p50, p95, p99)
   - Active API keys gauge
   - Top consumers table (by request count)

2. **Webhook Health Dashboard:**
   - Webhook delivery success rate (last 24 hours)
   - Failed webhooks table (webhook_id, failure_count, last_error)
   - Delivery latency histogram
   - Retry count distribution

3. **Rate Limiting Dashboard:**
   - Rate limit rejections chart (by tenant)
   - Top rate-limited tenants table
   - Redis performance metrics (latency, errors)

---

### 19. Testing Strategy

**19.1. Unit Tests**

Test each primitive in isolation:

```python
# Test APIKeyValidator.generate_key()
def test_generate_key_format():
    validator = APIKeyValidator()
    key = validator.generate_key('tenant_acme', ['read', 'write'])
    assert key.startswith('tc_test_')  # Test environment
    assert len(key) > 40  # Sufficient entropy

# Test APIKeyValidator.validate_key()
def test_validate_key_expired():
    validator = APIKeyValidator()
    expired_key = create_expired_key('tenant_acme')
    result = validator.validate_key(expired_key)
    assert result is None  # Expired key rejected

# Test RateLimiter.check_rate_limit()
def test_rate_limit_exceeded():
    limiter = RateLimiter(redis_client)
    # Make 1001 requests in 1 hour (exceeds 1000 limit)
    for i in range(1001):
        result = limiter.check_rate_limit('tenant_acme', 'GET /v1/observations', 'starter')
        if i < 1000:
            assert result['allowed'] == True
        else:
            assert result['allowed'] == False  # 1001st request rejected

# Test WebhookDispatcher.deliver_webhook()
def test_webhook_signature_valid():
    dispatcher = WebhookDispatcher()
    payload = {'upload_id': 'upl_123', 'status': 'parsed'}
    secret = 'webhook_secret_abc123'
    signature = dispatcher._generate_signature(payload, secret)
    assert dispatcher._verify_signature(payload, signature, secret) == True
```

**19.2. Integration Tests**

Test end-to-end flows:

```python
# Test API request → authentication → response
def test_api_request_with_valid_key():
    api_key = create_test_api_key('tenant_acme', ['read'])
    response = requests.get(
        'http://localhost:8000/v1/observations',
        headers={'Authorization': f'Bearer {api_key}'}
    )
    assert response.status_code == 200
    assert 'observations' in response.json()

# Test rate limiting integration
def test_rate_limit_integration():
    api_key = create_test_api_key('tenant_acme', ['read'], tier='starter')
    # Make 1001 requests
    for i in range(1001):
        response = requests.get(
            'http://localhost:8000/v1/observations',
            headers={'Authorization': f'Bearer {api_key}'}
        )
        if i < 1000:
            assert response.status_code == 200
        else:
            assert response.status_code == 429  # Rate limit exceeded
            assert 'Retry-After' in response.headers

# Test webhook delivery integration
def test_webhook_delivery_integration():
    # Start mock webhook server
    mock_server = start_mock_webhook_server(port=9000)

    # Register webhook
    webhook_id = register_webhook(
        tenant_id='tenant_acme',
        url='http://localhost:9000/webhook',
        events=['upload.completed']
    )

    # Trigger event
    trigger_event('upload.completed', {'upload_id': 'upl_123'})

    # Wait for delivery
    time.sleep(2)

    # Verify mock server received webhook
    deliveries = mock_server.get_deliveries()
    assert len(deliveries) == 1
    assert deliveries[0]['event_type'] == 'upload.completed'
    assert 'X-Webhook-Signature' in deliveries[0]['headers']
```

**19.3. Load Tests (Artillery/k6)**

```yaml
# artillery-load-test.yml
config:
  target: 'https://api.truthconstruction.com'
  phases:
    - duration: 60
      arrivalRate: 10  # 10 requests/second
      name: "Warm up"
    - duration: 300
      arrivalRate: 100  # 100 requests/second
      name: "Sustained load"
    - duration: 60
      arrivalRate: 200  # 200 requests/second (spike)
      name: "Spike test"

scenarios:
  - name: "Read observations"
    weight: 70
    flow:
      - get:
          url: "/v1/observations?upload_id={{ upload_id }}"
          headers:
            Authorization: "Bearer {{ api_key }}"

  - name: "Create upload"
    weight: 20
    flow:
      - post:
          url: "/v1/uploads"
          headers:
            Authorization: "Bearer {{ api_key }}"
          json:
            file_path: "s3://bucket/test.pdf"
            parser_type: "bank_statement"

  - name: "List entities"
    weight: 10
    flow:
      - get:
          url: "/v1/entities?tenant_id={{ tenant_id }}"
          headers:
            Authorization: "Bearer {{ api_key }}"
```

**19.4. Security Tests**

```python
# Test API key leakage detection
def test_api_key_format_detectable():
    key = APIKeyValidator().generate_key('tenant_acme', ['read'])
    # Ensure key format is detectable by secret scanning tools
    assert key.startswith('sk_')
    assert len(key) > 40

# Test webhook SSRF protection
def test_webhook_ssrf_protection():
    # Try to register webhook pointing to localhost (SSRF attack)
    response = requests.post(
        'http://localhost:8000/v1/webhooks',
        headers={'Authorization': f'Bearer {api_key}'},
        json={
            'url': 'http://localhost:9000/webhook',  # Localhost blocked
            'events': ['upload.completed']
        }
    )
    assert response.status_code == 400
    assert 'private IP' in response.json()['error']

# Test rate limit bypass attempt
def test_rate_limit_bypass_multiple_keys():
    # Create 5 API keys for same tenant
    keys = [create_test_api_key('tenant_acme', ['read']) for _ in range(5)]

    # Try to bypass rate limit by distributing requests across keys
    total_requests = 0
    for i in range(300):  # 300 requests/key = 1500 total (exceeds 1000 limit)
        key = keys[i % 5]
        response = requests.get(
            'http://localhost:8000/v1/observations',
            headers={'Authorization': f'Bearer {key}'}
        )
        total_requests += 1

        # Should be rate limited after 1000 requests (across all keys for tenant)
        if total_requests > 1000:
            assert response.status_code == 429
```

---

### 20. Deployment & Operations

**20.1. Deployment Architecture**

```
┌─────────────────────────────────────────────────────────────┐
│                         Load Balancer                       │
│  (AWS ALB / Cloudflare / Nginx)                             │
│  - TLS termination                                          │
│  - DDoS protection                                          │
└─────────────────────────────────────────────────────────────┘
                            │
              ┌─────────────┴─────────────┐
              ▼                           ▼
┌─────────────────────┐       ┌─────────────────────┐
│  API Gateway (Kong) │       │  API Gateway (Kong) │
│  - Rate limiting    │       │  (Replica)          │
│  - Auth validation  │       │                     │
└─────────────────────┘       └─────────────────────┘
              │                           │
              └─────────────┬─────────────┘
                            ▼
              ┌──────────────────────────┐
              │   API Service (Node.js)  │
              │   (Auto-scaling 3-10)    │
              └──────────────────────────┘
                            │
              ┌─────────────┼─────────────┐
              ▼             ▼             ▼
     ┌──────────┐  ┌──────────┐  ┌──────────┐
     │PostgreSQL│  │  Redis   │  │  Kafka   │
     │(Primary +│  │(Cluster) │  │(Cluster) │
     │ Replica) │  │          │  │          │
     └──────────┘  └──────────┘  └──────────┘
```

**20.2. Environment Configuration**

| Environment | API Endpoint | API Key Format | Rate Limits | Database |
|-------------|--------------|----------------|-------------|----------|
| **Sandbox** | sandbox.api.truthconstruction.com | tc_sandbox_* | 100 req/hour (no billing) | sandbox DB (reset daily) |
| **Staging** | staging.api.truthconstruction.com | tc_test_* | Same as prod | staging DB (prod snapshot) |
| **Production** | api.truthconstruction.com | tc_live_* | Tier-based (1000-10000/hour) | prod DB (HA, backups) |

**20.3. Deployment Process**

```bash
# Step 1: Deploy API Gateway (Kong)
kubectl apply -f k8s/api-gateway-deployment.yaml

# Step 2: Deploy API Service (rolling update, zero downtime)
kubectl set image deployment/api-service api-service=api-service:v1.2.3
kubectl rollout status deployment/api-service

# Step 3: Run database migrations (if needed)
kubectl exec -it api-service-pod -- npm run migrate

# Step 4: Deploy webhook workers (Kafka consumers)
kubectl apply -f k8s/webhook-worker-deployment.yaml

# Step 5: Update OpenAPI spec (API documentation)
aws s3 cp openapi.yaml s3://docs-bucket/api/v1/openapi.yaml
# This triggers Swagger UI update on docs.truthconstruction.com

# Step 6: Smoke tests (prod)
curl -H "Authorization: Bearer $PROD_API_KEY" https://api.truthconstruction.com/v1/health
# Expected: {"status": "ok", "version": "v1.2.3"}
```

**20.4. Rollback Procedure**

```bash
# If deployment has critical bug:

# Step 1: Rollback API Service
kubectl rollout undo deployment/api-service

# Step 2: Rollback database migrations (if needed)
kubectl exec -it api-service-pod -- npm run migrate:rollback

# Step 3: Rollback API Gateway config
kubectl apply -f k8s/api-gateway-deployment-previous.yaml

# Step 4: Verify rollback
curl -H "Authorization: Bearer $PROD_API_KEY" https://api.truthconstruction.com/v1/health
# Expected: {"status": "ok", "version": "v1.2.2"}

# Step 5: Post-mortem (identify root cause, add tests)
```

**20.5. Monitoring & Alerting**

| Alert | Trigger | Severity | On-Call Action |
|-------|---------|----------|----------------|
| **APIDown** | Health check fails for 2 minutes | P0 (Critical) | Restart service, check logs, escalate if not resolved in 5 min |
| **RateLimiterDown** | Redis unavailable | P0 (Critical) | Failover to backup Redis, check Redis logs |
| **APILatencyHigh** | p95 > 2s for 5 minutes | P1 (Warning) | Check slow query log, database load, APM traces |
| **WebhookFailuresHigh** | Success rate < 90% for 10 min | P2 (Warning) | Check consumer endpoints, network connectivity |
| **APIKeyValidationSlow** | p95 > 100ms for 5 minutes | P2 (Warning) | Check database load, consider read replica |

**20.6. Runbook: Handle API Outage**

```markdown
# Runbook: API Service Outage

## Symptoms
- Health check endpoint returns 503
- All API requests return 502/503
- Monitoring shows 0 requests/second

## Investigation Steps
1. Check API service pods: `kubectl get pods -l app=api-service`
   - If CrashLoopBackOff: Check logs `kubectl logs <pod-name>`
2. Check database connectivity: `kubectl exec -it api-service-pod -- npm run db:ping`
   - If fails: Check PostgreSQL primary/replica status
3. Check Redis connectivity: `kubectl exec -it api-service-pod -- redis-cli ping`
   - If fails: Restart Redis, failover to backup
4. Check API Gateway (Kong): `kubectl get pods -l app=api-gateway`
   - If down: Restart Kong pods

## Resolution
- **If API service crashed:** Restart pods `kubectl rollout restart deployment/api-service`
- **If database down:** Failover to replica, promote replica to primary
- **If Redis down:** Restart Redis, API will degrade gracefully (no rate limiting)
- **If Kong down:** Restart Kong pods

## Communication
- Post status update to status.truthconstruction.com within 5 minutes
- Email affected customers (Enterprise tier) within 15 minutes
- Post-mortem within 24 hours
```

---

## Multi-Domain Applicability

**Domain 1: Finance (Banking API Integration)**

**Use Case:** Bank integrates Truth Construction API to auto-process uploaded statements

**API Flow:**
```bash
# 1. Upload bank statement
curl -X POST https://api.truthconstruction.com/v1/uploads \
  -H "Authorization: Bearer tc_live_bank_xyz" \
  -F "file=@statement.pdf" \
  -F "parser_type=bank_statement"
# Response: {"upload_id": "upl_abc123", "status": "queued"}

# 2. Poll for completion (or use webhook)
curl https://api.truthconstruction.com/v1/uploads/upl_abc123 \
  -H "Authorization: Bearer tc_live_bank_xyz"
# Response: {"upload_id": "upl_abc123", "status": "parsed"}

# 3. Retrieve observations
curl https://api.truthconstruction.com/v1/observations?upload_id=upl_abc123 \
  -H "Authorization: Bearer tc_live_bank_xyz"
# Response: [{"observation_id": "obs_1", "type": "transaction", "amount": 1500.00, ...}]
```

**Webhook Example:**
```json
{
  "event": "upload.completed",
  "upload_id": "upl_abc123",
  "status": "parsed",
  "observation_count": 45,
  "timestamp": "2025-10-25T10:15:23Z"
}
```

---

**Domain 2: Healthcare (EHR Integration)**

**Use Case:** Hospital EHR system uses API to process lab reports

**API Flow:**
```bash
# 1. Upload lab report PDF
curl -X POST https://api.truthconstruction.com/v1/uploads \
  -H "Authorization: Bearer tc_live_hospital_abc" \
  -F "file=@lab_report.pdf" \
  -F "parser_type=lab_report"

# 2. Retrieve observations (with PHI masking for non-owner roles)
curl https://api.truthconstruction.com/v1/observations?upload_id=upl_abc123 \
  -H "Authorization: Bearer tc_live_hospital_abc"
# Response: [{"observation_id": "obs_1", "patient_ssn": "***-**-6789", "test_name": "CBC", ...}]
```

**Access Control:**
- API key scoped to tenant (hospital)
- PHI masking enforced based on API key role (viewer sees masked SSN, owner sees full SSN)

---

**Domain 3: Legal (Document Management System)**

**Use Case:** Law firm integrates API to extract clauses from contracts

**API Flow:**
```bash
# 1. Upload contract PDF
curl -X POST https://api.truthconstruction.com/v1/uploads \
  -H "Authorization: Bearer tc_live_lawfirm_xyz" \
  -F "file=@contract.pdf" \
  -F "parser_type=legal_contract"

# 2. Retrieve extracted entities (parties, dates, obligations)
curl https://api.truthconstruction.com/v1/entities?upload_id=upl_abc123 \
  -H "Authorization: Bearer tc_live_lawfirm_xyz"
# Response: [{"entity_id": "ent_1", "type": "party", "name": "Acme Corp", ...}]
```

**Webhook for Contract Expiration:**
```json
{
  "event": "entity.resolved",
  "entity_id": "ent_1",
  "type": "obligation",
  "obligation_deadline": "2026-01-15",
  "timestamp": "2025-10-25T10:15:23Z"
}
```

---

**Domain 4: Research (RSRCH - Utilitario)**

**Context:** RSRCH collects facts about founders/companies from diverse sources (TechCrunch, interviews, podcasts, tweets). Public API enables external developers to programmatically query fact database, search entities, receive real-time notifications when new facts are discovered.

**Use Case:** VC firm integrates RSRCH API to auto-enrich their CRM with founder investment facts

**API Flow:**
```bash
# 1. Query facts about specific founder (Sam Altman)
curl https://api.truthconstruction.com/v1/facts?subject_entity=Sam+Altman&fact_type=investment \
  -H "Authorization: Bearer tc_live_vcfirm_xyz"

# Response:
# [
#   {
#     "fact_id": "fact_sama_helion_001",
#     "claim": "Sam Altman invested $375M in Helion Energy",
#     "subject_entity": "Sam Altman",
#     "fact_type": "investment",
#     "investment_amount": 375000000,
#     "sources": ["techcrunch", "lex_fridman_podcast", "bloomberg"],
#     "source_credibility": 0.98,
#     "discovered_at": "2025-01-15T10:00:00Z"
#   },
#   ...
# ]

# 2. Get founder entity with all facts (aggregated view)
curl https://api.truthconstruction.com/v1/entities?name=Sam+Altman&type=founder \
  -H "Authorization: Bearer tc_live_vcfirm_xyz"

# Response:
# [
#   {
#     "entity_id": "ent_sama_001",
#     "type": "founder",
#     "canonical_name": "Sam Altman",
#     "aliases": ["@sama", "sama", "Samuel Altman"],
#     "facts": [
#       {"fact_id": "fact_sama_helion_001", "claim": "Invested $375M in Helion Energy", ...},
#       {"fact_id": "fact_sama_openai_001", "claim": "CEO of OpenAI", ...},
#       ...
#     ],
#     "relationships": [
#       {"type": "invested_in", "target_entity": "Helion Energy", "amount": 375000000},
#       {"type": "employed_by", "target_entity": "OpenAI", "role": "CEO"},
#       ...
#     ]
#   }
# ]

# 3. Register webhook for real-time notifications (new fact discovered)
curl -X POST https://api.truthconstruction.com/v1/webhooks \
  -H "Authorization: Bearer tc_live_vcfirm_xyz" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://vcfirm-crm.com/webhooks/rsrch",
    "events": ["fact.discovered", "entity.resolved"],
    "filters": {
      "fact_type": ["investment", "founding"],
      "entity_type": ["founder", "company"]
    },
    "secret": "whsec_abc123def456"
  }'

# 4. Webhook notification received (when new fact discovered)
# POST https://vcfirm-crm.com/webhooks/rsrch
# Headers:
#   X-Webhook-Signature: sha256=abc123...
#   X-Webhook-ID: evt_xyz789
# Body:
# {
#   "event": "fact.discovered",
#   "fact_id": "fact_sama_reddit_002",
#   "subject_entity": "Sam Altman",
#   "claim": "Sam Altman invested in Reddit Series B",
#   "source_url": "https://techcrunch.com/2025/02/01/sama-reddit",
#   "discovered_at": "2025-02-01T14:30:00Z"
# }

# 5. Search founders by investment activity (advanced query)
curl https://api.truthconstruction.com/v1/entities/search \
  -H "Authorization: Bearer tc_live_vcfirm_xyz" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "founder",
    "filters": {
      "has_fact_type": "investment",
      "investment_amount_min": 100000000,
      "investment_date_after": "2024-01-01"
    },
    "limit": 50
  }'

# Response: List of founders with $100M+ investments in 2024+
```

**RSRCH-Specific API Features:**
- **Multi-source fact querying**: GET /v1/facts?subject_entity=X returns facts with sources array (TechCrunch, podcasts, tweets)
- **Source credibility filtering**: GET /v1/facts?min_credibility=0.9 (only high-credibility sources like first-person interviews)
- **Entity relationship graph**: GET /v1/entities/:id/relationships (founder invested_in companies, employed_by companies)
- **Real-time fact discovery**: Webhook event "fact.discovered" triggers when new fact extracted from TechCrunch, podcast, interview
- **Fact provenance API**: GET /v1/facts/:id/provenance returns complete timeline (which source discovered which field, when)
- **Search by fact type**: GET /v1/facts?fact_type=investment|founding|employment (investment facts, founding events, employment history)

**Rate Limiting for RSRCH:**
- Fact queries: 1000 req/hour (standard tier), 10000 req/hour (enterprise tier)
- Entity searches: 500 req/hour (complex queries, expensive)
- Webhook deliveries: Unlimited (async, queued)

---

**Domain 5: E-Commerce (Invoice Processing)**

**Use Case:** E-commerce platform uses API to auto-process supplier invoices

**API Flow:**
```bash
# 1. Upload invoice PDF
curl -X POST https://api.truthconstruction.com/v1/uploads \
  -H "Authorization: Bearer tc_live_ecommerce_xyz" \
  -F "file=@invoice.pdf" \
  -F "parser_type=invoice"

# 2. Trigger reconciliation (match invoice to purchase orders)
curl -X POST https://api.truthconstruction.com/v1/reconciliations/trigger \
  -H "Authorization: Bearer tc_live_ecommerce_xyz" \
  -H "Content-Type: application/json" \
  -d '{"upload_id": "upl_abc123", "reconciliation_type": "invoice_to_po"}'

# 3. Retrieve reconciliation results
curl https://api.truthconstruction.com/v1/reconciliations/rec_xyz789 \
  -H "Authorization: Bearer tc_live_ecommerce_xyz"
# Response: {"reconciliation_id": "rec_xyz789", "status": "matched", "matches": [...]}
```

---

**Domain 6: SaaS (HR Platform Integration)**

**Use Case:** HR SaaS platform uses API to process employee tax documents

**API Flow:**
```bash
# 1. Upload W-2 form PDF
curl -X POST https://api.truthconstruction.com/v1/uploads \
  -H "Authorization: Bearer tc_live_hrsaas_abc" \
  -F "file=@w2.pdf" \
  -F "parser_type=tax_form_w2"

# 2. Retrieve observations (with SSN masking for non-admin roles)
curl https://api.truthconstruction.com/v1/observations?upload_id=upl_abc123 \
  -H "Authorization: Bearer tc_live_hrsaas_abc"
# Response: [{"observation_id": "obs_1", "ssn": "***-**-6789", "wages": 75000.00, ...}]
```

**Rate Limiting:**
- HR platform has Enterprise tier (10000 req/hour)
- Bulk upload endpoint (POST /v1/uploads/batch) for processing 100s of W-2s

---

**Domain 7: Insurance (Claims Processing)**

**Use Case:** Insurance company uses API to auto-process claim documents

**API Flow:**
```bash
# 1. Upload insurance claim PDF
curl -X POST https://api.truthconstruction.com/v1/uploads \
  -H "Authorization: Bearer tc_live_insurance_xyz" \
  -F "file=@claim.pdf" \
  -F "parser_type=insurance_claim"

# 2. Retrieve observations (claim details, diagnosis codes, charges)
curl https://api.truthconstruction.com/v1/observations?upload_id=upl_abc123 \
  -H "Authorization: Bearer tc_live_insurance_xyz"
# Response: [{"observation_id": "obs_1", "diagnosis_code": "E11.9", "charge_amount": 1500.00, ...}]

# 3. Setup webhook for claim approval
curl -X POST https://api.truthconstruction.com/v1/webhooks \
  -H "Authorization: Bearer tc_live_insurance_xyz" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://insurance.com/webhook",
    "events": ["reconciliation.completed"],
    "filters": {"reconciliation_type": "claim_approval"}
  }'
```

**Webhook Event:**
```json
{
  "event": "reconciliation.completed",
  "reconciliation_id": "rec_xyz789",
  "upload_id": "upl_abc123",
  "status": "approved",
  "claim_amount": 1500.00,
  "approved_amount": 1350.00,
  "timestamp": "2025-10-25T10:15:23Z"
}
```

---

## Summary

Vertical 5.5 provides a complete **Public API Contracts** specification, enabling external developers to integrate with Truth Construction primitives via REST API, webhooks, and OAuth2. Key features:

1. **REST API:** OpenAPI 3.0 spec with endpoints for uploads, observations, entities, reconciliation
2. **Webhooks:** Real-time event notifications with retry logic and signature verification
3. **API Versioning:** v1 (stable), v2 (future), with 12-month deprecation policy
4. **Rate Limiting:** Per-tenant, per-endpoint limits (1000-10000 req/hour by tier)
5. **Authentication:** API keys (server-to-server) and OAuth2 (user-delegated access)
6. **Multi-Domain:** Finance, Healthcare, Legal, Research, E-Commerce, SaaS, Insurance examples

**5 New OL Primitives:** APIGateway, APIRouter, WebhookDispatcher, APIKeyValidator, OAuth2Provider

**Ready for:** Final vertical completion, GitHub push, project documentation update.
