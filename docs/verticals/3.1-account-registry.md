# Vertical 3.1: Account Registry

**Status:** ✅ Complete
**Type:** Registry Management (Closed Registry)
**Domain:** Finance (multi-domain pattern)

---

## PRODUCT LAYER (Sections 1-10)

### 1. Scope & Boundaries

**IN SCOPE:**
- Create user accounts (e.g., "BofA Checking", "Apple Card", "Wise USD")
- Edit account details (name, type, currency, institution)
- Archive accounts (soft delete - preserve history)
- List all active accounts
- Select account in dropdowns (used in transaction editing, filtering)
- Validate account uniqueness (no duplicate names)

**OUT OF SCOPE:**
- Account balances (handled by separate balance tracking vertical)
- Account reconciliation (separate vertical)
- Multi-user account sharing (future)
- Account import from banks (future API integration)
- Account categories/tags (simplified - only type field)

**KEY INSIGHT:**
"Closed registry" = fixed, user-curated list. Unlike Counterparty (which grows dynamically as new merchants appear), Account is manually managed. User explicitly creates each account.

---

### 2. User Flow (Real Usage)

**Scenario 1: New user onboarding**
```
User opens app for first time
→ System shows "Add your first account" screen
→ User clicks [+ Add Account]
→ Modal opens:
   - Name: "BofA Checking"
   - Type: Checking (dropdown)
   - Currency: USD (dropdown)
   - Institution: "Bank of America" (optional text)
→ User clicks [Save]
→ System validates (no duplicate "BofA Checking")
→ Account created with account_id = "acc_bofa_checking_1"
→ User sees account in list
→ User adds 2 more: "BofA Credit", "Apple Card"
→ User now has 3 accounts
```

**Scenario 2: Editing account details**
```
User clicks [⚙️] on "BofA Checking"
→ Edit modal opens (pre-filled)
→ User changes name: "BofA Checking" → "BofA Personal Checking"
→ User clicks [Save]
→ System validates (no other account named "BofA Personal Checking")
→ Account updated
→ Change logged in audit trail
```

**Scenario 3: Archiving old account**
```
User closed their Apple Card last year
→ User clicks [⚙️] on "Apple Card"
→ User clicks [Archive Account]
→ Confirmation dialog: "Archive 'Apple Card'? Past transactions will remain linked."
→ User confirms
→ Account marked as archived (is_active = false)
→ Account disappears from active list
→ Account still appears in historical transaction views
```

**Scenario 4: Using account selector in transaction editing**
```
User viewing transaction: "Uber - $15.00"
→ User clicks [Edit]
→ Account dropdown shows:
   - BofA Personal Checking (current)
   - BofA Credit
   - Wise USD
   - Scotia MXN
→ User selects "BofA Credit" (moved expense to credit card)
→ Transaction updated
```

---

### 3. Primitives Touched

**OL (Objective Layer):**
- **AccountStore** (NEW) - CRUD operations for accounts with uniqueness validation
- **AccountValidator** (NEW) - Validates account data (names, types, currencies)
- **CanonicalStore** (from 1.3) - Transactions link to accounts via account_id

**IL (Interface Layer):**
- **AccountManager** (NEW) - Full CRUD UI for managing accounts
- **AccountSelector** (NEW) - Reusable dropdown for selecting account

---

### 4. Contracts (API + Internal)

**Public API:**

#### POST /api/accounts
```http
POST /api/accounts
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "BofA Checking",
  "type": "checking",
  "currency": "USD",
  "institution": "Bank of America"
}
```

**Response (Success - 201 Created):**
```json
{
  "account": {
    "account_id": "acc_bofa_checking_1",
    "name": "BofA Checking",
    "type": "checking",
    "currency": "USD",
    "institution": "Bank of America",
    "is_active": true,
    "created_at": "2025-05-15T10:00:00Z",
    "updated_at": "2025-05-15T10:00:00Z"
  }
}
```

**Response (Error - 409 Conflict - Duplicate Name):**
```json
{
  "error": {
    "code": "DUPLICATE_ACCOUNT_NAME",
    "message": "Account with name 'BofA Checking' already exists",
    "field": "name"
  }
}
```

**Response (Error - 400 Bad Request - Invalid Type):**
```json
{
  "error": {
    "code": "INVALID_ACCOUNT_TYPE",
    "message": "Invalid account type 'savings_account'. Must be one of: checking, savings, credit, debit, investment, loan",
    "field": "type",
    "allowed_values": ["checking", "savings", "credit", "debit", "investment", "loan"]
  }
}
```

---

#### GET /api/accounts
```http
GET /api/accounts?is_active=true
Authorization: Bearer {token}
```

**Response (Success - 200 OK):**
```json
{
  "accounts": [
    {
      "account_id": "acc_bofa_checking_1",
      "name": "BofA Personal Checking",
      "type": "checking",
      "currency": "USD",
      "institution": "Bank of America",
      "is_active": true,
      "created_at": "2025-05-15T10:00:00Z",
      "updated_at": "2025-05-16T14:30:00Z"
    },
    {
      "account_id": "acc_bofa_credit_2",
      "name": "BofA Credit",
      "type": "credit",
      "currency": "USD",
      "institution": "Bank of America",
      "is_active": true,
      "created_at": "2025-05-15T10:05:00Z",
      "updated_at": "2025-05-15T10:05:00Z"
    },
    {
      "account_id": "acc_wise_usd_3",
      "name": "Wise USD",
      "type": "debit",
      "currency": "USD",
      "institution": "Wise",
      "is_active": true,
      "created_at": "2025-05-15T10:10:00Z",
      "updated_at": "2025-05-15T10:10:00Z"
    }
  ],
  "count": 3
}
```

**Query Parameters:**
- `is_active` (optional): `true` (default) or `false` to include archived accounts

---

#### PUT /api/accounts/{account_id}
```http
PUT /api/accounts/acc_bofa_checking_1
Authorization: Bearer {token}
Content-Type: application/json

{
  "name": "BofA Personal Checking",
  "institution": "Bank of America - Personal"
}
```

**Response (Success - 200 OK):**
```json
{
  "account": {
    "account_id": "acc_bofa_checking_1",
    "name": "BofA Personal Checking",
    "type": "checking",
    "currency": "USD",
    "institution": "Bank of America - Personal",
    "is_active": true,
    "created_at": "2025-05-15T10:00:00Z",
    "updated_at": "2025-05-16T14:30:00Z"
  }
}
```

**Response (Error - 404 Not Found):**
```json
{
  "error": {
    "code": "ACCOUNT_NOT_FOUND",
    "message": "Account 'acc_nonexistent' not found"
  }
}
```

---

#### DELETE /api/accounts/{account_id}
```http
DELETE /api/accounts/acc_apple_card_4
Authorization: Bearer {token}
```

**Response (Success - 200 OK - Soft Delete):**
```json
{
  "account": {
    "account_id": "acc_apple_card_4",
    "name": "Apple Card",
    "type": "credit",
    "currency": "USD",
    "institution": "Apple",
    "is_active": false,
    "created_at": "2025-05-15T10:15:00Z",
    "updated_at": "2025-06-01T09:00:00Z"
  },
  "message": "Account archived. 47 historical transactions remain linked."
}
```

**NOTE:** This is a soft delete (is_active = false). Account remains in database to preserve transaction history.

---

**Internal Contracts:**

#### AccountStore.create()
```python
class AccountStore:
    def create(
        self,
        user_id: str,
        name: str,
        type: AccountType,
        currency: str,
        institution: Optional[str] = None
    ) -> Account:
        """
        Create new account.

        Raises:
            DuplicateAccountNameError: If account with same name exists
            InvalidAccountTypeError: If type not in allowed list
            InvalidCurrencyError: If currency not ISO 4217 code
        """
```

#### AccountStore.update()
```python
def update(
    self,
    account_id: str,
    user_id: str,
    updates: dict
) -> Account:
    """
    Update account details.

    Raises:
        AccountNotFoundError: If account doesn't exist
        UnauthorizedError: If user doesn't own account
        DuplicateAccountNameError: If new name conflicts
    """
```

#### AccountStore.archive()
```python
def archive(
    self,
    account_id: str,
    user_id: str
) -> ArchiveResult:
    """
    Soft delete account (set is_active = false).

    Returns:
        ArchiveResult with transaction_count (how many txns linked)

    Raises:
        AccountNotFoundError: If account doesn't exist
        UnauthorizedError: If user doesn't own account
    """
```

---

### 5. Schemas / Tipos (Persistencia)

**Account Entity (Database):**
```sql
CREATE TABLE accounts (
    account_id VARCHAR(50) PRIMARY KEY,  -- Format: "acc_{slug}_{seq}"
    user_id VARCHAR(50) NOT NULL,

    -- Core fields
    name VARCHAR(100) NOT NULL,          -- "BofA Checking"
    type VARCHAR(20) NOT NULL,           -- checking, savings, credit, debit, investment, loan
    currency CHAR(3) NOT NULL,           -- USD, MXN (ISO 4217)
    institution VARCHAR(200),            -- "Bank of America" (optional)

    -- Metadata
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,

    -- Constraints
    UNIQUE(user_id, name),               -- Unique name per user
    INDEX idx_user_active (user_id, is_active),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**AccountType Enum:**
```typescript
type AccountType =
  | "checking"      // Standard checking account
  | "savings"       // Savings account
  | "credit"        // Credit card
  | "debit"         // Debit card / prepaid card
  | "investment"    // Brokerage account
  | "loan"          // Loan account (mortgage, auto, personal)
```

**See:** `docs/schemas/account.schema.json`

---

### 6. Validaciones & Estados

**Account Validation Rules:**

1. **Name Validation:**
   - Required: `name.length >= 1`
   - Max length: `name.length <= 100`
   - Uniqueness: No duplicate names per user (case-insensitive)
   - Allowed characters: Letters, numbers, spaces, hyphens, apostrophes
   - Pattern: `^[A-Za-z0-9\s\-']+$`

2. **Type Validation:**
   - Required: `type` must be specified
   - Allowed values: `["checking", "savings", "credit", "debit", "investment", "loan"]`
   - No custom types allowed

3. **Currency Validation:**
   - Required: `currency` must be specified
   - Format: ISO 4217 3-letter code (USD, MXN, EUR, GBP, etc.)
   - Must be uppercase
   - Pattern: `^[A-Z]{3}$`

4. **Institution Validation:**
   - Optional field
   - Max length: 200 characters
   - Free text (no validation beyond length)

**Account States:**

Accounts have only 2 states (much simpler than upload flow):

```
is_active = true  → Account is active (appears in dropdowns, used in filtering)
is_active = false → Account is archived (hidden from UI, but preserves history)
```

**No complex state machine needed.** Archive is a simple boolean toggle.

---

### 7. Edge Cases

**Edge Case 1: Archiving account with active transactions**
```
Scenario: User archives "BofA Checking" but has 100 transactions linked to it
Solution: Archive succeeds. Transactions remain linked. Historical views still show account.
Rationale: Data integrity. Never break transaction → account relationship.
```

**Edge Case 2: Duplicate name (case-insensitive)**
```
Scenario: User has "BofA Checking", tries to create "bofa checking"
Result: 409 Conflict error
Rationale: Prevents user confusion. Names must be case-insensitively unique.
```

**Edge Case 3: Editing name to conflict with existing account**
```
Scenario: User has "BofA Checking" and "BofA Credit". Tries to rename "BofA Credit" → "BofA Checking"
Result: 409 Conflict error
Rationale: Same as Edge Case 2.
```

**Edge Case 4: Unarchiving account**
```
Scenario: User archived "Apple Card", now wants to reactivate it
Solution: PUT /api/accounts/{id} with {"is_active": true}
UI: Show [Unarchive] button in archived account list
```

**Edge Case 5: Currency mismatch with transactions**
```
Scenario: Account created as "USD", user changes to "MXN"
Result: NOT ALLOWED. Currency is immutable after creation.
Rationale: Changing currency would invalidate all historical transactions.
Enforcement: API rejects currency changes (400 Bad Request)
```

**Edge Case 6: Deleting vs Archiving**
```
Scenario: User clicks "Delete Account"
Solution: System performs soft delete (is_active = false), not hard delete
Rationale: Preserve referential integrity. Transactions must always link to valid account.
Future: If user really wants hard delete, require "delete all linked transactions first" (dangerous operation).
```

**Edge Case 7: Maximum accounts limit**
```
Scenario: User creates 100+ accounts (edge case for hoarders)
Solution: No hard limit enforced initially
Future: Warn at 50 accounts, suggest archiving unused ones
Rationale: Most users have 3-10 accounts. 100 is pathological but allowed.
```

---

### 8. Acceptance Criteria (Definition of Done)

**User can create account:**
- ✅ POST /api/accounts creates new account
- ✅ Account assigned unique account_id (format: `acc_{slug}_{seq}`)
- ✅ Account appears in GET /api/accounts list
- ✅ Account appears in AccountSelector dropdown

**User can edit account:**
- ✅ PUT /api/accounts/{id} updates name, institution
- ✅ Currency cannot be changed (immutable)
- ✅ Type cannot be changed (immutable after creation)
- ✅ updated_at timestamp updated

**User can archive account:**
- ✅ DELETE /api/accounts/{id} sets is_active = false
- ✅ Account disappears from default account list (is_active=true)
- ✅ Historical transactions remain linked
- ✅ Archived account visible in GET /api/accounts?is_active=false

**User can unarchive account:**
- ✅ PUT /api/accounts/{id} with is_active=true restores account
- ✅ Account reappears in active list

**Validation works:**
- ✅ Duplicate names rejected (409 Conflict)
- ✅ Invalid types rejected (400 Bad Request)
- ✅ Invalid currencies rejected (400 Bad Request)
- ✅ Name too long rejected (400 Bad Request)

**Multi-user isolation:**
- ✅ User A cannot see User B's accounts
- ✅ User A cannot edit User B's accounts
- ✅ account_id is globally unique (not per-user)

---

### 9. Logs & Provenance

**Account Change Log:**

Every account modification is logged in `account_change_log` table:

```sql
CREATE TABLE account_change_log (
    log_id VARCHAR(50) PRIMARY KEY,
    account_id VARCHAR(50) NOT NULL,
    user_id VARCHAR(50) NOT NULL,

    operation VARCHAR(20) NOT NULL,  -- CREATE, UPDATE, ARCHIVE, UNARCHIVE
    changes JSONB,                   -- {field: {old: X, new: Y}}

    timestamp TIMESTAMP NOT NULL,

    FOREIGN KEY (account_id) REFERENCES accounts(account_id),
    INDEX idx_account (account_id),
    INDEX idx_user (user_id)
);
```

**Example Log Entry (CREATE):**
```json
{
  "log_id": "acl_1234567890",
  "account_id": "acc_bofa_checking_1",
  "user_id": "user_darwin",
  "operation": "CREATE",
  "changes": {
    "name": {"old": null, "new": "BofA Checking"},
    "type": {"old": null, "new": "checking"},
    "currency": {"old": null, "new": "USD"},
    "institution": {"old": null, "new": "Bank of America"}
  },
  "timestamp": "2025-05-15T10:00:00Z"
}
```

**Example Log Entry (UPDATE):**
```json
{
  "log_id": "acl_1234567891",
  "account_id": "acc_bofa_checking_1",
  "user_id": "user_darwin",
  "operation": "UPDATE",
  "changes": {
    "name": {"old": "BofA Checking", "new": "BofA Personal Checking"}
  },
  "timestamp": "2025-05-16T14:30:00Z"
}
```

**Example Log Entry (ARCHIVE):**
```json
{
  "log_id": "acl_1234567892",
  "account_id": "acc_apple_card_4",
  "user_id": "user_darwin",
  "operation": "ARCHIVE",
  "changes": {
    "is_active": {"old": true, "new": false}
  },
  "timestamp": "2025-06-01T09:00:00Z"
}
```

**Use Cases:**
- Audit trail: "Who changed what when?"
- Undo functionality (future): Revert to previous name
- Analytics: How often do users edit accounts?

---

### 10. Risks & Deferred

**RISKS:**

1. **Currency immutability:**
   - Risk: User creates account with wrong currency, wants to change it
   - Mitigation: Clear error message: "Currency cannot be changed. Create new account instead."
   - Future: Allow currency change if account has 0 transactions

2. **Account deletion (hard delete):**
   - Risk: User expects "Delete" to permanently remove account
   - Mitigation: UI says "Archive Account" not "Delete Account"
   - Future: Add "Permanently Delete" option (requires confirming 0 transactions)

3. **Multi-currency accounts:**
   - Risk: Some accounts hold multiple currencies (e.g., Wise multi-currency)
   - Deferred: V1 assumes 1 account = 1 currency. Future: account_currencies table.

**DEFERRED:**

1. **Account icons/colors:**
   - Feature: User assigns custom icon (🏦) or color (#4CAF50) to account
   - Deferred to: V2 (UX enhancement)

2. **Account import from Plaid/banks:**
   - Feature: Auto-import accounts from bank API
   - Deferred to: Vertical 5.x (External Integrations)

3. **Account balance tracking:**
   - Feature: Show current balance per account
   - Deferred to: Vertical 4.x (Balance Reconciliation)

4. **Account categories/tags:**
   - Feature: Tag accounts with categories (e.g., "Business", "Personal")
   - Deferred to: V2 (simplified for V1)

5. **Multi-user account sharing:**
   - Feature: Multiple users share same account (e.g., joint account)
   - Deferred to: V3 (collaboration features)

---

## MACHINERY LAYER (Sections 11-15)

### 11. Primitives Introduced

This vertical introduces **4 new primitives:**

#### 11.1 AccountStore (OL Primitive)

**Purpose:** CRUD operations for accounts with validation and uniqueness checks

**Multi-domain applicability:**
- Finance: Bank accounts, credit cards, payment processors
- Healthcare: Insurance providers, medical facilities, pharmacy accounts
- Legal: Trust accounts, client accounts, retainer accounts
- Research: Funding sources, grant accounts, institutional accounts
- Manufacturing: Cost centers, departments, production lines
- Media: Revenue streams, ad accounts, monetization channels

**See:** `docs/primitives/ol/AccountStore.md`

---

#### 11.2 AccountValidator (OL Primitive)

**Purpose:** Validates account data (names, types, currencies, uniqueness)

**Multi-domain applicability:**
- Finance: Validate account types (checking, credit, etc.)
- Healthcare: Validate provider types (insurance, pharmacy, hospital)
- Legal: Validate account types (trust, client, operating)
- Research: Validate funding source types (grant, institution, private)
- Manufacturing: Validate cost center codes, department names
- Media: Validate revenue stream types (ads, subscriptions, sponsors)

**See:** `docs/primitives/ol/AccountValidator.md`

---

#### 11.3 AccountManager (IL Component)

**Purpose:** Full CRUD UI for managing accounts (list, create, edit, archive)

**Multi-domain applicability:**
- Finance: Manage bank accounts
- Healthcare: Manage insurance providers
- Legal: Manage trust accounts
- Research: Manage funding sources
- Manufacturing: Manage cost centers
- Media: Manage revenue streams

**See:** `docs/primitives/il/AccountManager.md`

---

#### 11.4 AccountSelector (IL Component)

**Purpose:** Reusable dropdown for selecting account (used in transaction editing, filtering, reports)

**Multi-domain applicability:**
- Finance: Select account in transaction edit, filter by account
- Healthcare: Select insurance provider in claim edit
- Legal: Select trust account in transaction allocation
- Research: Select funding source in expense reporting
- Manufacturing: Select cost center in work order
- Media: Select revenue stream in content analytics

**See:** `docs/primitives/il/AccountSelector.md`

---

### 12. Interlocks with Other Verticals

**DEPENDS ON (Prerequisites):**

1. **Vertical 1.3 (Normalization) - CanonicalStore**
   - Why: Canonical transactions have `account_id` field
   - Integration: CanonicalStore queries AccountStore to validate account exists
   - Example: When normalizing observation, verify account_id is valid

2. **Vertical 2.1 (Transaction List View) - TransactionQuery**
   - Why: Users filter transactions by account
   - Integration: TransactionQuery uses AccountStore to resolve account names
   - Example: "Show all transactions from BofA Checking"

**ENABLES (Future Verticals):**

1. **Vertical 3.5 (Relationships) - Transfer Linking**
   - Why: Transfers link two accounts (from_account, to_account)
   - Integration: Relationship engine queries AccountStore to validate both accounts exist
   - Example: Transfer from "BofA Checking" to "Wise USD"

2. **Vertical 4.x (Balance Reconciliation)**
   - Why: Balances tracked per account
   - Integration: Balance engine reads account list from AccountStore
   - Example: "BofA Checking balance: $5,432.10"

3. **Vertical 3.3 (Series) - Recurring Payments**
   - Why: Series tied to specific account
   - Integration: Series entity has account_id field
   - Example: "OpenAI Subscription charged to BofA Credit every month"

**CROSS-CUTTING:**

1. **Vertical 2.2 (OL Exploration) - DrillDownPanel**
   - Integration: Drill-down shows account name (not just account_id)
   - Enhancement: Click account name → view all transactions for that account

2. **Vertical 2.3 (Finance Dashboard) - MetricCard**
   - Integration: Dashboard shows metrics per account
   - Example: "BofA Checking - $9,000 income this month"

---

### 13. Reusability (Multi-Domain Generalization)

**Core Pattern: Closed Registry Management**

Account Registry is an instance of **Closed Registry Pattern** - a user-curated, fixed-size collection of entities.

**Universal Properties:**
1. User explicitly creates each item (not auto-discovered)
2. Items have unique names (enforced)
3. Items can be edited
4. Items can be archived (soft delete)
5. Items are used as foreign keys in other entities
6. Small dataset (<100 items per user)

**Other Domains Using Same Pattern:**

| Domain | Finance Example | Healthcare Example | Legal Example | Research Example |
|--------|----------------|-------------------|---------------|------------------|
| **Entity** | Account | Insurance Provider | Trust Account | Funding Source |
| **Examples** | BofA Checking, Apple Card | Blue Cross, Aetna | Client Trust 1, Operating | NIH Grant, NSF Award |
| **Attributes** | name, type, currency | name, type, policy_number | name, type, jurisdiction | name, type, amount |
| **Foreign Key** | canonical_transaction.account_id | claim.provider_id | transaction.account_id | expense.funding_source_id |

**Abstraction:**

```typescript
interface ClosedRegistry<T> {
  create(item: T): T;
  update(item_id: string, updates: Partial<T>): T;
  archive(item_id: string): void;
  list(filters?: { is_active?: boolean }): T[];
}

// Finance instantiation
type Account = {
  account_id: string;
  name: string;
  type: AccountType;
  currency: string;
}

// Healthcare instantiation
type InsuranceProvider = {
  provider_id: string;
  name: string;
  type: ProviderType;
  policy_number: string;
}

// Same CRUD operations, different data
```

**Multi-domain primitives:**
- `ClosedRegistryStore` (generic CRUD)
- `ClosedRegistryValidator` (generic validation)
- `RegistryManager` (generic UI component)
- `RegistrySelector` (generic dropdown)

**Finance-specific primitives:**
- `AccountStore extends ClosedRegistryStore<Account>`
- `AccountValidator extends ClosedRegistryValidator<Account>`
- `AccountManager` (uses RegistryManager)
- `AccountSelector` (uses RegistrySelector)

---

### 14. Pattern Abstraction

**Pattern Name:** **Closed Registry Management Pattern**

**Intent:**
Manage a user-curated, fixed-size collection of named entities with uniqueness constraints.

**When to Use:**
- User needs to manage a small set of entities (<100 items)
- Each entity has a unique name
- Entities are referenced by other parts of the system (foreign keys)
- Entities should be archived (not deleted) to preserve history

**Structure:**

```
┌─────────────────────────────────────────┐
│         RegistryManager (UI)            │
│  - List items                           │
│  - Create new item                      │
│  - Edit existing item                   │
│  - Archive item                         │
└─────────────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│      ClosedRegistryStore (OL)           │
│  - create(item)                         │
│  - update(item_id, updates)             │
│  - archive(item_id)                     │
│  - list(filters)                        │
└─────────────────────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│    ClosedRegistryValidator (OL)         │
│  - validate_unique_name()               │
│  - validate_required_fields()           │
│  - validate_immutable_fields()          │
└─────────────────────────────────────────┘
```

**Participants:**

1. **ClosedRegistryStore** - Handles CRUD operations and persistence
2. **ClosedRegistryValidator** - Validates data before persistence
3. **RegistryManager** - UI for managing registry items
4. **RegistrySelector** - Dropdown for selecting registry item

**Consequences:**

**Benefits:**
- ✅ Reusable across domains (finance, health, legal, etc.)
- ✅ Simple mental model (create, edit, archive)
- ✅ Data integrity (soft delete preserves history)
- ✅ Uniqueness guaranteed (no duplicate names)

**Drawbacks:**
- ❌ Not suitable for large datasets (>1000 items)
- ❌ No auto-discovery (user must manually create each item)
- ❌ Name conflicts can frustrate users (must be globally unique per user)

**Related Patterns:**
- **Open Registry Pattern** (Vertical 3.2 Counterparty) - Auto-grows as new entities discovered
- **Master Data Management** - Enterprise-scale registry with hierarchy, synonyms, deduplication

---

### 15. Métricas de Madurez

**Functional Maturity:**

| Metric | Target | Measurement |
|--------|--------|-------------|
| Account CRUD operations | 100% | All create, read, update, archive operations work |
| Uniqueness validation | 100% | No duplicate names allowed |
| Soft delete | 100% | Archiving preserves transaction links |
| API error handling | 100% | All edge cases return correct status codes |
| Multi-user isolation | 100% | Users cannot see each other's accounts |

**Non-Functional Maturity:**

| Metric | Target | Current | Measurement |
|--------|--------|---------|-------------|
| API response time (GET /accounts) | <100ms p95 | TBD | Response time for fetching 10 accounts |
| API response time (POST /account) | <200ms p95 | TBD | Response time for creating account |
| Concurrent users | 1000+ | TBD | System handles 1000 concurrent account operations |
| Data consistency | 100% | TBD | No orphaned transactions (all link to valid accounts) |
| Audit trail completeness | 100% | TBD | All account changes logged |

**Operational Maturity:**

| Metric | Target | Current |
|--------|--------|---------|
| API uptime | 99.9% | TBD |
| Error rate | <0.1% | TBD |
| Data backup frequency | Daily | TBD |
| Monitoring alerts configured | 100% | TBD |
| Runbook completeness | 100% | TBD |

---

## CROSS-CUTTING CONCERNS (Sections 16-20)

### 16. Security Considerations

**Authentication & Authorization:**

1. **User Isolation:**
   - Rule: Users can only access their own accounts
   - Enforcement: All queries filtered by `user_id` from JWT token
   - Test: User A cannot GET /api/accounts for User B

2. **Account Ownership:**
   - Rule: Only account owner can edit/archive account
   - Enforcement: UPDATE/DELETE endpoints verify `user_id` matches account owner
   - Test: User A cannot edit User B's account (returns 403 Forbidden)

3. **Token-Based Auth:**
   - All endpoints require `Authorization: Bearer {token}` header
   - Invalid token → 401 Unauthorized
   - Missing token → 401 Unauthorized

**Input Validation:**

1. **SQL Injection Prevention:**
   - All inputs sanitized before SQL queries
   - Use parameterized queries (never string concatenation)
   - Example: `SELECT * FROM accounts WHERE account_id = ?` (parameterized)

2. **XSS Prevention:**
   - Account names sanitized on output
   - HTML tags stripped/escaped
   - Example: User enters `<script>alert('xss')</script>` → stored as plain text

3. **Name Length Limits:**
   - Max 100 characters for account name
   - Max 200 characters for institution
   - Prevents database overflow attacks

**Data Privacy:**

1. **No PII Leakage:**
   - Account names are user-defined (may contain sensitive info)
   - Never log account names in plain text
   - Redact in logs: `"account_name": "[REDACTED]"`

2. **Audit Trail Access:**
   - Only account owner can view change log
   - Admin access requires separate permission (future)

**Future Enhancements:**
- Role-based access control (RBAC) for shared accounts
- Account-level encryption for sensitive institution data
- Rate limiting to prevent account enumeration attacks

---

### 17. Performance Characteristics

**Database Queries:**

**Query 1: List Active Accounts**
```sql
SELECT * FROM accounts
WHERE user_id = ? AND is_active = true
ORDER BY name ASC;
```
- **Expected rows:** 3-10 per user (typical), up to 50 (edge case)
- **Index:** `idx_user_active (user_id, is_active)`
- **Performance:** <10ms (indexed query)

**Query 2: Create Account**
```sql
INSERT INTO accounts (account_id, user_id, name, type, currency, institution, is_active, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, true, NOW(), NOW());
```
- **Performance:** <20ms (single INSERT)
- **Constraint check:** UNIQUE(user_id, name) validated automatically

**Query 3: Update Account**
```sql
UPDATE accounts
SET name = ?, institution = ?, updated_at = NOW()
WHERE account_id = ? AND user_id = ?;
```
- **Performance:** <20ms (indexed on account_id)

**Query 4: Archive Account**
```sql
UPDATE accounts
SET is_active = false, updated_at = NOW()
WHERE account_id = ? AND user_id = ?;
```
- **Performance:** <20ms

**Query 5: Count Linked Transactions (for Archive Confirmation)**
```sql
SELECT COUNT(*) FROM canonical_transactions
WHERE account_id = ?;
```
- **Performance:** <50ms (indexed on account_id)
- **Note:** Only called on archive operation

**Caching Strategy:**

- **Cache Key:** `accounts:{user_id}:active`
- **TTL:** 5 minutes
- **Invalidation:** On create/update/archive operation
- **Benefit:** Repeated GET /api/accounts calls served from cache (<1ms)

**Pagination:**

- **Not needed for accounts.** Small dataset (<100 items per user).
- **Future:** If user has 100+ accounts, implement cursor-based pagination (reuse PaginationEngine from Vertical 2.1)

**Performance Targets:**

| Operation | Target p95 Latency |
|-----------|--------------------|
| GET /api/accounts | <100ms |
| POST /api/accounts | <200ms |
| PUT /api/accounts/{id} | <150ms |
| DELETE /api/accounts/{id} | <150ms |

---

### 18. Observability

**Metrics to Track:**

1. **Request Metrics:**
   - `account.create.requests` (counter)
   - `account.create.success` (counter)
   - `account.create.errors` (counter by error_code)
   - `account.create.duration` (histogram)

2. **Account Count Metrics:**
   - `accounts.total` (gauge) - Total accounts in system
   - `accounts.active` (gauge) - Total active accounts
   - `accounts.per_user.avg` (gauge) - Average accounts per user
   - `accounts.per_user.p95` (gauge) - 95th percentile accounts per user

3. **Error Metrics:**
   - `account.duplicate_name_errors` (counter)
   - `account.invalid_type_errors` (counter)
   - `account.not_found_errors` (counter)
   - `account.unauthorized_errors` (counter)

**Logs to Emit:**

**Structured Log Format:**
```json
{
  "timestamp": "2025-05-15T10:00:00Z",
  "level": "info",
  "event": "account.created",
  "user_id": "user_darwin",
  "account_id": "acc_bofa_checking_1",
  "account_type": "checking",
  "currency": "USD",
  "duration_ms": 45
}
```

**Log Events:**
- `account.created` - Account successfully created
- `account.updated` - Account updated
- `account.archived` - Account archived
- `account.unarchived` - Account reactivated
- `account.duplicate_name_error` - Duplicate name rejected
- `account.validation_error` - Validation failed (with details)

**Dashboards:**

**Dashboard 1: Account Operations**
- Total accounts created (last 7 days)
- Active vs archived accounts (pie chart)
- Account creation errors (by error type)
- Average accounts per user

**Dashboard 2: API Performance**
- Request latency (p50, p95, p99) by endpoint
- Error rate (%) by endpoint
- Requests per second

**Dashboard 3: User Behavior**
- Distribution of account types (checking, credit, etc.)
- Top currencies used
- Average time between account creation and first edit

**Alerts:**

1. **High Error Rate:**
   - Condition: `account.create.errors > 10% of account.create.requests`
   - Severity: Warning
   - Action: Check logs for common error patterns

2. **Slow API Response:**
   - Condition: `account.create.duration p95 > 500ms`
   - Severity: Warning
   - Action: Check database performance, consider index optimization

3. **Database Connection Errors:**
   - Condition: `account.database.connection_errors > 0`
   - Severity: Critical
   - Action: Page on-call engineer

---

### 19. Testing Strategy

**Unit Tests:**

**Test: AccountStore.create()**
```python
def test_create_account_success():
    store = AccountStore(db_connection)
    account = store.create(
        user_id="user_test",
        name="Test Checking",
        type="checking",
        currency="USD",
        institution="Test Bank"
    )
    assert account.account_id.startswith("acc_")
    assert account.name == "Test Checking"
    assert account.is_active == True

def test_create_account_duplicate_name():
    store = AccountStore(db_connection)
    store.create(user_id="user_test", name="Test Checking", type="checking", currency="USD")

    with pytest.raises(DuplicateAccountNameError):
        store.create(user_id="user_test", name="Test Checking", type="savings", currency="USD")

def test_create_account_invalid_type():
    store = AccountStore(db_connection)
    with pytest.raises(InvalidAccountTypeError):
        store.create(user_id="user_test", name="Test", type="invalid_type", currency="USD")
```

**Test: AccountValidator.validate_name()**
```python
def test_validate_name_too_long():
    validator = AccountValidator()
    with pytest.raises(ValidationError):
        validator.validate_name("A" * 101)  # 101 characters

def test_validate_name_invalid_characters():
    validator = AccountValidator()
    with pytest.raises(ValidationError):
        validator.validate_name("BofA <script>alert('xss')</script>")

def test_validate_currency_invalid_format():
    validator = AccountValidator()
    with pytest.raises(ValidationError):
        validator.validate_currency("usd")  # Must be uppercase
```

**Integration Tests:**

**Test: Full CRUD Flow**
```python
def test_account_crud_flow():
    # Create
    response = client.post("/api/accounts", json={
        "name": "Test Account",
        "type": "checking",
        "currency": "USD"
    }, headers={"Authorization": f"Bearer {token}"})
    assert response.status_code == 201
    account_id = response.json()["account"]["account_id"]

    # Read
    response = client.get("/api/accounts", headers={"Authorization": f"Bearer {token}"})
    assert response.status_code == 200
    assert len(response.json()["accounts"]) == 1

    # Update
    response = client.put(f"/api/accounts/{account_id}", json={
        "name": "Test Account Updated"
    }, headers={"Authorization": f"Bearer {token}"})
    assert response.status_code == 200
    assert response.json()["account"]["name"] == "Test Account Updated"

    # Archive
    response = client.delete(f"/api/accounts/{account_id}", headers={"Authorization": f"Bearer {token}"})
    assert response.status_code == 200
    assert response.json()["account"]["is_active"] == False

    # Verify archived account not in active list
    response = client.get("/api/accounts?is_active=true", headers={"Authorization": f"Bearer {token}"})
    assert len(response.json()["accounts"]) == 0
```

**E2E Tests:**

**Test: New User Onboarding**
```typescript
test("New user can add first account", async () => {
  await page.goto("/accounts");
  await page.click("button:has-text('Add Account')");

  await page.fill("input[name='name']", "BofA Checking");
  await page.selectOption("select[name='type']", "checking");
  await page.selectOption("select[name='currency']", "USD");
  await page.fill("input[name='institution']", "Bank of America");

  await page.click("button:has-text('Save')");

  // Verify account appears in list
  await expect(page.locator("text=BofA Checking")).toBeVisible();
});
```

**Test: Duplicate Name Validation**
```typescript
test("Cannot create account with duplicate name", async () => {
  // Create first account
  await createAccount({name: "BofA Checking", type: "checking", currency: "USD"});

  // Try to create duplicate
  await page.click("button:has-text('Add Account')");
  await page.fill("input[name='name']", "BofA Checking");
  await page.selectOption("select[name='type']", "savings");
  await page.selectOption("select[name='currency']", "USD");
  await page.click("button:has-text('Save')");

  // Verify error message
  await expect(page.locator("text=Account with name 'BofA Checking' already exists")).toBeVisible();
});
```

**Performance Tests:**

```python
def test_list_accounts_performance():
    # Setup: Create 50 accounts
    for i in range(50):
        store.create(user_id="user_test", name=f"Account {i}", type="checking", currency="USD")

    # Test: List accounts
    start = time.time()
    accounts = store.list(user_id="user_test", is_active=True)
    duration = (time.time() - start) * 1000  # Convert to ms

    assert len(accounts) == 50
    assert duration < 100  # Target: <100ms
```

---

### 20. Operations Runbook

**Deployment:**

**Pre-Deployment Checklist:**
- [ ] Database migration ready (accounts table, account_change_log table)
- [ ] Indexes created (idx_user_active, unique constraint on user_id + name)
- [ ] API endpoints tested in staging
- [ ] UI components tested in staging
- [ ] Rollback plan documented

**Deployment Steps:**
1. Run database migration: `migrate up 003_create_accounts_table`
2. Deploy backend API (zero-downtime deployment)
3. Deploy frontend UI
4. Verify health checks pass
5. Monitor error rates for 1 hour

**Rollback Plan:**
- If API errors spike: Roll back backend to previous version
- If database migration fails: Run `migrate down 003_create_accounts_table`
- If UI breaks: Roll back frontend, backend remains deployed (API still works)

---

**Monitoring & Alerts:**

**Health Check Endpoint:**
```http
GET /health/accounts
```

**Response (Healthy):**
```json
{
  "status": "healthy",
  "database": "connected",
  "cache": "connected",
  "accounts_count": 1234
}
```

**Alerts Configured:**
1. `account_api_error_rate > 5%` → Slack #alerts
2. `account_api_p95_latency > 500ms` → Slack #alerts
3. `account_database_connection_errors > 0` → PagerDuty (critical)

---

**Common Issues & Resolutions:**

**Issue 1: Duplicate Name Error Spike**
- **Symptom:** Increase in `account.duplicate_name_errors`
- **Possible Cause:** Bug in UI not checking for existing names before submit
- **Resolution:** Check UI validation logic, ensure client-side check before API call
- **Prevention:** Add integration test for duplicate name prevention

**Issue 2: Slow Account List Query**
- **Symptom:** `account.list.duration p95 > 500ms`
- **Possible Cause:** Missing index on `user_id + is_active`
- **Resolution:** Verify index exists: `SHOW INDEX FROM accounts WHERE Key_name = 'idx_user_active'`
- **Prevention:** Add index verification to deployment checklist

**Issue 3: Orphaned Transactions**
- **Symptom:** Transactions reference account_id that doesn't exist
- **Possible Cause:** Hard delete instead of soft delete
- **Resolution:** Run data integrity check: `SELECT COUNT(*) FROM canonical_transactions WHERE account_id NOT IN (SELECT account_id FROM accounts)`
- **Prevention:** Never allow hard delete of accounts, enforce soft delete only

---

**Backup & Recovery:**

**Backup Schedule:**
- **Frequency:** Daily at 2 AM UTC
- **Retention:** 30 days
- **Scope:** Full database backup (includes accounts table, account_change_log)

**Recovery Scenarios:**

**Scenario 1: User accidentally archives all accounts**
- **Solution:** Restore from account_change_log (unarchive operation)
- **Command:** `UPDATE accounts SET is_active = true WHERE user_id = ? AND updated_at > ?`

**Scenario 2: Data corruption (wrong account types)**
- **Solution:** Restore from latest backup, replay account_change_log to current state
- **Downtime:** ~15 minutes

**Scenario 3: Complete database loss**
- **Solution:** Restore from S3 backup
- **RTO:** 1 hour
- **RPO:** 24 hours (last backup)

---

**Scaling Considerations:**

**Current Scale:**
- **Users:** <10,000
- **Accounts:** <50,000 (avg 5 accounts per user)
- **QPS:** <100 requests/second

**Future Scale (1M users):**
- **Accounts:** ~5,000,000
- **Database:** Add read replicas for GET /api/accounts
- **Caching:** Increase cache TTL to 10 minutes
- **Sharding:** Shard by user_id if needed (unlikely - accounts table remains small)

---

**End of Vertical 3.1 Specification**

**Progress:** 7/23 verticals complete (30%)
**Next:** 3.2 Counterparty Registry (open registry)
