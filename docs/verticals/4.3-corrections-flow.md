# Vertical 4.3: Corrections Flow

**Version:** 1.0
**Status:** Complete
**Last Updated:** 2025-10-24

---

## Overview

The **Corrections Flow** vertical provides a comprehensive system for manual correction of extracted, parsed, or normalized data. Users can override any field-level value (category, merchant, amount, date, etc.), with full audit trail tracking who changed what, when, and why. The system enforces clear precedence rules (manual override > automated rule > extraction > default) and validates all corrections before persisting.

**Key principle:** NO AI/ML assistance—corrections are 100% manual, user-driven, and transparent.

---

## Table of Contents

### Product Layer (Sections 1-10)
1. [User Stories](#1-user-stories)
2. [Core Capabilities](#2-core-capabilities)
3. [User Flows](#3-user-flows)
4. [Edge Cases](#4-edge-cases)
5. [Success Metrics](#5-success-metrics)
6. [Business Value](#6-business-value)
7. [User Experience Goals](#7-user-experience-goals)
8. [Accessibility & Inclusivity](#8-accessibility--inclusivity)
9. [Localization & Internationalization](#9-localization--internationalization)
10. [Product Roadmap & Iteration](#10-product-roadmap--iteration)

### Machinery Layer (Sections 11-15)
11. [Architecture Overview](#11-architecture-overview)
12. [Component Specifications](#12-component-specifications)
13. [Reusability & Multi-Domain Examples](#13-reusability--multi-domain-examples)
14. [Pattern Abstraction](#14-pattern-abstraction)
15. [Integration Points](#15-integration-points)

### Cross-Cutting Concerns (Sections 16-20)
16. [Security & Privacy](#16-security--privacy)
17. [Performance & Scalability](#17-performance--scalability)
18. [Observability & Debugging](#18-observability--debugging)
19. [Testing Strategy](#19-testing-strategy)
20. [Operational Considerations](#20-operational-considerations)

---

## Product Layer

### 1. User Stories

**As a financial analyst**, I want to:
- Correct a merchant name that was extracted incorrectly from a PDF ("AMZN MKTP" → "Amazon Marketplace")
- Override an auto-categorized transaction ("Shopping" → "Business Expenses")
- Fix a misread amount ($1,234.56 read as $123.45)
- See the complete audit trail of who changed this transaction and why
- Revert to the original extracted value if my correction was wrong

**As a healthcare data manager**, I want to:
- Correct a diagnosis code that was auto-assigned incorrectly (ICD-10: E11.9 → E11.65)
- Override provider name normalization ("Dr. Smith" → "Dr. John Smith, MD")
- Adjust procedure dates that were parsed from scanned documents incorrectly
- Track who corrected patient records for compliance audits

**As a legal assistant**, I want to:
- Fix case numbers that were OCR'd incorrectly from court filings
- Override attorney name normalization when the system merged two different attorneys
- Correct filing dates when the parser misread handwritten dates
- Document why each correction was made (for audit trail)

**As a research coordinator**, I want to:
- Correct author names that were extracted incorrectly from PDFs ("Smith, J." → "Smith, John A.")
- Override publication year when metadata extraction was wrong
- Fix journal names that were abbreviated inconsistently
- See the history of corrections for data quality reports

**As an e-commerce catalog manager**, I want to:
- Correct product categories that were auto-classified incorrectly
- Override normalized brand names when the system merged separate brands
- Fix prices that were parsed incorrectly from supplier catalogs
- Bulk-correct multiple products with the same error pattern

**As a SaaS operations analyst**, I want to:
- Correct plan names that were extracted from billing data inconsistently
- Override MRR calculations when the automated rule missed edge cases
- Fix billing cycle dates that were parsed incorrectly
- Track who corrected subscription records for revenue reconciliation

---

### 2. Core Capabilities

#### 2.1 Field-Level Overrides

**Capability:** Users can override ANY field independently—category, merchant, amount, date, description, etc.

**Example (Finance):**
```json
// Original extraction
{
  "merchant": "AMZN MKTP US*AB123",
  "amount": 45.99,
  "category": "Shopping",
  "date": "2025-10-20"
}

// User corrects merchant + category (amount/date unchanged)
{
  "merchant": "Amazon Marketplace",  // ← MANUAL OVERRIDE
  "amount": 45.99,                   // ← original extraction
  "category": "Business Expenses",   // ← MANUAL OVERRIDE
  "date": "2025-10-20"               // ← original extraction
}

// System stores:
{
  "field_overrides": [
    {
      "field": "merchant",
      "original_value": "AMZN MKTP US*AB123",
      "override_value": "Amazon Marketplace",
      "overridden_by": "user_123",
      "overridden_at": "2025-10-24T10:30:00Z",
      "reason": "Normalize merchant name for reporting"
    },
    {
      "field": "category",
      "original_value": "Shopping",
      "override_value": "Business Expenses",
      "overridden_by": "user_123",
      "overridden_at": "2025-10-24T10:30:15Z",
      "reason": "Correct business expense misclassification"
    }
  ]
}
```

**Benefits:**
- Granular corrections (only fix what's wrong)
- Preserve original extraction (can revert)
- Clear audit trail per field
- No need to re-extract entire record

#### 2.2 Audit Trail Per Field

**Capability:** Every field change is logged with who, when, why, original value, new value.

**Example (Healthcare):**
```json
// Audit trail for diagnosis_code field
{
  "field": "diagnosis_code",
  "audit_entries": [
    {
      "timestamp": "2025-10-20T08:00:00Z",
      "action": "extracted",
      "value": "E11.9",
      "source": "parser_ocr_v2",
      "confidence": 0.92
    },
    {
      "timestamp": "2025-10-21T14:30:00Z",
      "action": "override",
      "previous_value": "E11.9",
      "new_value": "E11.65",
      "changed_by": "user_nurse_456",
      "reason": "Patient has chronic kidney disease, E11.9 too generic",
      "source": "manual_correction"
    },
    {
      "timestamp": "2025-10-22T09:15:00Z",
      "action": "revert",
      "previous_value": "E11.65",
      "new_value": "E11.9",
      "changed_by": "user_doctor_789",
      "reason": "CKD not documented in chart, reverting to original",
      "source": "manual_correction"
    }
  ]
}
```

**Benefits:**
- Full transparency for compliance
- Understand why data changed over time
- Identify patterns of corrections (e.g., parser consistently wrong on X)
- Support retroactive queries ("what was the value on 2025-10-21?")

#### 2.3 Precedence Rules

**Capability:** System resolves conflicts using static precedence hierarchy.

**Precedence Order (highest to lowest):**
1. **Manual Override** (user explicitly corrected)
2. **Automated Rule** (normalization rule applied)
3. **Extraction** (parser/OCR output)
4. **Default** (fallback value)

**Example (Finance):**
```typescript
// Transaction with multiple value sources
{
  "merchant": {
    "extraction_value": "AMZN MKTP US*AB123",      // from PDF parser
    "rule_value": "Amazon",                         // from normalization rule
    "manual_override": "Amazon Marketplace",        // user corrected
    "default_value": "Unknown Merchant"
  }
}

// Precedence resolution
PrecedenceEngine.resolve("merchant")
  → "Amazon Marketplace"  // manual override wins
```

**Example (Legal - no override):**
```typescript
{
  "case_number": {
    "extraction_value": "2025-CV-1234",     // from OCR
    "rule_value": null,                      // no rule applied
    "manual_override": null,                 // no user correction
    "default_value": "UNKNOWN"
  }
}

// Precedence resolution
PrecedenceEngine.resolve("case_number")
  → "2025-CV-1234"  // extraction wins (no override/rule)
```

**Benefits:**
- Predictable value resolution
- User corrections always respected
- Automation helps but never overrides user intent
- Clear hierarchy for debugging

#### 2.4 Validation Engine

**Capability:** Validate overrides BEFORE accepting them to prevent invalid data.

**Validation Rules:**
- **Type validation:** Amount must be numeric, date must be valid date, etc.
- **Range validation:** Amount > 0, date within reasonable range, etc.
- **Format validation:** Category from allowed list, merchant not empty, etc.
- **Business logic validation:** No future dates for historical transactions, etc.

**Example (Finance - Validation Failures):**
```typescript
// User attempts invalid corrections
{
  "amount": "abc",              // ❌ REJECTED: not a number
  "date": "2030-01-01",         // ❌ REJECTED: future date for historical transaction
  "category": "InvalidCategory", // ❌ REJECTED: not in allowed category list
  "merchant": "",               // ❌ REJECTED: cannot be empty
}

// ValidationEngine returns:
{
  "valid": false,
  "errors": [
    { "field": "amount", "error": "Must be a valid number" },
    { "field": "date", "error": "Cannot be in the future for historical transaction" },
    { "field": "category", "error": "Must be one of: [Income, Shopping, Business, ...]" },
    { "field": "merchant", "error": "Cannot be empty" }
  ]
}
```

**Example (Healthcare - Validation Success):**
```typescript
// User corrects diagnosis code
{
  "diagnosis_code": "E11.65"  // ✅ ACCEPTED: valid ICD-10 code
}

// ValidationEngine returns:
{
  "valid": true,
  "errors": []
}
```

**Benefits:**
- Prevent garbage data from entering system
- Provide immediate feedback to user
- Maintain data integrity
- Reduce downstream errors

---

### 3. User Flows

#### Flow 1: Correct Single Field

**Actor:** Financial analyst
**Goal:** Fix merchant name on one transaction
**Duration:** ~30 seconds

**Steps:**
1. User views transaction in UI
2. Notices merchant is "AMZN MKTP US*AB123" (ugly extraction)
3. Clicks "Edit" button on transaction card
4. CorrectionDialog opens showing all fields
5. User edits merchant field: "AMZN MKTP US*AB123" → "Amazon Marketplace"
6. User adds reason: "Normalize merchant name for reporting"
7. User clicks "Save"
8. ValidationEngine validates: ✅ valid
9. OverrideStore creates field_override record
10. AuditLog logs change (who=user_123, when=now, why=reason)
11. UI updates to show "Amazon Marketplace" with FieldOverrideIndicator badge
12. User sees confirmation toast: "Merchant corrected successfully"

**Result:** Merchant field now shows "Amazon Marketplace" with small badge indicating manual override.

---

#### Flow 2: View Audit Trail for Field

**Actor:** Healthcare data manager
**Goal:** See who changed diagnosis_code and why
**Duration:** ~15 seconds

**Steps:**
1. User views patient record in UI
2. Notices diagnosis_code has FieldOverrideIndicator badge
3. User hovers over badge → tooltip: "Manually corrected by Dr. Smith on 2025-10-21"
4. User clicks badge to open AuditTrailViewer drawer
5. AuditTrailViewer shows timeline:
   - **2025-10-20 08:00** - Extracted: "E11.9" (OCR, confidence: 92%)
   - **2025-10-21 14:30** - Corrected by Nurse Johnson: "E11.9" → "E11.65" (Reason: "Patient has CKD")
   - **2025-10-22 09:15** - Reverted by Dr. Smith: "E11.65" → "E11.9" (Reason: "CKD not documented")
6. User understands the history and closes drawer

**Result:** User has full transparency into field changes.

---

#### Flow 3: Revert Override

**Actor:** Legal assistant
**Goal:** Revert incorrect correction
**Duration:** ~20 seconds

**Steps:**
1. User views case record in UI
2. Sees attorney_name is "John Smith" (manually corrected yesterday)
3. Realizes correction was wrong (should be "Jane Smith", different attorney)
4. Opens CorrectionDialog
5. Clicks "View History" button for attorney_name field
6. AuditTrailViewer shows:
   - **Original extraction:** "J. Smith"
   - **Yesterday's correction:** "John Smith" (by user_789)
7. User clicks "Revert to Original" button
8. System creates new override: current="John Smith" → override="J. Smith"
9. User then corrects again: "J. Smith" → "Jane Smith"
10. Saves with reason: "Correcting attorney identity - Jane Smith, not John"

**Result:** Field now shows "Jane Smith" with full audit trail showing revert + re-correction.

---

#### Flow 4: Bulk Corrections

**Actor:** E-commerce catalog manager
**Goal:** Correct 50 products with same category error
**Duration:** ~2 minutes

**Steps:**
1. User filters products: category="Electronics" AND supplier="SupplierX"
2. Sees 50 products incorrectly categorized (should be "Home Appliances")
3. Selects all 50 products
4. Clicks "Bulk Edit" button
5. CorrectionDialog opens in bulk mode
6. User changes category: "Electronics" → "Home Appliances"
7. User adds reason: "Supplier X catalog error - these are appliances not electronics"
8. Clicks "Apply to 50 items"
9. System validates all 50: ✅ all valid
10. OverrideStore creates 50 field_override records
11. AuditLog creates 50 audit entries (all with same reason, same timestamp)
12. UI updates all 50 products, each showing FieldOverrideIndicator badge
13. Toast: "50 products corrected successfully"

**Result:** 50 products corrected in one operation with audit trail for each.

---

### 4. Edge Cases

#### 4.1 Correcting Already-Corrected Field

**Scenario:** User corrects a field that was previously corrected by another user.

**Behavior:**
- New override supersedes previous override
- Both overrides preserved in audit trail
- Most recent override wins in precedence resolution

**Example:**
```json
// User A corrects merchant
{
  "field": "merchant",
  "extraction_value": "AMZN MKTP",
  "manual_override": "Amazon",
  "audit_trail": [
    { "timestamp": "2025-10-20T10:00:00Z", "by": "userA", "value": "Amazon" }
  ]
}

// User B corrects again
{
  "field": "merchant",
  "extraction_value": "AMZN MKTP",
  "manual_override": "Amazon Marketplace",  // ← supersedes userA's override
  "audit_trail": [
    { "timestamp": "2025-10-20T10:00:00Z", "by": "userA", "value": "Amazon" },
    { "timestamp": "2025-10-21T15:30:00Z", "by": "userB", "value": "Amazon Marketplace" }
  ]
}

// Current value: "Amazon Marketplace" (userB's override)
```

#### 4.2 Reverting to Original Extraction

**Scenario:** User wants to undo their correction and go back to what the parser extracted.

**Behavior:**
- Create new override with value = extraction_value
- Audit trail shows "revert" action
- Effectively removes manual override (precedence falls back to extraction)

**Example:**
```json
// Before revert
{
  "category": {
    "extraction_value": "Shopping",
    "manual_override": "Business Expenses"
  }
}

// User reverts
→ creates override: { "new_value": "Shopping", "action": "revert" }

// After revert
{
  "category": {
    "extraction_value": "Shopping",
    "manual_override": null  // cleared
  }
}

// Current value: "Shopping" (back to extraction)
```

**Alternative Implementation:**
- Just delete the override record
- Audit trail still shows deletion event

#### 4.3 Invalid Override Attempts

**Scenario:** User tries to set invalid values (empty string, wrong type, out of range, etc.).

**Behavior:**
- ValidationEngine rejects override BEFORE persisting
- UI shows inline errors
- No audit entry created for rejected attempts
- User must fix errors to proceed

**Example (Finance):**
```typescript
// User tries to set amount to negative
ValidationEngine.validate({
  field: "amount",
  value: -50.00
})

// Returns:
{
  valid: false,
  error: "Amount must be greater than 0"
}

// UI shows error, does NOT save override
```

#### 4.4 Conflicting Overrides (Multi-User)

**Scenario:** Two users correct the same field simultaneously.

**Behavior:**
- Last write wins (timestamp-based)
- Both corrections logged in audit trail
- Loser sees toast: "Field was updated by [other user]. Your change was not saved."
- Optional: Optimistic locking (version numbers) to prevent overwrite

**Example:**
```typescript
// UserA and UserB both edit merchant at 10:30:00
// UserA saves at 10:30:10
// UserB saves at 10:30:15

// Final state:
{
  "merchant": {
    "manual_override": "UserB's value",  // ← UserB won (later timestamp)
    "audit_trail": [
      { "timestamp": "10:30:10", "by": "userA", "value": "UserA's value" },
      { "timestamp": "10:30:15", "by": "userB", "value": "UserB's value" }
    ]
  }
}

// UserA sees warning: "Merchant was updated by UserB at 10:30:15. Your change was overwritten."
```

#### 4.5 Bulk Corrections with Partial Failures

**Scenario:** User bulk-corrects 100 items, but 5 fail validation.

**Behavior:**
- Validate ALL items BEFORE persisting any
- If any fail, show errors and let user fix
- Alternative: Save valid ones, skip invalid, show summary

**Example:**
```typescript
// User bulk-corrects 100 products: category → "Home Appliances"
// 5 products already have manual overrides that conflict

ValidationEngine.validateBulk(100 items)

// Returns:
{
  valid_count: 95,
  invalid_count: 5,
  errors: [
    { item_id: "prod_42", error: "Category already manually set to 'Electronics'" },
    { item_id: "prod_87", error: "Category already manually set to 'Electronics'" },
    // ... 3 more
  ]
}

// Options:
// 1. Block entire operation: "Fix 5 errors to proceed"
// 2. Partial save: "95 corrected, 5 skipped (see errors)"
```

**Recommendation:** Partial save with clear summary.

#### 4.6 Retroactive Corrections with Effective Dates

**Scenario:** User discovers error in historical data and corrects it, but wants to track "when the correction was made" vs "when the data should have been correct".

**Behavior:**
- Audit entry has two timestamps:
  - `corrected_at`: When user made the correction (2025-10-24)
  - `effective_date`: When the correct value should have been used (2025-01-15)
- Supports bitemporal queries (future vertical 5.1)

**Example (Legal):**
```json
{
  "field": "filing_date",
  "extraction_value": "2025-01-20",
  "manual_override": "2025-01-15",
  "audit_trail": [
    {
      "corrected_at": "2025-10-24T14:00:00Z",  // user made correction today
      "effective_date": "2025-01-15",           // correct value was actually Jan 15
      "changed_by": "user_legal_123",
      "reason": "Court clerk entered wrong date, correcting to actual filing date"
    }
  ]
}
```

**Use case:** "Show me all cases as they were known on 2025-02-01" → use extraction_value (override didn't exist yet).

---

### 5. Success Metrics

**Correction Frequency:**
- Tracks how often users correct data
- High correction rate → parser/normalization needs improvement
- Target: <5% of records require manual correction

**Correction Latency:**
- Time from data ingestion to first correction
- Fast correction → users actively reviewing data
- Target: 90% of corrections within 24 hours of ingestion

**Revert Rate:**
- Percentage of corrections that are later reverted
- High revert rate → users making mistakes or unclear guidance
- Target: <2% revert rate

**Validation Error Rate:**
- Percentage of correction attempts that fail validation
- High error rate → UI not guiding users well
- Target: <1% validation errors

**Field Correction Distribution:**
- Which fields are corrected most often?
- Example: If "merchant" is 60% of corrections → improve merchant normalization
- Helps prioritize parser/rule improvements

**User Satisfaction:**
- Survey: "Was the correction process easy?"
- Target: 4.5/5 stars average

**Audit Compliance:**
- For healthcare/legal: 100% of corrections must have audit trail
- Track: Any corrections without audit entry? (should be 0%)

---

### 6. Business Value

**For Financial Services:**
- **Accurate reporting:** Corrected categories → accurate budget analysis
- **Compliance:** Audit trail for tax deductions, expense reports
- **Time savings:** Bulk corrections save hours vs manual CSV editing
- **ROI:** 10 hours/month saved on data cleanup = $500/month (at $50/hr)

**For Healthcare:**
- **Billing accuracy:** Corrected diagnosis/procedure codes → proper insurance reimbursement
- **Compliance:** HIPAA audit trail for data changes
- **Quality of care:** Accurate patient records → better treatment decisions
- **ROI:** Fewer claim denials (1% reduction = $50K/year for mid-size practice)

**For Legal:**
- **Case management:** Accurate case data → better case tracking
- **Compliance:** Audit trail for court filings, regulatory requirements
- **Time savings:** Paralegals spend 30% less time fixing data
- **ROI:** 20 hours/week saved = $40K/year (at $40/hr paralegal rate)

**For Research:**
- **Data quality:** Corrected author names, citations → accurate bibliometrics
- **Publication readiness:** Clean data → faster manuscript preparation
- **Collaboration:** Shared corrections across team members
- **ROI:** 5 hours/month per researcher saved = $150/month per user (at $30/hr grad student rate)

**For E-commerce:**
- **Catalog accuracy:** Corrected categories → better search/discovery
- **Revenue impact:** Correct prices → no revenue leakage
- **Customer satisfaction:** Accurate product data → fewer returns
- **ROI:** 0.1% improvement in conversion = $10K/month for mid-size store

**For SaaS:**
- **Revenue accuracy:** Corrected MRR → accurate financial reporting
- **Compliance:** Audit trail for revenue recognition (SOX)
- **Customer success:** Accurate subscription data → better retention analysis
- **ROI:** Faster monthly close (2 days → 1 day) = $5K/month CFO time saved

---

### 7. User Experience Goals

**Goal 1: Frictionless Corrections**
- User should be able to correct any field in <3 clicks
- No modal hell (multiple nested dialogs)
- Inline editing where possible
- Clear visual feedback on save

**Goal 2: Transparency**
- Always show audit trail icon/badge on corrected fields
- Hover tooltip shows basic info (who corrected, when)
- Full history available with 1 click
- No hidden changes

**Goal 3: Reversibility**
- Easy to undo mistakes
- "Revert to original" button always available
- Clear warning before reverting
- Audit trail preserves revert action

**Goal 4: Validation Guidance**
- Inline errors (not toast/alert)
- Explain WHY validation failed
- Suggest valid values when possible
- Example: "Category must be one of: Income, Shopping, Business, ..."

**Goal 5: Bulk Operations**
- Select multiple items easily (checkbox, Cmd+click)
- Apply same correction to all selected
- Show preview before saving ("50 items will be updated")
- Partial save with clear error summary

**Goal 6: Accessibility**
- Keyboard navigation (Tab, Enter, Esc)
- Screen reader friendly (ARIA labels)
- High contrast mode for corrected fields
- Focus management (return focus after dialog closes)

---

### 8. Accessibility & Inclusivity

**Screen Reader Support:**
- ARIA labels on all correction UI elements
- Announce validation errors: `aria-live="polite"`
- FieldOverrideIndicator badge: `aria-label="Manually corrected by [user] on [date]"`
- AuditTrailViewer: Timeline structured as `<ol>` with semantic HTML

**Keyboard Navigation:**
- CorrectionDialog opens with focus on first editable field
- Tab through fields, Esc to cancel, Enter to save
- AuditTrailViewer timeline navigable with arrow keys
- Bulk selection with Shift+click or Ctrl+A

**Visual Accessibility:**
- FieldOverrideIndicator badge: High contrast color (orange/blue, not just red/green)
- Validation errors: Icon + text (not just color)
- AuditTrailViewer: Large text, clear timestamps
- Dark mode support

**Language Support:**
- Correction reasons can be in any language
- Audit trail timestamps localized to user's timezone
- Error messages localized (English, Spanish, French, etc.)

**Cognitive Accessibility:**
- Simple, clear language: "Revert to original" not "Rollback override to extraction value"
- Confirmations for destructive actions: "Are you sure you want to revert 50 corrections?"
- Progress indicators for bulk operations

---

### 9. Localization & Internationalization

**UI Labels:**
- All button/field labels translatable
- Supported languages: English, Spanish, French, German, Portuguese, Japanese
- Example: "Correct" button → "Corregir" (Spanish), "Corriger" (French)

**Validation Messages:**
- Error messages in user's language
- Example: "Amount must be greater than 0" → "La cantidad debe ser mayor que 0" (Spanish)

**Audit Trail Timestamps:**
- Display in user's timezone
- Format based on locale (US: MM/DD/YYYY, Europe: DD/MM/YYYY, ISO: YYYY-MM-DD)
- Example: "2025-10-24T14:30:00Z" → "10/24/2025 2:30 PM EST" (US) or "24/10/2025 14:30 EST" (Europe)

**Correction Reasons:**
- Users can enter reasons in any language
- No translation required (stored as-is)
- Search/filter audit trail supports Unicode

**Number Formatting:**
- Respect locale for amounts (US: 1,234.56, Europe: 1.234,56)
- Date inputs accept locale format
- Validation accepts multiple formats

---

### 10. Product Roadmap & Iteration

**v1.0 (Current):**
- ✅ Field-level overrides
- ✅ Audit trail per field
- ✅ Precedence resolution
- ✅ Validation engine
- ✅ Single-item corrections
- ✅ Bulk corrections
- ✅ Revert capability

**v1.1 (Next 3 months):**
- 🔄 Suggested corrections (NO AI, just rules)
  - Example: "10 transactions with merchant 'AMZN MKTP*' → suggest 'Amazon'?"
  - User reviews and applies in bulk
- 🔄 Correction templates
  - Save common corrections as templates
  - Example: "Fix all AMZN variants → Amazon Marketplace"
- 🔄 Correction analytics dashboard
  - Which fields corrected most?
  - Which users correct most?
  - Correction trends over time

**v2.0 (6-12 months):**
- 🔮 Multi-field validations
  - Example: If category="Income", amount must be positive
  - Cross-field consistency checks
- 🔮 Approval workflows
  - Junior analyst corrects → senior analyst approves
  - For high-stakes domains (healthcare, legal)
- 🔮 Correction notifications
  - Alert user when their data is corrected by someone else
  - Email digest: "5 corrections made to your reports this week"

**v3.0 (Future):**
- 🔮 Integration with Provenance Ledger (Vertical 5.1)
  - Bitemporal corrections (transaction time vs valid time)
  - "As of" queries: "Show me data as it was known on 2025-02-01"
- 🔮 Correction API
  - External systems can submit corrections programmatically
  - Example: Accounting system corrects amount via API
- 🔮 Machine learning insights (OPTIONAL)
  - Learn from corrections to improve parser
  - Example: "90% of 'AMZN MKTP*' corrected to 'Amazon' → auto-apply rule?"
  - **Note:** Still NO auto-corrections, just rule suggestions for user to approve

---

## Machinery Layer

### 11. Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Corrections Flow                          │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      Interaction Layer (IL)                      │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌──────────────────┐  ┌────────────────┐ │
│  │ CorrectionDialog│  │ AuditTrailViewer │  │ FieldOverride  │ │
│  │                 │  │                  │  │   Indicator    │ │
│  │ - Edit fields   │  │ - Show timeline  │  │                │ │
│  │ - Bulk mode     │  │ - Filter by user │  │ - Badge icon   │ │
│  │ - Validation UI │  │ - Export audit   │  │ - Tooltip      │ │
│  └─────────────────┘  └──────────────────┘  └────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                     Objective Layer (OL)                         │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐    │
│  │OverrideStore │  │  AuditLog    │  │PrecedenceEngine    │    │
│  │              │  │              │  │                    │    │
│  │- CRUD        │  │- Log changes │  │- Resolve value     │    │
│  │- Get by ID   │  │- Query trail │  │- Apply precedence  │    │
│  │- Bulk save   │  │- Export      │  │- Handle conflicts  │    │
│  └──────────────┘  └──────────────┘  └────────────────────┘    │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              ValidationEngine                            │  │
│  │                                                          │  │
│  │  - Type validation                                       │  │
│  │  - Range validation                                      │  │
│  │  - Format validation                                     │  │
│  │  - Business logic validation                             │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                               │
                               ↓
┌─────────────────────────────────────────────────────────────────┐
│                       Data Storage                               │
├─────────────────────────────────────────────────────────────────┤
│  ┌────────────────────┐      ┌──────────────────────────┐       │
│  │ field_overrides    │      │ audit_log                │       │
│  │  table (Postgres)  │      │  table (Postgres)        │       │
│  │                    │      │                          │       │
│  │ - override_id (PK) │      │ - audit_id (PK)          │       │
│  │ - entity_id        │      │ - entity_id              │       │
│  │ - field_name       │      │ - field_name             │       │
│  │ - override_value   │      │ - action (extract/       │       │
│  │ - original_value   │      │   override/revert)       │       │
│  │ - overridden_by    │      │ - previous_value         │       │
│  │ - overridden_at    │      │ - new_value              │       │
│  │ - reason (text)    │      │ - changed_by             │       │
│  │ - metadata (JSONB) │      │ - timestamp              │       │
│  └────────────────────┘      │ - reason                 │       │
│                              │ - metadata (JSONB)       │       │
│                              └──────────────────────────┘       │
└─────────────────────────────────────────────────────────────────┘
```

**Data Flow (Correction):**
1. User edits field in `CorrectionDialog`
2. `ValidationEngine` validates input
3. If valid → `OverrideStore.create()` saves override
4. `AuditLog.log()` creates audit entry
5. `PrecedenceEngine.resolve()` recomputes final value
6. UI updates with new value + `FieldOverrideIndicator` badge

**Data Flow (Query):**
1. User opens transaction in UI
2. System calls `PrecedenceEngine.resolveAll(entity_id)` to get final values for all fields
3. For each field, checks: manual override? → rule? → extraction? → default
4. Returns final values + metadata (is_overridden, overridden_by, etc.)
5. UI renders values + badges for overridden fields

**Data Flow (Audit Trail):**
1. User clicks `FieldOverrideIndicator` badge
2. UI calls `AuditLog.getHistory(entity_id, field_name)`
3. Returns timeline of all changes to that field
4. `AuditTrailViewer` renders timeline

---

### 12. Component Specifications

See individual primitive files for detailed specifications:

**Objective Layer (OL):**
- **OverrideStore** ([docs/primitives/ol/OverrideStore.md](../primitives/ol/OverrideStore.md))
  - CRUD operations for field overrides
  - Bulk save/delete
  - Query by entity, field, user, date range

- **AuditLog** ([docs/primitives/ol/AuditLog.md](../primitives/ol/AuditLog.md))
  - Log all field changes (extraction, override, revert)
  - Query audit trail with filters
  - Export audit log (CSV, JSON)

- **PrecedenceEngine** ([docs/primitives/ol/PrecedenceEngine.md](../primitives/ol/PrecedenceEngine.md))
  - Resolve field values using precedence rules
  - Handle multi-source conflicts
  - Batch resolution for performance

- **ValidationEngine** ([docs/primitives/ol/ValidationEngine.md](../primitives/ol/ValidationEngine.md))
  - Type, range, format, business logic validation
  - Extensible validation rules
  - Batch validation for bulk corrections

**Interaction Layer (IL):**
- **CorrectionDialog** ([docs/primitives/il/CorrectionDialog.md](../primitives/il/CorrectionDialog.md))
  - Modal/drawer for editing fields
  - Single-item and bulk modes
  - Inline validation feedback

- **AuditTrailViewer** ([docs/primitives/il/AuditTrailViewer.md](../primitives/il/AuditTrailViewer.md))
  - Timeline visualization of field changes
  - Filter by user, date, action type
  - Export audit trail

- **FieldOverrideIndicator** ([docs/primitives/il/FieldOverrideIndicator.md](../primitives/il/FieldOverrideIndicator.md))
  - Badge/icon showing field was manually corrected
  - Tooltip with basic info
  - Click to open audit trail

---

### 13. Reusability & Multi-Domain Examples

The Corrections Flow pattern applies to ANY system with extracted/normalized data that requires manual review and correction.

#### 13.1 Finance: Transaction Corrections

**Use Case:** Financial analyst corrects bank transaction data.

**Fields Corrected:**
- `merchant`: "AMZN MKTP US*AB123" → "Amazon Marketplace"
- `category`: "Shopping" → "Business Expenses"
- `amount`: $123.45 → $1,234.56 (parser misread decimal)
- `date`: 2025-10-20 → 2025-10-19 (bank posted next day)

**Primitives Used:**
- `OverrideStore`: Save overrides to `transactions` table
- `AuditLog`: Log who corrected for expense report audits
- `PrecedenceEngine`: manual > rule > extraction
- `ValidationEngine`: amount > 0, category from allowed list

**UI:**
- `CorrectionDialog`: Edit transaction fields
- `AuditTrailViewer`: Show transaction correction history
- `FieldOverrideIndicator`: Badge on corrected transactions

**Value:** Accurate expense reports, tax deductions, budget analysis.

---

#### 13.2 Healthcare: Patient Record Corrections

**Use Case:** Nurse corrects diagnosis code extracted from physician notes.

**Fields Corrected:**
- `diagnosis_code`: "E11.9" → "E11.65" (diabetes with CKD)
- `provider`: "Dr. Smith" → "Dr. John Smith, MD"
- `procedure_date`: 2025-10-21 → 2025-10-20 (OCR error)
- `insurance_id`: "ABC12345" → "ABC123456" (missing digit)

**Primitives Used:**
- `OverrideStore`: Save overrides to `patient_records` table
- `AuditLog`: HIPAA-compliant audit trail
- `PrecedenceEngine`: manual > rule > extraction
- `ValidationEngine`: diagnosis_code must be valid ICD-10, provider not empty

**UI:**
- `CorrectionDialog`: Edit patient record fields (HIPAA-secure)
- `AuditTrailViewer`: Show record change history for compliance
- `FieldOverrideIndicator`: Badge on corrected fields

**Value:** Accurate billing codes → proper insurance reimbursement, compliance.

---

#### 13.3 Legal: Case Data Corrections

**Use Case:** Legal assistant corrects case information extracted from court filings.

**Fields Corrected:**
- `case_number`: "2025-CV-1234" → "2025-CV-12345" (OCR missed digit)
- `attorney`: "J. Smith" → "Jane Smith, Esq."
- `filing_date`: 2025-01-20 → 2025-01-15 (clerk error)
- `court`: "Superior Court" → "Superior Court of California"

**Primitives Used:**
- `OverrideStore`: Save overrides to `cases` table
- `AuditLog`: Audit trail for court filing compliance
- `PrecedenceEngine`: manual > rule > extraction
- `ValidationEngine`: case_number format, filing_date not in future

**UI:**
- `CorrectionDialog`: Edit case fields
- `AuditTrailViewer`: Show case correction history
- `FieldOverrideIndicator`: Badge on corrected case fields

**Value:** Accurate case tracking, compliance with court requirements.

---

#### 13.4 Research: Publication Metadata Corrections

**Use Case:** Research coordinator corrects author names/publication data extracted from PDFs.

**Fields Corrected:**
- `author`: "Smith, J." → "Smith, John A."
- `publication_year`: 2024 → 2023 (metadata error)
- `journal`: "J. Med." → "Journal of Medicine"
- `doi`: "10.1234/abc" → "10.1234/abcd" (typo)

**Primitives Used:**
- `OverrideStore`: Save overrides to `publications` table
- `AuditLog`: Track who corrected for data quality reports
- `PrecedenceEngine`: manual > rule > extraction
- `ValidationEngine`: DOI format, year between 1900-2030

**UI:**
- `CorrectionDialog`: Edit publication fields
- `AuditTrailViewer`: Show publication correction history
- `FieldOverrideIndicator`: Badge on corrected metadata

**Value:** Accurate bibliometrics, publication-ready data.

---

#### 13.5 E-commerce: Product Catalog Corrections

**Use Case:** Catalog manager corrects product data extracted from supplier catalogs.

**Fields Corrected:**
- `product_name`: "Widget 2000" → "SuperWidget 2000 Pro"
- `category`: "Electronics" → "Home Appliances"
- `price`: $99.99 → $199.99 (supplier catalog error)
- `sku`: "WGT2000" → "WGT2000-PRO"

**Primitives Used:**
- `OverrideStore`: Save overrides to `products` table
- `AuditLog`: Track who corrected for inventory audits
- `PrecedenceEngine`: manual > rule > extraction
- `ValidationEngine`: price > 0, category from taxonomy

**UI:**
- `CorrectionDialog`: Edit product fields (with image preview)
- `AuditTrailViewer`: Show product correction history
- `FieldOverrideIndicator`: Badge on corrected products

**Value:** Accurate product catalog → better search/discovery → higher conversion.

---

#### 13.6 SaaS: Subscription Data Corrections

**Use Case:** Operations analyst corrects subscription data extracted from billing system.

**Fields Corrected:**
- `plan_name`: "Pro" → "Pro Annual"
- `mrr`: $50 → $500 (billing system bug)
- `billing_cycle`: "monthly" → "annual"
- `start_date`: 2025-10-01 → 2025-09-01 (import error)

**Primitives Used:**
- `OverrideStore`: Save overrides to `subscriptions` table
- `AuditLog`: SOX-compliant audit trail for revenue
- `PrecedenceEngine`: manual > rule > extraction
- `ValidationEngine`: MRR > 0, billing_cycle from enum

**UI:**
- `CorrectionDialog`: Edit subscription fields
- `AuditTrailViewer`: Show subscription correction history
- `FieldOverrideIndicator`: Badge on corrected subscriptions

**Value:** Accurate MRR → reliable financial reporting → investor confidence.

---

### 14. Pattern Abstraction

The Corrections Flow pattern can be abstracted as generic interfaces applicable to any domain.

#### 14.1 Generic FieldOverride Interface

```typescript
interface FieldOverride<T> {
  override_id: string;
  entity_id: string;           // ID of the record being corrected
  entity_type: string;          // "transaction", "patient_record", "case", etc.
  field_name: keyof T;          // Which field is being overridden
  original_value: T[keyof T];   // Value before override (from extraction/rule)
  override_value: T[keyof T];   // User's corrected value
  overridden_by: string;        // User ID who made correction
  overridden_at: string;        // ISO 8601 timestamp
  reason?: string;              // Optional explanation
  metadata?: Record<string, any>; // Extensible metadata
}

// Example: Finance
type Transaction = {
  merchant: string;
  amount: number;
  category: string;
  date: string;
};

const override: FieldOverride<Transaction> = {
  override_id: "ovr_abc123",
  entity_id: "txn_xyz789",
  entity_type: "transaction",
  field_name: "merchant",
  original_value: "AMZN MKTP US*AB123",
  override_value: "Amazon Marketplace",
  overridden_by: "user_123",
  overridden_at: "2025-10-24T10:30:00Z",
  reason: "Normalize merchant name for reporting"
};

// Example: Healthcare
type PatientRecord = {
  diagnosis_code: string;
  provider: string;
  procedure_date: string;
};

const override2: FieldOverride<PatientRecord> = {
  override_id: "ovr_def456",
  entity_id: "patient_456",
  entity_type: "patient_record",
  field_name: "diagnosis_code",
  original_value: "E11.9",
  override_value: "E11.65",
  overridden_by: "nurse_789",
  overridden_at: "2025-10-24T11:00:00Z",
  reason: "Patient has chronic kidney disease"
};
```

#### 14.2 Generic AuditEntry Interface

```typescript
interface AuditEntry<T> {
  audit_id: string;
  entity_id: string;
  entity_type: string;
  field_name: keyof T;
  action: "extracted" | "override" | "revert" | "delete";
  previous_value?: T[keyof T];  // Value before this action
  new_value: T[keyof T];        // Value after this action
  changed_by: string;           // User ID or system identifier
  timestamp: string;            // ISO 8601
  reason?: string;
  source: string;               // "parser_v2", "manual_correction", "normalization_rule", etc.
  metadata?: Record<string, any>;
}

// Example: Audit trail for merchant field
const auditTrail: AuditEntry<Transaction>[] = [
  {
    audit_id: "audit_001",
    entity_id: "txn_xyz789",
    entity_type: "transaction",
    field_name: "merchant",
    action: "extracted",
    new_value: "AMZN MKTP US*AB123",
    changed_by: "parser_pdf_v2",
    timestamp: "2025-10-20T08:00:00Z",
    source: "parser_pdf_v2",
    metadata: { confidence: 0.95 }
  },
  {
    audit_id: "audit_002",
    entity_id: "txn_xyz789",
    entity_type: "transaction",
    field_name: "merchant",
    action: "override",
    previous_value: "AMZN MKTP US*AB123",
    new_value: "Amazon",
    changed_by: "user_123",
    timestamp: "2025-10-24T10:30:00Z",
    reason: "Normalize merchant",
    source: "manual_correction"
  },
  {
    audit_id: "audit_003",
    entity_id: "txn_xyz789",
    entity_type: "transaction",
    field_name: "merchant",
    action: "override",
    previous_value: "Amazon",
    new_value: "Amazon Marketplace",
    changed_by: "user_456",
    timestamp: "2025-10-25T14:00:00Z",
    reason: "More specific merchant name",
    source: "manual_correction"
  }
];
```

#### 14.3 Generic PrecedenceResolution Interface

```typescript
interface PrecedenceResolution<T> {
  field_name: keyof T;
  final_value: T[keyof T];       // Value to use after precedence resolution
  source: "manual" | "rule" | "extraction" | "default";
  sources: {                      // All available sources
    manual_override?: T[keyof T];
    rule_value?: T[keyof T];
    extraction_value?: T[keyof T];
    default_value?: T[keyof T];
  };
  metadata: {
    is_overridden: boolean;
    overridden_by?: string;
    overridden_at?: string;
  };
}

// Example: Resolve merchant field
const resolution: PrecedenceResolution<Transaction> = {
  field_name: "merchant",
  final_value: "Amazon Marketplace",
  source: "manual",
  sources: {
    manual_override: "Amazon Marketplace",
    rule_value: "Amazon",
    extraction_value: "AMZN MKTP US*AB123",
    default_value: "Unknown Merchant"
  },
  metadata: {
    is_overridden: true,
    overridden_by: "user_456",
    overridden_at: "2025-10-25T14:00:00Z"
  }
};

// Example: Resolve category field (no override)
const resolution2: PrecedenceResolution<Transaction> = {
  field_name: "category",
  final_value: "Shopping",
  source: "extraction",
  sources: {
    extraction_value: "Shopping",
    default_value: "Uncategorized"
  },
  metadata: {
    is_overridden: false
  }
};
```

#### 14.4 Generic ValidationResult Interface

```typescript
interface ValidationResult {
  valid: boolean;
  errors?: ValidationError[];
}

interface ValidationError {
  field: string;
  error: string;
  suggested_value?: any;
}

// Example: Validate transaction correction
const validationResult: ValidationResult = {
  valid: false,
  errors: [
    {
      field: "amount",
      error: "Must be a positive number",
      suggested_value: null
    },
    {
      field: "category",
      error: "Must be one of: Income, Shopping, Business, Travel",
      suggested_value: "Shopping"
    }
  ]
};
```

#### 14.5 Generic OverrideStore Interface

```typescript
interface IOverrideStore<T> {
  // Create single override
  create(override: Omit<FieldOverride<T>, "override_id" | "overridden_at">): Promise<FieldOverride<T>>;

  // Bulk create
  createBulk(overrides: Omit<FieldOverride<T>, "override_id" | "overridden_at">[]): Promise<FieldOverride<T>[]>;

  // Get override by ID
  getById(overrideId: string): Promise<FieldOverride<T> | null>;

  // Get all overrides for an entity
  getByEntity(entityId: string): Promise<FieldOverride<T>[]>;

  // Get overrides for specific field
  getByField(entityId: string, fieldName: keyof T): Promise<FieldOverride<T> | null>;

  // Delete override (revert to original)
  delete(overrideId: string): Promise<void>;

  // Query with filters
  query(filters: {
    entity_type?: string;
    field_name?: keyof T;
    overridden_by?: string;
    date_range?: { start: string; end: string };
  }): Promise<FieldOverride<T>[]>;
}
```

#### 14.6 Generic PrecedenceEngine Interface

```typescript
interface IPrecedenceEngine<T> {
  // Resolve single field
  resolveField(
    entityId: string,
    fieldName: keyof T,
    sources: {
      manual_override?: T[keyof T];
      rule_value?: T[keyof T];
      extraction_value?: T[keyof T];
      default_value?: T[keyof T];
    }
  ): Promise<PrecedenceResolution<T>>;

  // Resolve all fields for entity
  resolveAll(entityId: string): Promise<Record<keyof T, PrecedenceResolution<T>>>;

  // Get precedence rules
  getPrecedenceRules(): PrecedenceRule[];
}

interface PrecedenceRule {
  priority: number;
  source: "manual" | "rule" | "extraction" | "default";
}
```

---

### 15. Integration Points

#### 15.1 Integration with Vertical 1.1 (Upload)

**Scenario:** User uploads a file, parser extracts data, user corrects errors.

**Flow:**
1. User uploads PDF via Vertical 1.1
2. Parser extracts transactions
3. Transactions stored with `source: "extraction"`
4. User reviews transactions in UI
5. User corrects merchant field via `CorrectionDialog`
6. `OverrideStore` saves override
7. `PrecedenceEngine` resolves: manual override > extraction
8. UI shows corrected merchant with `FieldOverrideIndicator` badge

**Data Link:**
- `transactions.transaction_id` = `field_overrides.entity_id`
- `field_overrides.entity_type` = "transaction"

---

#### 15.2 Integration with Vertical 1.3 (Normalization)

**Scenario:** Normalization rule categorizes transaction, user disagrees and overrides.

**Flow:**
1. Transaction extracted: merchant="AMZN MKTP"
2. Normalization rule (Vertical 1.3) applies: merchant → "Amazon"
3. User disagrees, wants "Amazon Marketplace"
4. User corrects via `CorrectionDialog`
5. `OverrideStore` saves override
6. `PrecedenceEngine` resolves: manual override > rule > extraction
7. Final value: "Amazon Marketplace"

**Precedence:**
- `sources.extraction_value` = "AMZN MKTP"
- `sources.rule_value` = "Amazon"
- `sources.manual_override` = "Amazon Marketplace"
- `final_value` = "Amazon Marketplace" (manual wins)

---

#### 15.3 Integration with Vertical 4.2 (Forecast)

**Scenario:** User corrects historical transactions, forecasts should update.

**Flow:**
1. User has 3 months of transaction history
2. Vertical 4.2 forecasts next month's expenses based on history
3. User realizes 10 transactions were miscategorized ("Shopping" should be "Business")
4. User bulk-corrects via `CorrectionDialog`
5. **Trigger:** `OverrideStore.createBulk()` emits event `overrides.created`
6. **Listener:** `ForecastCache` (Vertical 4.2) listens for event
7. **Action:** `ForecastCache.invalidate()` clears cached forecasts
8. Next forecast request re-calculates with corrected data
9. Updated forecast reflects corrected spending patterns

**Integration:**
- Event-driven: Corrections trigger cache invalidation
- Ensures forecasts always use latest corrected data

---

#### 15.4 Integration with Vertical 5.1 (Provenance Ledger)

**Scenario:** Advanced bitemporal tracking (transaction time vs valid time).

**Flow:**
1. User discovers filing_date was wrong (extracted as 2025-01-20, should be 2025-01-15)
2. User corrects on 2025-10-24
3. Correction stored with:
   - `corrected_at`: 2025-10-24 (transaction time = when correction made)
   - `effective_date`: 2025-01-15 (valid time = when correct value should have been)
4. Provenance Ledger (Vertical 5.1) supports "as of" queries:
   - Query: "Show me all cases as known on 2025-02-01"
   - Answer: Use `extraction_value` (correction didn't exist yet)
   - Query: "Show me all cases as they actually were on 2025-01-15"
   - Answer: Use `override_value` (correct value, retroactively applied)

**Integration:**
- `AuditEntry` stores both `timestamp` (transaction time) and `metadata.effective_date` (valid time)
- Provenance Ledger uses this for bitemporal queries

---

#### 15.5 Integration with External Systems

**API Endpoint: Submit Correction**

```typescript
POST /api/corrections

{
  "entity_id": "txn_xyz789",
  "entity_type": "transaction",
  "field_name": "merchant",
  "override_value": "Amazon Marketplace",
  "reason": "Normalize merchant name"
}

// Response:
{
  "override_id": "ovr_abc123",
  "status": "created",
  "audit_id": "audit_456"
}
```

**Use Case:** Accounting system auto-corrects merchant names via API.

**API Endpoint: Get Audit Trail**

```typescript
GET /api/corrections/audit?entity_id=txn_xyz789&field_name=merchant

// Response:
{
  "entity_id": "txn_xyz789",
  "field_name": "merchant",
  "audit_trail": [
    {
      "timestamp": "2025-10-20T08:00:00Z",
      "action": "extracted",
      "value": "AMZN MKTP US*AB123",
      "source": "parser_v2"
    },
    {
      "timestamp": "2025-10-24T10:30:00Z",
      "action": "override",
      "previous_value": "AMZN MKTP US*AB123",
      "new_value": "Amazon Marketplace",
      "changed_by": "user_123",
      "reason": "Normalize merchant name"
    }
  ]
}
```

**Use Case:** External audit system retrieves correction history for compliance.

---

## Cross-Cutting Concerns

### 16. Security & Privacy

#### 16.1 Access Control

**Requirement:** Only authorized users can correct data.

**Implementation:**
- Role-based access control (RBAC)
- Permissions: `corrections.create`, `corrections.view_audit`, `corrections.delete`
- Example: Junior analyst can create corrections, senior analyst can view audit trail

**Code:**
```typescript
// Check permission before allowing correction
if (!user.hasPermission("corrections.create")) {
  throw new ForbiddenError("You don't have permission to correct data");
}

OverrideStore.create({
  entity_id: "txn_123",
  field_name: "merchant",
  override_value: "Amazon",
  overridden_by: user.id
});
```

#### 16.2 Data Privacy (PII)

**Requirement:** Protect personally identifiable information in audit logs.

**Implementation:**
- Audit log stores field names, not sensitive values (configurable)
- Example: Log "SSN field corrected" not "SSN changed from 123-45-6789 to 987-65-4321"
- Healthcare: HIPAA compliance (encrypt audit logs, access logs)

**Code:**
```typescript
// Configuration per entity type
const auditConfig = {
  transaction: {
    sensitive_fields: [], // No PII in transactions
    log_values: true
  },
  patient_record: {
    sensitive_fields: ["ssn", "diagnosis_code"],
    log_values: false  // Don't log actual values, just "field corrected"
  }
};

// When logging
if (auditConfig[entityType].sensitive_fields.includes(fieldName)) {
  AuditLog.log({
    field_name: fieldName,
    action: "override",
    // Don't log previous_value or new_value for PII fields
    changed_by: user.id,
    timestamp: now()
  });
} else {
  AuditLog.log({
    field_name: fieldName,
    action: "override",
    previous_value: originalValue,
    new_value: overrideValue,
    changed_by: user.id,
    timestamp: now()
  });
}
```

#### 16.3 Audit Log Integrity

**Requirement:** Audit logs must be immutable (cannot be edited/deleted).

**Implementation:**
- Append-only table (no UPDATE or DELETE operations)
- Optional: Cryptographic signatures (hash each entry)
- Optional: Write to separate audit database (read-only from main app)

**Code:**
```typescript
// Append-only table (PostgreSQL)
CREATE TABLE audit_log (
  audit_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_id VARCHAR NOT NULL,
  field_name VARCHAR NOT NULL,
  action VARCHAR NOT NULL,
  previous_value TEXT,
  new_value TEXT,
  changed_by VARCHAR NOT NULL,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  signature VARCHAR  -- SHA-256 hash of entry for tamper detection
);

// Revoke UPDATE and DELETE permissions
REVOKE UPDATE, DELETE ON audit_log FROM app_user;
GRANT INSERT, SELECT ON audit_log TO app_user;
```

#### 16.4 Multi-Tenancy

**Requirement:** Users can only correct data in their own tenant.

**Implementation:**
- Add `tenant_id` to `field_overrides` and `audit_log` tables
- Filter all queries by current user's tenant
- Example: User in tenant "ACME Corp" cannot correct data in tenant "Widget Inc"

**Code:**
```typescript
// When creating override
OverrideStore.create({
  entity_id: "txn_123",
  tenant_id: user.tenant_id,  // ← Enforce tenant isolation
  field_name: "merchant",
  override_value: "Amazon",
  overridden_by: user.id
});

// When querying
OverrideStore.getByEntity(entityId, user.tenant_id);  // ← Filter by tenant
```

---

### 17. Performance & Scalability

#### 17.1 Bulk Correction Performance

**Requirement:** Bulk-correct 1,000 items in <10 seconds.

**Strategy:**
- Batch INSERT for overrides (not 1,000 individual INSERTs)
- Batch INSERT for audit log entries
- Use database transactions to ensure atomicity

**Code:**
```typescript
async createBulk(overrides: FieldOverride[]): Promise<void> {
  // Single batch INSERT instead of 1,000 individual INSERTs
  const query = `
    INSERT INTO field_overrides
      (entity_id, field_name, override_value, original_value, overridden_by, reason)
    VALUES
      ${overrides.map(() => '(?, ?, ?, ?, ?, ?)').join(', ')}
  `;

  const values = overrides.flatMap(o => [
    o.entity_id,
    o.field_name,
    o.override_value,
    o.original_value,
    o.overridden_by,
    o.reason
  ]);

  await db.execute(query, values);

  // Also batch INSERT audit entries
  await AuditLog.logBulk(overrides.map(o => ({
    entity_id: o.entity_id,
    field_name: o.field_name,
    action: "override",
    previous_value: o.original_value,
    new_value: o.override_value,
    changed_by: o.overridden_by
  })));
}
```

**Performance:**
- 1,000 overrides: <5 seconds (batch INSERT)
- vs. 1,000 individual INSERTs: ~2 minutes

#### 17.2 Precedence Resolution Performance

**Requirement:** Resolve final values for 100 transactions in <100ms.

**Strategy:**
- Batch query: Fetch all overrides for 100 transactions in one query
- In-memory resolution (no database queries per field)
- Cache frequently-accessed resolutions (optional)

**Code:**
```typescript
async resolveAllBatch(entityIds: string[]): Promise<Map<string, Record<string, any>>> {
  // 1. Fetch all overrides for these entities in one query
  const overrides = await db.query(`
    SELECT entity_id, field_name, override_value
    FROM field_overrides
    WHERE entity_id IN (${entityIds.map(() => '?').join(', ')})
  `, entityIds);

  // 2. Group overrides by entity
  const overridesByEntity = new Map<string, Map<string, any>>();
  for (const override of overrides) {
    if (!overridesByEntity.has(override.entity_id)) {
      overridesByEntity.set(override.entity_id, new Map());
    }
    overridesByEntity.get(override.entity_id)!.set(override.field_name, override.override_value);
  }

  // 3. Resolve in-memory (no more DB queries)
  const results = new Map<string, Record<string, any>>();
  for (const entityId of entityIds) {
    const entityOverrides = overridesByEntity.get(entityId) || new Map();
    const entity = await getEntity(entityId);  // Fetch entity data

    const resolved: Record<string, any> = {};
    for (const field of Object.keys(entity)) {
      resolved[field] = entityOverrides.has(field)
        ? entityOverrides.get(field)  // manual override
        : entity[field];                // original value
    }

    results.set(entityId, resolved);
  }

  return results;
}
```

**Performance:**
- 100 transactions: <100ms (single DB query + in-memory resolution)
- vs. 100 individual queries: ~5 seconds

#### 17.3 Audit Trail Query Performance

**Requirement:** Load audit trail for 1 field in <200ms.

**Strategy:**
- Index on `(entity_id, field_name, timestamp)`
- Limit results (e.g., last 50 entries)
- Paginate for very long audit trails

**Code:**
```sql
-- Index for fast audit trail queries
CREATE INDEX idx_audit_entity_field_time
  ON audit_log(entity_id, field_name, timestamp DESC);

-- Query audit trail
SELECT * FROM audit_log
WHERE entity_id = 'txn_123' AND field_name = 'merchant'
ORDER BY timestamp DESC
LIMIT 50;
```

**Performance:**
- Query with index: <50ms
- Without index: ~2 seconds (full table scan)

#### 17.4 Scalability: Million Overrides

**Requirement:** Support 1M+ overrides without performance degradation.

**Strategy:**
- Partition `field_overrides` table by `entity_type` or `created_at`
- Archive old audit log entries (move to cold storage after 1 year)
- Use read replicas for audit trail queries (don't impact write performance)

**Code:**
```sql
-- Partition by entity_type
CREATE TABLE field_overrides_transaction PARTITION OF field_overrides
  FOR VALUES IN ('transaction');

CREATE TABLE field_overrides_patient_record PARTITION OF field_overrides
  FOR VALUES IN ('patient_record');

-- Archive old audit entries
INSERT INTO audit_log_archive
SELECT * FROM audit_log
WHERE timestamp < NOW() - INTERVAL '1 year';

DELETE FROM audit_log
WHERE timestamp < NOW() - INTERVAL '1 year';
```

---

### 18. Observability & Debugging

#### 18.1 Metrics

**Corrections Per Day:**
- Track total corrections created per day
- Alert if sudden spike (may indicate data quality issue)

```typescript
metrics.increment("corrections.created", {
  entity_type: "transaction",
  field_name: "merchant",
  user: user.id
});
```

**Validation Error Rate:**
- Track % of correction attempts that fail validation
- High error rate → improve UI guidance

```typescript
metrics.increment("corrections.validation_failed", {
  field_name: "amount",
  error_type: "invalid_format"
});
```

**Revert Rate:**
- Track % of corrections that are later reverted
- High revert rate → users making mistakes

```typescript
metrics.increment("corrections.reverted", {
  entity_type: "transaction",
  field_name: "category"
});
```

**Field Correction Distribution:**
- Which fields are corrected most often?
- Example: 60% merchant, 30% category, 10% amount

```typescript
metrics.distribution("corrections.by_field", field_name);
```

#### 18.2 Structured Logs

**Log Every Correction:**
```json
{
  "timestamp": "2025-10-24T10:30:00Z",
  "level": "INFO",
  "event": "correction.created",
  "entity_id": "txn_123",
  "entity_type": "transaction",
  "field_name": "merchant",
  "original_value": "AMZN MKTP",
  "override_value": "Amazon Marketplace",
  "overridden_by": "user_123",
  "reason": "Normalize merchant name",
  "validation_passed": true
}
```

**Log Validation Failures:**
```json
{
  "timestamp": "2025-10-24T10:35:00Z",
  "level": "WARN",
  "event": "correction.validation_failed",
  "entity_id": "txn_456",
  "field_name": "amount",
  "attempted_value": "abc",
  "error": "Must be a valid number",
  "user": "user_789"
}
```

**Log Reverts:**
```json
{
  "timestamp": "2025-10-24T10:40:00Z",
  "level": "INFO",
  "event": "correction.reverted",
  "entity_id": "txn_123",
  "field_name": "category",
  "previous_override": "Business Expenses",
  "reverted_to": "Shopping",
  "reverted_by": "user_456",
  "reason": "Original categorization was correct"
}
```

#### 18.3 Dashboards

**Corrections Dashboard:**
- Total corrections per day (line chart)
- Top 10 corrected fields (bar chart)
- Validation error rate (gauge)
- Revert rate (gauge)
- Top 10 users by corrections (table)

**Audit Activity Dashboard:**
- Audit trail query volume (line chart)
- Average audit trail length per entity (histogram)
- Top 10 entities by audit trail length (table)

---

### 19. Testing Strategy

#### 19.1 Unit Tests

**OverrideStore:**
- ✅ `create()` saves override to database
- ✅ `getByEntity()` returns all overrides for entity
- ✅ `getByField()` returns override for specific field
- ✅ `delete()` removes override
- ✅ `createBulk()` saves multiple overrides in batch

**AuditLog:**
- ✅ `log()` creates audit entry
- ✅ `getHistory()` returns audit trail for field
- ✅ `query()` filters audit entries by user, date, action

**PrecedenceEngine:**
- ✅ `resolveField()` returns manual override when present
- ✅ `resolveField()` falls back to rule value when no override
- ✅ `resolveField()` falls back to extraction when no override/rule
- ✅ `resolveAll()` resolves all fields for entity

**ValidationEngine:**
- ✅ `validate()` accepts valid values
- ✅ `validate()` rejects invalid type (string for number field)
- ✅ `validate()` rejects out-of-range values (negative amount)
- ✅ `validate()` rejects invalid format (bad category)

#### 19.2 Integration Tests

**Full Correction Flow:**
1. Create entity (transaction)
2. User corrects field via `OverrideStore.create()`
3. Verify override saved
4. Verify audit entry created
5. Verify `PrecedenceEngine.resolveField()` returns corrected value
6. Verify UI shows `FieldOverrideIndicator` badge

**Bulk Correction Flow:**
1. Create 100 entities
2. User bulk-corrects via `OverrideStore.createBulk()`
3. Verify 100 overrides saved
4. Verify 100 audit entries created
5. Verify all entities show corrected values

**Revert Flow:**
1. Create entity with override
2. User reverts via `OverrideStore.delete()`
3. Verify override removed
4. Verify audit entry created (action: "revert")
5. Verify `PrecedenceEngine.resolveField()` returns original extraction value

#### 19.3 E2E Tests

**User Corrects Transaction (UI):**
1. User logs in
2. User navigates to transaction list
3. User clicks "Edit" on transaction
4. CorrectionDialog opens
5. User changes merchant field
6. User enters reason
7. User clicks "Save"
8. Verify toast: "Merchant corrected successfully"
9. Verify transaction shows new merchant with badge
10. User clicks badge
11. Verify AuditTrailViewer opens showing correction

**User Bulk-Corrects Products (UI):**
1. User logs in
2. User filters products: category="Electronics"
3. User selects 50 products
4. User clicks "Bulk Edit"
5. CorrectionDialog opens in bulk mode
6. User changes category to "Home Appliances"
7. User enters reason
8. User clicks "Apply to 50 items"
9. Verify progress bar shown
10. Verify toast: "50 products corrected successfully"
11. Verify all 50 products show new category with badge

#### 19.4 Performance Tests

**Bulk Correction Performance:**
- Create 1,000 entities
- Bulk-correct all 1,000 via API
- **Assertion:** Completes in <10 seconds

**Precedence Resolution Performance:**
- Create 100 entities with overrides
- Resolve all 100 via `resolveAllBatch()`
- **Assertion:** Completes in <100ms

**Audit Trail Query Performance:**
- Create entity with 100 audit entries
- Query audit trail via `getHistory()`
- **Assertion:** Completes in <200ms

---

### 20. Operational Considerations

#### 20.1 Deployment

**Database Migrations:**
- Create `field_overrides` table
- Create `audit_log` table
- Create indexes

```sql
-- Migration: Create field_overrides table
CREATE TABLE field_overrides (
  override_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_id VARCHAR NOT NULL,
  entity_type VARCHAR NOT NULL,
  field_name VARCHAR NOT NULL,
  original_value TEXT,
  override_value TEXT NOT NULL,
  overridden_by VARCHAR NOT NULL,
  overridden_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  reason TEXT,
  metadata JSONB,
  UNIQUE(entity_id, field_name)  -- One override per field per entity
);

CREATE INDEX idx_overrides_entity ON field_overrides(entity_id);
CREATE INDEX idx_overrides_user ON field_overrides(overridden_by);

-- Migration: Create audit_log table
CREATE TABLE audit_log (
  audit_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  entity_id VARCHAR NOT NULL,
  entity_type VARCHAR NOT NULL,
  field_name VARCHAR NOT NULL,
  action VARCHAR NOT NULL,
  previous_value TEXT,
  new_value TEXT,
  changed_by VARCHAR NOT NULL,
  timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  reason TEXT,
  source VARCHAR NOT NULL,
  metadata JSONB
);

CREATE INDEX idx_audit_entity_field_time
  ON audit_log(entity_id, field_name, timestamp DESC);
```

#### 20.2 Monitoring

**Alerts:**
- **High correction rate:** >10% of entities corrected in 24h → investigate data quality
- **High validation error rate:** >5% of corrections fail validation → improve UI
- **High revert rate:** >5% of corrections reverted → user confusion or bad data
- **Audit log growth:** >1M entries/day → consider archiving strategy

**Health Checks:**
- OverrideStore: Can create/query overrides? (test INSERT and SELECT)
- AuditLog: Can log entries? (test INSERT)
- Database: Disk space >80% → alert

#### 20.3 Backup & Recovery

**Backup Strategy:**
- Daily backups of `field_overrides` and `audit_log` tables
- Point-in-time recovery (PITR) for PostgreSQL
- Retention: 30 days

**Recovery Scenarios:**
- **User deletes override by mistake:** Restore from backup (last 30 days)
- **Audit log corruption:** Restore from backup + replay from write-ahead log
- **Full database loss:** Restore from latest backup, accept <24h data loss

#### 20.4 Archiving

**Old Audit Entries:**
- Archive audit entries >1 year old to cold storage (S3)
- Keep last 1 year in hot database for fast queries
- Archive process runs monthly

```typescript
// Archive old audit entries
const archiveAuditLog = async () => {
  const oneYearAgo = new Date();
  oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);

  // 1. Export to S3
  const oldEntries = await db.query(`
    SELECT * FROM audit_log WHERE timestamp < $1
  `, [oneYearAgo]);

  await s3.upload("audit-archive-2024.json", JSON.stringify(oldEntries));

  // 2. Delete from hot database
  await db.execute(`
    DELETE FROM audit_log WHERE timestamp < $1
  `, [oneYearAgo]);
};
```

#### 20.5 Runbook

**Common Issues:**

**Issue:** Correction not showing in UI
- **Check:** Override saved to database? `SELECT * FROM field_overrides WHERE entity_id = 'xxx'`
- **Check:** Precedence resolution returning override? `PrecedenceEngine.resolveField()`
- **Check:** Cache cleared? Clear browser cache, reload page

**Issue:** Validation always failing
- **Check:** ValidationEngine configuration correct?
- **Check:** Error message clear? Show user what values are allowed
- **Check:** Bug in validation logic? Check logs for stack trace

**Issue:** Bulk correction slow (>10 seconds)
- **Check:** Using `createBulk()` or individual `create()` calls? Use batch INSERT
- **Check:** Database indexes present? Check `pg_indexes` table
- **Check:** Database load? Check CPU/memory usage

**Issue:** Audit trail query slow
- **Check:** Index on `(entity_id, field_name, timestamp)`? Verify with `EXPLAIN`
- **Check:** Limiting results? Add `LIMIT 50` to query
- **Check:** Too many old entries? Archive audit log

---

## Appendix

### Related Documents

- **Primitives (OL):**
  - [OverrideStore](../primitives/ol/OverrideStore.md)
  - [AuditLog](../primitives/ol/AuditLog.md)
  - [PrecedenceEngine](../primitives/ol/PrecedenceEngine.md)
  - [ValidationEngine](../primitives/ol/ValidationEngine.md)

- **Primitives (IL):**
  - [CorrectionDialog](../primitives/il/CorrectionDialog.md)
  - [AuditTrailViewer](../primitives/il/AuditTrailViewer.md)
  - [FieldOverrideIndicator](../primitives/il/FieldOverrideIndicator.md)

- **Schemas:**
  - [field-override.schema.json](../schemas/field-override.schema.json)
  - [audit-entry.schema.json](../schemas/audit-entry.schema.json)
  - [precedence-resolution.schema.json](../schemas/precedence-resolution.schema.json)

- **ADRs:**
  - [ADR-0024: Field-Level Overrides](../adr/0024-field-level-overrides.md)
  - [ADR-0025: Audit Storage Strategy](../adr/0025-audit-storage-strategy.md)
  - [ADR-0026: Precedence Resolution](../adr/0026-precedence-resolution.md)

- **UX Flows:**
  - [Corrections Experience](../ux-flows/4.3-corrections-experience.md)

- **Related Verticals:**
  - [1.1 Upload Flow](./1.1-upload-flow.md) - Initial data ingestion
  - [1.3 Normalization](./1.3-normalization.md) - Automated normalization
  - [4.2 Forecast](./4.2-forecast.md) - Forecasts update when data corrected
  - [5.1 Provenance Ledger](./5.1-provenance-ledger.md) - Bitemporal tracking

---

## Changelog

| Version | Date       | Author | Changes                        |
|---------|------------|--------|--------------------------------|
| 1.0     | 2025-10-24 | Claude | Initial specification complete |

---

**End of Vertical 4.3: Corrections Flow**
